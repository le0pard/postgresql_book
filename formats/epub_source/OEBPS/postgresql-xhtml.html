<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="generator" content=
  "HTML Tidy for Linux/x86 (vers 25 March 2009), see www.w3.org" />

  <title>Работа с Postgresql: настройка, масштабирование</title>
  <meta name="description" content=
  "Работа с Postgresql: настройка, масштабирование" />
  <meta name="keywords" content="postgresql" />
  <meta name="resource-type" content="document" />
  <meta name="distribution" content="global" />
  <meta http-equiv="Content-Type" content=
  "text/html; charset=utf-8" />
  <meta name="Generator" content="LaTeX2HTML v2008" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="STYLESHEET" href="postgresql.css" type="text/css" />
</head>

<body>
  <p>=0.1</p>

  <div align="center"></div><br />
  <big class="LARGE">Васильев А.Ю.</big><br />
  <br />
  <br />
  <br />
  <big class="XXLARGE">Работа с Postgresql</big><br />
  <i>настройка, масштабирование</i><br />
  <br />
  <br />
  <br />
  <big class="LARGE">справочное пособие</big>

  <p><big class="LARGE">2010</big><br />
  <small class="SMALL">C<small>REATIVE</small>
  C<small>OMMONS</small>
  A<small>TTRIBUTION-</small>N<small>ONCOMMERCIAL
  2.5</small></small></p>

  <p><br /></p>

  <p>При написании книги(мануала, или просто шпаргалки)
  использовались материалы:</p>

  <ul>
    <li>PostgreSQL: настройка производительности. Алексей Борзов
    (Sad Spirit) borz_off@cs.msu.su,<br />
    http://www.phpclub.ru/detail/store/pdf/postgresql-performance.pdf</li>

    <li>Настройка репликации в PostgreSQL с помощью системы
    Slony-I, Eugene Kuzin eugene@kuzin.net,<br />
    http://www.kuzin.net/work/sloniki-privet.html</li>

    <li>Установка Londiste в подробностях, Sergey Konoplev
    gray.ru@gmail.com,<br />
    http://gray-hemp.blogspot.com/2010/04/londiste.html</li>

    <li>Учебное руководство по pgpool-II, Dmitry Stasyuk,<br />
    http://undenied.ru/2009/03/04/uchebnoe-rukovodstvo-po-pgpool-ii/</li>

    <li>Горизонтальное масштабирование PostgreSQL с помощью
    PL/Proxy, Чиркин Дима dmitry.chirkin@gmail.com,<br />
    http://habrahabr.ru/blogs/postgresql/45475/</li>

    <li>Hadoop, Иван Блинков wordpress@insight-it.ru,<br />
    http://www.insight-it.ru/masshtabiruemost/hadoop/</li>

    <li>Up and Running with HadoopDB, Padraig O'Sullivan,<br />
    http://posulliv.github.com/2010/05/10/hadoopdb-mysql.html</li>

    <li>Масштабирование PostgreSQL: готовые решения от Skype, Иван
    Золотухин,<br />
    http://postgresmen.ru/articles/view/25</li>

    <li>Streaming Replication,<br />
    http://wiki.postgresql.org/wiki/Streaming_Replication</li>

    <li>Шардинг, партиционирование, репликация - зачем и когда?,
    Den Golotyuk,<br />
    http://highload.com.ua/index.php/2009/05/06/шардинг-партиционирование-репликац/</li>
  </ul>

  <p>ell<br /></p>

  <h2><a name="SECTION00100000000000000000" id=
  "SECTION00100000000000000000">Contents</a></h2>
  <!--Table of Contents-->

  <ul class="TofC">
    <li><a name="tex2html109" href=
    "postgresql.html#SECTION00200000000000000000" id=
    "tex2html109">1 Введение</a></li>

    <li>
      <a name="tex2html110" href=
      "postgresql.html#SECTION00300000000000000000" id=
      "tex2html110">2 Настройка производительности</a>

      <ul>
        <li>
          <a name="tex2html111" href=
          "postgresql.html#SECTION00310000000000000000" id=
          "tex2html111">1 Введение</a>

          <ul>
            <li><a name="tex2html112" href=
            "postgresql.html#SECTION00311000000000000000" id=
            "tex2html112">1 Не используйте настройки по
            умолчанию</a></li>

            <li><a name="tex2html113" href=
            "postgresql.html#SECTION00312000000000000000" id=
            "tex2html113">2 Используйте актуальную версию
            сервера</a></li>

            <li><a name="tex2html114" href=
            "postgresql.html#SECTION00313000000000000000" id=
            "tex2html114">3 Стоит ли доверять тестам
            производительности</a></li>
          </ul>
        </li>

        <li>
          <a name="tex2html115" href=
          "postgresql.html#SECTION00320000000000000000" id=
          "tex2html115">2 Настройка сервера</a>

          <ul>
            <li><a name="tex2html116" href=
            "postgresql.html#SECTION00321000000000000000" id=
            "tex2html116">1 Используемая память</a></li>

            <li><a name="tex2html117" href=
            "postgresql.html#SECTION00322000000000000000" id=
            "tex2html117">2 Журнал транзакций и контрольные
            точки</a></li>

            <li><a name="tex2html118" href=
            "postgresql.html#SECTION00323000000000000000" id=
            "tex2html118">3 Планировщик запросов</a></li>

            <li><a name="tex2html119" href=
            "postgresql.html#SECTION00324000000000000000" id=
            "tex2html119">4 Сбор статистики</a></li>
          </ul>
        </li>

        <li>
          <a name="tex2html120" href=
          "postgresql.html#SECTION00330000000000000000" id=
          "tex2html120">3 Диски и файловые системы</a>

          <ul>
            <li><a name="tex2html121" href=
            "postgresql.html#SECTION00331000000000000000" id=
            "tex2html121">1 Перенос журнала транзакций на отдельный
            диск</a></li>
          </ul>
        </li>

        <li>
          <a name="tex2html122" href=
          "postgresql.html#SECTION00340000000000000000" id=
          "tex2html122">4 Примеры настроек</a>

          <ul>
            <li><a name="tex2html123" href=
            "postgresql.html#SECTION00341000000000000000" id=
            "tex2html123">1 Среднестатистическая настройка для
            максимальной производительности</a></li>

            <li><a name="tex2html124" href=
            "postgresql.html#SECTION00342000000000000000" id=
            "tex2html124">2 Среднестатистическая настройка для
            оконного приложения (1С), 2 ГБ памяти</a></li>

            <li><a name="tex2html125" href=
            "postgresql.html#SECTION00343000000000000000" id=
            "tex2html125">3 Среднестатистическая настройка для Web
            приложения, 2 ГБ памяти</a></li>

            <li><a name="tex2html126" href=
            "postgresql.html#SECTION00344000000000000000" id=
            "tex2html126">4 Среднестатистическая настройка для Web
            приложения, 8 ГБ памяти</a></li>
          </ul>
        </li>

        <li><a name="tex2html127" href=
        "postgresql.html#SECTION00350000000000000000" id=
        "tex2html127">5 Автоматическое создание оптимальных
        настроек: pgtune</a></li>

        <li>
          <a name="tex2html128" href=
          "postgresql.html#SECTION00360000000000000000" id=
          "tex2html128">6 Оптимизация БД и приложения</a>

          <ul>
            <li><a name="tex2html129" href=
            "postgresql.html#SECTION00361000000000000000" id=
            "tex2html129">1 Поддержание базы в порядке</a></li>

            <li><a name="tex2html130" href=
            "postgresql.html#SECTION00362000000000000000" id=
            "tex2html130">2 Использование индексов</a></li>

            <li><a name="tex2html131" href=
            "postgresql.html#SECTION00363000000000000000" id=
            "tex2html131">3 Перенос логики на сторону
            сервера</a></li>

            <li><a name="tex2html132" href=
            "postgresql.html#SECTION00364000000000000000" id=
            "tex2html132">4 Оптимизация конкретных
            запросов</a></li>

            <li><a name="tex2html133" href=
            "postgresql.html#SECTION00365000000000000000" id=
            "tex2html133">5 Оптимизация запросов с помощью
            pgFouine</a></li>
          </ul>
        </li>

        <li><a name="tex2html134" href=
        "postgresql.html#SECTION00370000000000000000" id=
        "tex2html134">7 Заключение</a></li>
      </ul><br />
    </li>

    <li>
      <a name="tex2html135" href=
      "postgresql.html#SECTION00400000000000000000" id=
      "tex2html135">3 Партиционирование</a>

      <ul>
        <li><a name="tex2html136" href=
        "postgresql.html#SECTION00410000000000000000" id=
        "tex2html136">1 Введение</a></li>

        <li><a name="tex2html137" href=
        "postgresql.html#SECTION00420000000000000000" id=
        "tex2html137">2 Теория</a></li>

        <li>
          <a name="tex2html138" href=
          "postgresql.html#SECTION00430000000000000000" id=
          "tex2html138">3 Практика использования</a>

          <ul>
            <li><a name="tex2html139" href=
            "postgresql.html#SECTION00431000000000000000" id=
            "tex2html139">1 Настройка</a></li>

            <li><a name="tex2html140" href=
            "postgresql.html#SECTION00432000000000000000" id=
            "tex2html140">2 Тестирование</a></li>

            <li><a name="tex2html141" href=
            "postgresql.html#SECTION00433000000000000000" id=
            "tex2html141">3 Управление партициями</a></li>

            <li><a name="tex2html142" href=
            "postgresql.html#SECTION00434000000000000000" id=
            "tex2html142">4 Важность
            &lt;&lt;constraint_exclusion&gt;&gt; для
            партиционирования</a></li>
          </ul>
        </li>

        <li><a name="tex2html143" href=
        "postgresql.html#SECTION00440000000000000000" id=
        "tex2html143">4 Заключение</a></li>
      </ul><br />
    </li>

    <li>
      <a name="tex2html144" href=
      "postgresql.html#SECTION00500000000000000000" id=
      "tex2html144">4 Репликация</a>

      <ul>
        <li><a name="tex2html145" href=
        "postgresql.html#SECTION00510000000000000000" id=
        "tex2html145">1 Введение</a></li>

        <li>
          <a name="tex2html146" href=
          "postgresql.html#SECTION00520000000000000000" id=
          "tex2html146">2 Bucardo</a>

          <ul>
            <li><a name="tex2html147" href=
            "postgresql.html#SECTION00521000000000000000" id=
            "tex2html147">1 Введение</a></li>

            <li><a name="tex2html148" href=
            "postgresql.html#SECTION00522000000000000000" id=
            "tex2html148">2 Установка</a></li>

            <li><a name="tex2html149" href=
            "postgresql.html#SECTION00523000000000000000" id=
            "tex2html149">3 Настройка</a></li>

            <li><a name="tex2html150" href=
            "postgresql.html#SECTION00524000000000000000" id=
            "tex2html150">4 Общие задачи</a></li>
          </ul>
        </li>

        <li><a name="tex2html151" href=
        "postgresql.html#SECTION00530000000000000000" id=
        "tex2html151">3 Заключение</a></li>
      </ul><br />
    </li>

    <li>
      <a name="tex2html152" href=
      "postgresql.html#SECTION00600000000000000000" id=
      "tex2html152">5 Шардинг</a>

      <ul>
        <li><a name="tex2html153" href=
        "postgresql.html#SECTION00610000000000000000" id=
        "tex2html153">1 Введение</a></li>

        <li><a name="tex2html154" href=
        "postgresql.html#SECTION00620000000000000000" id=
        "tex2html154">2 Заключение</a></li>
      </ul><br />
    </li>

    <li>
      <a name="tex2html155" href=
      "postgresql.html#SECTION00700000000000000000" id=
      "tex2html155">6 Мультиплексоры соединений</a>

      <ul>
        <li><a name="tex2html156" href=
        "postgresql.html#SECTION00710000000000000000" id=
        "tex2html156">1 Введение</a></li>

        <li><a name="tex2html157" href=
        "postgresql.html#SECTION00720000000000000000" id=
        "tex2html157">2 PgBouncer</a></li>

        <li><a name="tex2html158" href=
        "postgresql.html#SECTION00730000000000000000" id=
        "tex2html158">3 PgPool-II vs PgBouncer</a></li>
      </ul><br />
    </li>

    <li>
      <a name="tex2html159" href=
      "postgresql.html#SECTION00800000000000000000" id=
      "tex2html159">7 Бэкап и восстановление PostgreSQL</a>

      <ul>
        <li><a name="tex2html160" href=
        "postgresql.html#SECTION00810000000000000000" id=
        "tex2html160">1 Введение</a></li>

        <li>
          <a name="tex2html161" href=
          "postgresql.html#SECTION00820000000000000000" id=
          "tex2html161">2 SQL бэкап</a>

          <ul>
            <li><a name="tex2html162" href=
            "postgresql.html#SECTION00821000000000000000" id=
            "tex2html162">1 SQL бэкап больших баз данных</a></li>
          </ul>
        </li>

        <li><a name="tex2html163" href=
        "postgresql.html#SECTION00830000000000000000" id=
        "tex2html163">3 Бекап уровня файловой системы</a></li>

        <li>
          <a name="tex2html164" href=
          "postgresql.html#SECTION00840000000000000000" id=
          "tex2html164">4 Непрерывное резервное копирование</a>

          <ul>
            <li><a name="tex2html165" href=
            "postgresql.html#SECTION00841000000000000000" id=
            "tex2html165">1 Настройка</a></li>
          </ul>
        </li>

        <li><a name="tex2html166" href=
        "postgresql.html#SECTION00850000000000000000" id=
        "tex2html166">5 Заключение</a></li>
      </ul>
    </li>
  </ul><!--End of Table of Contents-->

  <h1><a name="SECTION00200000000000000000" id=
  "SECTION00200000000000000000"><span class="arabic">1</span>
  Введение</a></h1><br />
  <img width="427" height="71" align="bottom" border="0" src=
  "postgresql-img1.png" alt=
  "\begin{epigraphs} \qitem{Послушайте~--- и Вы забудете, по... ... сделайте~--- и Вы поймете.}{Конфуций} \end{epigraphs}" />
  <br />

  <p>Данная книга не дает ответы на все вопросы по работе с
  PostgreSQL. Главное её задание -- показать возможности
  PostgreSQL, методики настройки и масштабируемости этой СУБД. В
  любом случае, выбор метода решения поставленной задачи остается
  за разработчиком или администратором СУБД.</p>

  <h1><a name="SECTION00300000000000000000" id=
  "SECTION00300000000000000000"><span class="arabic">2</span>
  Настройка производительности</a></h1><br />
  <img width="427" height="71" align="bottom" border="0" src=
  "postgresql-img2.png" alt=
  "\begin{epigraphs} \qitem{Теперь я знаю тысячу способов,... ...�пу накаливания.}{Томас Алва Эдисон} \end{epigraphs}" />
  <br />

  <h1><a name="SECTION00310000000000000000" id=
  "SECTION00310000000000000000"><span class="arabic">1</span>
  Введение</a></h1>Скорость работы, вообще говоря, не является
  основной причиной использования реляционных СУБД. Более того,
  первые реляционные базы работали медленнее своих
  предшественников. Выбор этой технологии был вызван скорее

  <ul>
    <li>возможностью возложить поддержку целостности данных на
    СУБД;</li>

    <li>независимостью логической структуры данных от
    физической.</li>
  </ul>

  <p>Эти особенности позволяют сильно упростить написание
  приложений, но требуют для своей реализации дополнительных
  ресурсов.</p>

  <p>Таким образом, прежде, чем искать ответ на вопрос «как
  заставить РСУБД работать быстрее в моей задаче?» следует ответить
  на вопрос «нет ли более подходящего средства для решения моей
  задачи, чем РСУБД?» Иногда использование другого средства
  потребует меньше усилий, чем настройка производительности.</p>

  <p>Данная глава посвящена возможностям повышения
  производительности PostgreSQL. Глава не претендует на
  исчерпывающее изложение вопроса, наиболее полным и точным
  руководством по использованию PostgreSQL является, конечно,
  официальная документация и официальный FAQ. Также существует
  англоязычный список рассылки postgresql-performance, посвящённый
  именно этим вопросам. Глава состоит из двух разделов, первый из
  которых ориентирован скорее на администратора, второй -- на
  разработчика приложений. Рекомендуется прочесть оба раздела:
  отнесение многих вопросов к какому-то одному из них весьма
  условно.</p>

  <h2><a name="SECTION00311000000000000000" id=
  "SECTION00311000000000000000"><span class="arabic">1</span> Не
  используйте настройки по умолчанию</a></h2>По умолчанию
  PostgreSQL сконфигурирован таким образом, чтобы он мог быть
  запущен практически на любом компьютере и не слишком мешал при
  этом работе других приложений. Это особенно касается используемой
  памяти. Настройки по умолчанию подходят только для следующего
  использования: с ними вы сможете проверить, работает ли установка
  PostgreSQL, создать тестовую базу уровня записной книжки и
  потренироваться писать к ней запросы. Если вы собираетесь
  разрабатывать (а тем более запускать в работу) реальные
  приложения, то настройки придётся радикально изменить. В
  дистрибутиве PostgreSQL, к сожалению, не поставляется файлов с
  «рекомендуемыми» настройками. Вообще говоря, такие файлы создать
  весьма сложно, т.к. оптимальные настройки конкретной установки
  PostgreSQL будут определяться:

  <ul>
    <li>конфигурацией компьютера;</li>

    <li>объёмом и типом данных, хранящихся в базе;</li>

    <li>отношением числа запросов на чтение и на запись;</li>

    <li>тем, запущены ли другие требовательные к ресурсам процессы
    (например, вебсервер).</li>
  </ul>

  <h2><a name="SECTION00312000000000000000" id=
  "SECTION00312000000000000000"><span class="arabic">2</span>
  Используйте актуальную версию сервера</a></h2>Если у вас стоит
  устаревшая версия PostgreSQL, то наибольшего ускорения работы вы
  сможете добиться, обновив её до текущей. Укажем лишь наиболее
  значительные из связанных с производительностью изменений.

  <ul>
    <li>В версии 7.1 появился журнал транзакций, до того данные в
    таблицу сбрасывались каждый раз при успешном завершении
    транзакции.</li>

    <li>В версии 7.2 появились:

      <ul>
        <li>новая версия команды VACUUM, не требующая
        блокировки;</li>

        <li>команда ANALYZE, строящая гистограмму распределения
        данных в столбцах, что позволяет выбирать более быстрые
        планы выполнения запросов;</li>

        <li>подсистема сбора статистики.</li>
      </ul>
    </li>

    <li>В версии 7.4 была ускорена работа многих сложных запросов
    (включая печально известные подзапросы IN/NOT IN).</li>

    <li>В версии 8.0 было внедрено метки востановления, улучшение
    управления буфером, CHECKPOINT и VACUUM улучшены.</li>

    <li>В версии 8.1 было улучшено одновременный доступ к
    разделяемой памяти, автоматически использование индексов для
    MIN() и MAX(), pg_autovacuum внедрен в сервер
    (автоматизирован), повышение производительности для
    секционированных таблиц.</li>

    <li>В версии 8.2 было улучшено скорость множества SQL запросов,
    усовершенствован сам язык запросов.</li>

    <li>В версии 8.3 внедрен полнотекстовый поиск, поддержка
    SQL/XML стандарта, параметры конфигурации сервера могут быть
    установлены на основе отдельных функций.</li>

    <li>В версии 8.4 было внедрено общие табличные выражения,
    рекурсивные запросы, параллельное восстановление, улучшенна
    производительность для EXISTS/NOT EXISTS запросов.</li>

    <li>В версии 9.0 «репликация из коробки», VACUUM/VACUUM FULL
    стали быстрее, расширены хранимые процедуры.</li>
  </ul>Следует также отметить, что большая часть изложенного в
  статье материала относится к версии сервера не ниже 8.4.

  <h2><a name="SECTION00313000000000000000" id=
  "SECTION00313000000000000000"><span class="arabic">3</span> Стоит
  ли доверять тестам производительности</a></h2>Перед тем, как
  заниматься настройкой сервера, вполне естественно ознакомиться с
  опубликованными данными по производительности, в том числе в
  сравнении с другими СУБД. К сожалению, многие тесты служат не
  столько для облегчения вашего выбора, сколько для продвижения
  конкретных продуктов в качестве «самых быстрых». При изучении
  опубликованных тестов в первую очередь обратите внимание,
  соответствует ли величина и тип нагрузки, объём данных и
  сложность запросов в тесте тому, что вы собираетесь делать с
  базой? Пусть, например, обычное использование вашего приложения
  подразумевает несколько одновременно работающих запросов на
  обновление к таблице в миллионы записей. В этом случае СУБД,
  которая в несколько раз быстрее всех остальных ищет запись в
  таблице в тысячу записей, может оказаться не лучшим выбором. Ну и
  наконец, вещи, которые должны сразу насторожить:

  <ul>
    <li>Тестирование устаревшей версии СУБД.</li>

    <li>Использование настроек по умолчанию (или отсутствие
    информации о настройках).</li>

    <li>Тестирование в однопользовательском режиме (если, конечно,
    вы не предполагаете использовать СУБД именно так).</li>

    <li>Использование расширенных возможностей одной СУБД при
    игнорировании расширенных возможностей другой.</li>

    <li>Использование заведомо медленно работающих запросов (см.
    пункт 3.4).</li>
  </ul>

  <h1><a name="SECTION00320000000000000000" id=
  "SECTION00320000000000000000"><span class="arabic">2</span>
  Настройка сервера</a></h1>В этом разделе описаны рекомендуемые
  значения параметров, влияющих на производительность СУБД. Эти
  параметры обычно устанавливаются в конфигурационном файле
  postgresql.conf и влияют на все базы в текущей установке.

  <h2><a name="SECTION00321000000000000000" id=
  "SECTION00321000000000000000"><span class="arabic">1</span>
  Используемая память</a></h2>

  <h3><a name="SECTION00321100000000000000" id=
  "SECTION00321100000000000000"><span class="arabic">1</span> Общий
  буфер сервера: shared_buffers</a></h3>PostgreSQL не читает данные
  напрямую с диска и не пишет их сразу на диск. Данные загружаются
  в общий буфер сервера, находящийся в разделяемой памяти,
  серверные процессы читают и пишут блоки в этом буфере, а затем
  уже изменения сбрасываются на диск.

  <p>Если процессу нужен доступ к таблице, то он сначала ищет
  нужные блоки в общем буфере. Если блоки присутствуют, то он может
  продолжать работу, если нет -- делается системный вызов для их
  загрузки. Загружаться блоки могут как из файлового кэша ОС, так и
  с диска, и эта операция может оказаться весьма «дорогой».</p>

  <p>Если объём буфера недостаточен для хранения часто используемых
  рабочих данных, то они будут постоянно писаться и читаться из
  кэша ОС или с диска, что крайне отрицательно скажется на
  производительности.</p>

  <p>В то же время не следует устанавливать это значение слишком
  большим: это НЕ вся память, которая нужна для работы PostgreSQL,
  это только размер разделяемой между процессами PostgreSQL памяти,
  которая нужна для выполнения активных операций. Она должна
  занимать меньшую часть оперативной памяти вашего компьютера, так
  как PostgreSQL полагается на то, что операционная система
  кэширует файлы, и не старается дублировать эту работу. Кроме
  того, чем больше памяти будет отдано под буфер, тем меньше
  останется операционной системе и другим приложениям, что может
  привести к своппингу.</p>

  <p>К сожалению, чтобы знать точное число shared_buffers, нужно
  учесть количество оперативной памяти компьютера, размер базы
  данных, число соединений и сложность запросов, так что лучше
  воспользуемся несколькими простыми правилами настройки.</p>

  <p>На выделенных серверах полезным объемом будет значение от 8 МБ
  до 2 ГБ. Объем может быть выше, если у вас большие активные
  порции базы данных, сложные запросы, большое число одновременных
  соединений, длительные транзакции, вам доступен большой объем
  оперативной памяти или большее количество процессоров. И, конечно
  же, не забываем об остальных приложениях. Выделив слишком много
  памяти для базы данных, мы можем получить ухудшение
  производительности. В качестве начальных значений можете
  попробовать следующие:</p>

  <ul>
    <li>Начните с 4 МБ (512) для рабочей станции</li>

    <li>Средний объём данных и 256-512 МБ доступной памяти: 16-32
    МБ (2048-4096)</li>

    <li>Большой объём данных и 1-4 ГБ доступной памяти: 64-256 МБ
    (8192-32768)</li>
  </ul>

  <p>Для тонкой настройки параметра установите для него большое
  значение и потестируйте базу при обычной нагрузке. Проверяйте
  использование разделяемой памяти при помощи ipcs или других
  утилит(например, free или vmstat). Рекомендуемое значение
  параметра будет примерно в 1,2 -2 раза больше, чем максимум
  использованной памяти. Обратите внимание, что память под буфер
  выделятся при запуске сервера, и её объём при работе не
  изменяется. Учтите также, что настройки ядра операционной системы
  могут не дать вам выделить большой объём памяти. В руководстве
  администратора PostgreSQL описано, как можно изменить эти
  настройки:<br />
  http://developer.postgresql.org/docs/postgres/kernel-resources.html</p>

  <p>Вот несколько примеров, полученных на личном опыте и при
  тестировании:</p>

  <ul>
    <li>Laptop, Celeron processor, 384 МБ RAM, база данных 25 МБ:
    12 МБ</li>

    <li>Athlon server, 1 ГБ RAM, база данных поддержки принятия
    решений 10 ГБ: 200 МБ</li>

    <li>Quad PIII server, 4 ГБ RAM, 40 ГБ, 150 соединений,
    «тяжелые» транзакции: 1 ГБ</li>

    <li>Quad Xeon server, 8 ГБ RAM, 200 ГБ, 300 соединений,
    «тяжелые» транзакции: 2 ГБ</li>
  </ul>

  <h3><a name="SECTION00321200000000000000" id=
  "SECTION00321200000000000000"><span class="arabic">2</span>
  Память для сортировки результата запроса: work_mem</a></h3>Ранее
  известное как sort_mem, было переименовано, так как сейчас
  определяет максимальное количество оперативной памяти, которое
  может выделить одна операция сортировки, агрегации и др. Это не
  разделяемая память, work_mem выделяется отдельно на каждую
  операцию (от одного до нескольких раз за один запрос). Разумное
  значение параметра определяется следующим образом: количество
  доступной оперативной памяти (после того, как из общего объема
  вычли память, требуемую для других приложений, и shared_buffers)
  делится на максимальное число одновременных запросов умноженное
  на среднее число операций в запросе, которые требуют памяти.

  <p>Если объём памяти недостаточен для сортироки некоторого
  результата, то серверный процесс будет использовать временные
  файлы. Если же объём памяти слишком велик, то это может привести
  к своппингу.</p>

  <p>Объём памяти задаётся параметром work_mem в файле
  postgresql.conf. Единица измерения параметра -- 1 кБ. Значение по
  умолчанию -- 1024. В качестве начального значения для параметра
  можете взять 2-4% доступной памяти. Для веб-приложений обычно
  устанавливают низкие значения work_mem, так как запросов обычно
  много, но они простые, обычно хватает от 512 до 2048 КБ. С другой
  стороны, приложения для поддержки принятия решений с сотнями
  строк в каждом запросе и десятками миллионов столбцов в таблицах
  фактов часто требуют work_mem порядка 500 МБ. Для баз данных,
  которые используются и так, и так, этот параметр можно
  устанавливать для каждого запроса индивидуально, используя
  настройки сессии. Например, при памяти 1-4 ГБ рекомендуется
  устанавливать 32-128 MB.</p>

  <h3><a name="SECTION00321300000000000000" id=
  "SECTION00321300000000000000"><span class="arabic">3</span>
  Память для работы команды VACUUM:
  maintenance_work_mem</a></h3>Предыдущее название в PostgreSQL 7.x
  vacuum_mem. Этот параметр задаёт объём памяти, используемый
  командами VACUUM, ANALYZE, CREATE INDEX, и добавления внешних
  ключей. Чтобы операции выполнялись максимально быстро, нужно
  устанавливать этот параметр тем выше, чем больше размер таблиц в
  вашей базе данных. Неплохо бы устанавливать его значение от 50 до
  75% размера вашей самой большой таблицы или индекса или, если
  точно определить невозможно, от 32 до 256 МБ. Следует
  устанавливать большее значение, чем для work_mem. Слишком большие
  значения приведут к использованию свопа. Например, при памяти 1-4
  ГБ рекомендуется устанавливать 128-512 MB.

  <h3><a name="SECTION00321400000000000000" id=
  "SECTION00321400000000000000"><span class="arabic">4</span> Free
  Space Map: как избавиться от VACUUM FULL</a></h3>Особенностями
  версионных движков БД (к которым относится и используемый в
  PostgreSQL) является следующее:

  <ul>
    <li>Транзакции, изменяющие данные в таблице, не блокируют
    транзакции, читающие из неё данные, и наоборот (это
    хорошо);</li>

    <li>При изменении данных в таблице (командами UPDATE или
    DELETE) накапливается мусор<a name="tex2html1" href="#foot340"
    id="tex2html1"><sup><span class="arabic">1</span></sup></a> (а
    это плохо).</li>
  </ul>В каждой СУБД сборка мусора реализована особым образом, в
  PostgreSQL для этой цели применяется команда VACUUM (описана в
  пункте 3.1.1).

  <p>До версии 7.2 команда VACUUM полностью блокировала таблицу.
  Начиная с версии 7.2, команда VACUUM накладывает более слабую
  блокировку, позволяющую параллельно выполнять команды SELECT,
  INSERT, UPDATE и DELETE над обрабатываемой таблицей. Старый
  вариант команды называется теперь VACUUM FULL.</p>

  <p>Новый вариант команды не пытается удалить все старые версии
  записей и, соответственно, уменьшить размер файла, содержащего
  таблицу, а лишь помечает занимаемое ими место как свободное. Для
  информации о свободном месте есть следующие настройки:</p>

  <ul>
    <li>
      <span class="textbf">max_fsm_relations</span>

      <p>Максимальное количество таблиц, для которых будет
      отслеживаться свободное место в общей карте свободного
      пространства. Эти данные собираются VACUUM. Параметр
      max_fsm_relations должен быть не меньше общего количества
      таблиц во всех базах данной установки (лучше с запасом).</p>
    </li>

    <li>
      <span class="textbf">max_fsm_pages</span>

      <p>Данный параметр определяет размер реестра, в котором
      хранится информация о частично освобождённых страницах
      данных, готовых к заполнению новыми данными. Значение этого
      параметра нужно установить чуть больше, чем полное число
      страниц, которые могут быть затронуты операциями обновления
      или удаления между выполнением VACUUM. Чтобы определить это
      число, можно запустить VACUUM VERBOSE ANALYZE и выяснить
      общее число страниц, используемых базой данных. max_fsm_pages
      обычно требует немного памяти, так что на этом параметре
      лучше не экономить.</p>
    </li>
  </ul>

  <p>Если эти параметры установленны верно и информация обо всех
  изменениях помещается в FSM, то команды VACUUM будет достаточно
  для сборки мусора, если нет - понадобится VACUUM FULL, во время
  работы которой нормальное использование БД сильно затруднено.</p>

  <p><span class="textbf">ВНИМАНИЕ!</span> Начиная с 8.4 версии fsm
  параметры были убраны, поскольку Free Space Map сохраняется на
  жесткий диск, а не в память.</p>

  <h3><a name="SECTION00321500000000000000" id=
  "SECTION00321500000000000000"><span class="arabic">5</span>
  Прочие настройки</a></h3>

  <ul>
    <li>
      <span class="textbf">temp_buffers</span>

      <p>Буфер под временные объекты, в основном для временных
      таблиц. Можно установить порядка 16 МБ.</p>
    </li>

    <li>
      <span class="textbf">max_prepared_transactions</span>

      <p>Количество одновременно подготавливаемых транзакций
      (PREPARE TRANSACTION). Можно оставить по дефолту -- 5.</p>
    </li>

    <li>
      <span class="textbf">vacuum_cost_delay</span>

      <p>Если у вас большие таблицы, и производится много
      одновременных операций записи, вам может пригодиться функция,
      которая уменьшает затраты на I/O для VACUUM, растягиваяя его
      по времени. Чтобы включить эту функциональность, нужно
      поднять значение vacuum_cost_delay выше 0. Используйте
      разумную задержку от 50 до 200 мс. Для более тонкой настройки
      повышайте vacuum_cost_page_hit и понижайте
      vacuum_cost_page_limit. Это ослабит влияние VACUUM, увеличив
      время его выполнения. В тестах с параллельными транзакциями
      Ян Вик (Jan Wieck) получил, что при значениях delay -- 200,
      page_hit -- 6 и предел -- 100 вляние VACUUM уменьшилось более
      чем на 80%, но его длительность увеличилась втрое.</p>
    </li>

    <li>
      <span class="textbf">max_stack_depth</span>

      <p>Специальный стек для сервера, в идеале он должен совпадать
      с размером стека, выставленном в ядре ОС. Установка большего
      значения, чем в ядре, может привести к ошибкам. Рекомендуется
      устанавливать 2-4 MB.</p>
    </li>

    <li>
      <span class="textbf">max_files_per_process</span>

      <p>Максимальное количество файлов, открываемых процессом и
      его подпроцессами в один момент времени. Уменьшите данный
      параметр, если в процессе работы наблюдается сообщение «Too
      many open files».</p>
    </li>
  </ul>

  <h2><a name="SECTION00322000000000000000" id=
  "SECTION00322000000000000000"><span class="arabic">2</span>
  Журнал транзакций и контрольные точки</a></h2>Журнал транзакций
  PostgreSQL работает следующим образом: все изменения в файлах
  данных (в которых находятся таблицы и индексы) производятся
  только после того, как они были занесены в журнал транзакций, при
  этом записи в журнале должны быть гарантированно записаны на
  диск.

  <p>В этом случае нет необходимости сбрасывать на диск изменения
  данных при каждом успешном завершении транзакции: в случае сбоя
  БД может быть восстановлена по записям в журнале. Таким образом,
  данные из буферов сбрасываются на диск при проходе контрольной
  точки: либо при заполнении нескольких (параметр
  checkpoint_segments, по умолчанию 3) сегментов журнала
  транзакций, либо через определённый интервал времени (параметр
  checkpoint_timeout, измеряется в секундах, по умолчанию 300).</p>

  <p>Изменение этих параметров прямо не повлияет на скорость
  чтения, но может принести большую пользу, если данные в базе
  активно изменяются.</p>

  <h3><a name="SECTION00322100000000000000" id=
  "SECTION00322100000000000000"><span class="arabic">1</span>
  Уменьшение количества контрольных точек:
  checkpoint_segments</a></h3>Если в базу заносятся большие объёмы
  данных, то контрольные точки могут происходить слишком
  часто<a name="tex2html2" href="#foot357" id=
  "tex2html2"><sup><span class="arabic">2</span></sup></a>. При
  этом производительность упадёт из-за постоянного сбрасывания на
  диск данных из буфера.

  <p>Для увеличения интервала между контрольными точками нужно
  увеличить количество сегментов журнала транзакций
  (checkpoint_segments). Данный параметр определяет количество
  сегментов (каждый по 16 МБ) лога транзакций между контрольными
  точками. Этот параметр не имеет особого значения для базы данных,
  предназначенной преимущественно для чтения, но для баз данных со
  множеством транзакций увеличение этого параметра может оказаться
  жизненно необходимым. В зависимости от объема данных установите
  этот параметр в диапазоне от 12 до 256 сегментов и, если в логе
  появляются предупреждения (warning) о том, что контрольные точки
  происходят слишком часто, постепенно увеличивайте его. Место,
  требуемое на диске, вычисляется по формуле (checkpoint_segments *
  2 + 1) * 16 МБ, так что убедитесь, что у вас достаточно
  свободного места. Например, если вы выставите значение 32, вам
  потребуется больше 1 ГБ дискового пространства.</p>

  <p>Следует также отметить, что чем больше интервал между
  контрольными точками, тем дольше будут восстанавливаться данные
  по журналу транзакций после сбоя.</p>

  <h3><a name="SECTION00322200000000000000" id=
  "SECTION00322200000000000000"><span class="arabic">2</span> fsync
  и стоит ли его трогать</a></h3>Наиболее радикальное из возможных
  решений -- выставить значение «off» параметру fsync. При этом
  записи в журнале транзакций не будут принудительно сбрасываться
  на диск, что даст большой прирост скорости записи. Учтите: вы
  жертвуете надёжностью, в случае сбоя целостность базы будет
  нарушена, и её придётся восстанавливать из резервной копии!

  <p>Использовать этот параметр рекомендуется лишь в том случае,
  если вы всецело доверяете своему «железу» и своему источнику
  бесперебойного питания. Ну или если данные в базе не представляют
  для вас особой ценности.</p>

  <h3><a name="SECTION00322300000000000000" id=
  "SECTION00322300000000000000"><span class="arabic">3</span>
  Прочие настройки</a></h3>

  <ul>
    <li>
      <span class="textbf">commit_delay</span> (в микросекундах, 0
      по умолчанию) и <span class="textbf">commit_siblings</span>
      (5 по умолчанию)

      <p>определяют задержку между попаданием записи в буфер
      журнала транзакций и сбросом её на диск. Если при успешном
      завершении транзакции активно не менее commit_siblings
      транзакций, то запись будет задержана на время commit_delay.
      Если за это время завершится другая транзакция, то их
      изменения будут сброшены на диск вместе, при помощи одного
      системного вызова. Эти параметры позволят ускорить работу,
      если параллельно выполняется много «мелких» транзакций.</p>
    </li>

    <li>
      <span class="textbf">wal_sync_method</span>

      <p>Метод, который используется для принудительной записи
      данных на диск. Если fsync=off, то этот параметр не
      используется. Возможные значения:</p>

      <ul>
        <li>open_datasync -- запись данных методом open() с
        параметром O_DSYNC</li>

        <li>fdatasync -- вызов метода fdatasync() после каждого
        commit</li>

        <li>fsync_writethrough -- вызывать fsync() после каждого
        commit игнорирую паралельные процессы</li>

        <li>fsync -- вызов fsync() после каждого commit</li>

        <li>open_sync -- запись данных методом open() с параметром
        O_SYNC</li>
      </ul>

      <p>Не все эти методы доступны на разных ОС. По умолчанию
      устанавливается первый, который доступен для системы.</p>
    </li>

    <li>
      <span class="textbf">full_page_writes</span>

      <p>Установите данный параметр в off, если fsync=off. Иначе,
      когда этот параметр on, PostgreSQL записывает содержимое
      каждой записи в журнал транзакций при первой модификации
      таблицы. Это необходимо, поскольку данные могут записаться
      лишь частично, если в ходе процесса «упала» ОС. Это приведет
      к тому, что на диске окажутся новые данные смешанные со
      старыми. Строкового уровня записи в журнал транзакций может
      быть не достаточно, что бы полность восстановить данные после
      «падения». full_page_writes гарантирует корректное
      восстановление, ценой увелечения записываемых данных в журнал
      транзакций (Единственный способ снижения объема записи в
      журнал транзакций заключается в увеличении
      checkpoint_interval).</p>
    </li>

    <li>
      <span class="textbf">wal_buffers</span>

      <p>Количество памяти используемое в SHARED MEMORY для ведения
      транзакционных логов<a name="tex2html3" href="#foot368" id=
      "tex2html3"><sup><span class="arabic">3</span></sup></a>.
      Стоит увеличить буфер до 256-512 кБ, что позволит лучше
      работать с большими транзакциями. Например, при доступной
      памяти 1-4 ГБ рекомендуется устанавливать 256-1024 КБ.</p>
    </li>
  </ul>

  <h2><a name="SECTION00323000000000000000" id=
  "SECTION00323000000000000000"><span class="arabic">3</span>
  Планировщик запросов</a></h2>Следующие настройки помогают
  планировщику запросов правильно оценивать стоимости различных
  операций и выбирать оптимальный план выполнения запроса.
  Существуют 3 настройки планировщика, на которые стоит обратить
  внимание:

  <ul>
    <li>
      <span class="textbf">default_statistics_target</span>

      <p>Этот параметр задаёт объём статистики, собираемой командой
      ANALYZE (см. пункт 3.1.2). Увеличение параметра заставит эту
      команду работать дольше, но может позволить оптимизатору
      строить более быстрые планы, используя полученные
      дополнительные данные. Объём статистики для конкретного поля
      может быть задан командой ALTER TABLE ...SET STATISTICS.</p>
    </li>

    <li>
      <span class="textbf">effective_cache_size</span>

      <p>Этот параметр сообщает PostgreSQL примерный объём
      файлового кэша операционной системы, оптимизатор использует
      эту оценку для построения плана запроса<a name="tex2html4"
      href="#foot374" id="tex2html4"><sup><span class=
      "arabic">4</span></sup></a>.</p>

      <p>Пусть в вашем компьютере 1,5 ГБ памяти, параметр
      shared_buffers установлен в 32 МБ, а параметр
      effective_cache_size в 800 МБ. Если запросу нужно 700 МБ
      данных, то PostgreSQL оценит, что все нужные данные уже есть
      в памяти и выберет более агрессивный план с использованием
      индексов и merge joins. Но если effective_cache_size будет
      всего 200 МБ, то оптимизатор вполне может выбрать более
      эффективный для дисковой системы план, включающий полный
      просмотр таблицы.</p>

      <p>На выделенном сервере имеет смысл выставлять
      effective_cache_size в 2/3 от всей оперативной памяти; на
      сервере с другими приложениями сначала нужно вычесть из всего
      объема RAM размер дискового кэша ОС и память, занятую
      остальными процессами.</p>
    </li>

    <li>
      <span class="textbf">random_page_cost</span>

      <p>Переменная, указывающая на условную стоимость индексного
      доступа к страницам данных. На серверах с быстрыми дисковыми
      массивами имеет смысл уменьшать изначальную настройку до 3.0,
      2.5 или даже до 2.0. Если же активная часть вашей базы данных
      намного больше размеров оперативной памяти, попробуйте
      поднять значение параметра. Можно подойти к выбору
      оптимального значения и со стороны производительности
      запросов. Если планировщик запросов чаще, чем необходимо,
      предпочитает последовательные просмотры (sequential scans)
      просмотрам с использованием индекса (index scans), понижайте
      значение. И наоборот, если планировщик выбирает просмотр по
      медленному индексу, когда не должен этого делать, настройку
      имеет смысл увеличить. После изменения тщательно тестируйте
      результаты на максимально широком наборе запросов. Никогда не
      опускайте значение random_page_cost ниже 2.0; если вам
      кажется, что random_page_cost нужно еще понижать, разумнее в
      этом случае менять настройки статистики планировщика.</p>
    </li>
  </ul>

  <h2><a name="SECTION00324000000000000000" id=
  "SECTION00324000000000000000"><span class="arabic">4</span> Сбор
  статистики</a></h2>У PostgreSQL также есть специальная подсистема
  -- сборщик статистики, -- которая в реальном времени собирает
  данные об активности сервера. Поскольку сбор статистики создает
  дополнительные накладные расходы на базу данных, то система может
  быть настроена как на сбор, так и не сбор статистики вообще. Эта
  система контролируется следующими параметрами, принимающими
  значения true/false:

  <ul>
    <li><span class="textbf">track_counts</span> включать ли сбор
    статистики. По умолчанию включён, поскольку autovacuum демону
    требуется сбор статистики. Отключайте, только если статистика
    вас совершенно не интересует (как и autovacuum).</li>

    <li><span class="textbf">track_functions</span> отслеживание
    использования определенных пользователем функций.</li>

    <li><span class="textbf">track_activities</span> передавать ли
    сборщику статистики информацию о текущей выполняемой команде и
    времени начала её выполнения. По умолчанию эта возможность
    включена. Следует отметить, что эта информация будет доступна
    только привилегированным пользователям и пользователям, от лица
    которых запущены команды, так что проблем с безопасностью быть
    не должно.</li>
  </ul>

  <p>Данные, полученные сборщиком статистики, доступны через
  специальные системные представления. При установках по умолчанию
  собирается очень мало информации, рекомендуется включить все
  возможности: дополнительная нагрузка будет невелика, в то время
  как полученные данные позволят оптимизировать использование
  индексов (а также помогут оптимальной работе autovacuum
  демону).</p>

  <h1><a name="SECTION00330000000000000000" id=
  "SECTION00330000000000000000"><span class="arabic">3</span> Диски
  и файловые системы</a></h1>Очевидно, что от качественной дисковой
  подсистемы в сервере БД зависит немалая часть производительности.
  Вопросы выбора и тонкой настройки «железа», впрочем, не являются
  темой данной статьи, ограничимся уровнем файловой системы.

  <p>Единого мнения насчёт наиболее подходящей для PostgreSQL
  файловой системы нет, поэтому рекомендуется использовать ту,
  которая лучше всего поддерживается вашей операционной системой.
  При этом учтите, что современные журналирующие файловые системы
  не намного медленнее нежурналирующих, а выигрыш -- быстрое
  восстановление после сбоев -- от их использования велик.</p>

  <p>Вы легко можете получить выигрыш в производительности без
  побочных эффектов, если примонтируете файловую систему,
  содержащую базу данных, с параметром noatime<a name="tex2html5"
  href="#foot508" id="tex2html5"><sup><span class=
  "arabic">5</span></sup></a>.</p>

  <h2><a name="SECTION00331000000000000000" id=
  "SECTION00331000000000000000"><span class="arabic">1</span>
  Перенос журнала транзакций на отдельный диск</a></h2>При доступе
  к диску изрядное время занимает не только собственно чтение
  данных, но и перемещение магнитной головки.

  <p>Если в вашем сервере есть несколько физических дисков<a name=
  "tex2html6" href="#foot510" id="tex2html6"><sup><span class=
  "arabic">6</span></sup></a>, то вы можете разнести файлы базы
  данных и журнал транзакций по разным дискам. Данные в сегменты
  журнала пишутся последовательно, более того, записи в журнале
  транзакций сразу сбрасываются на диск, поэтому в случае
  нахождения его на отдельном диске магнитная головка не будет
  лишний раз двигаться, что позволит ускорить запись.</p>

  <p>Порядок действий:</p>

  <ul>
    <li>Остановите сервер (!).</li>

    <li>Перенесите каталоги pg_clog и pg_xlog, находящийся в
    каталоге с базами данных, на другой диск.</li>

    <li>Создайте на старом месте символическую ссылку.</li>

    <li>Запустите сервер.</li>
  </ul>

  <p>Примерно таким же образом можно перенести и часть файлов,
  содержащих таблицы и индексы, на другой диск, но здесь
  потребуется больше кропотливой ручной работы, а при внесении
  изменений в схему базы процедуру, возможно, придётся
  повторить.</p>

  <h1><a name="SECTION00340000000000000000" id=
  "SECTION00340000000000000000"><span class="arabic">4</span>
  Примеры настроек</a></h1>

  <h2><a name="SECTION00341000000000000000" id=
  "SECTION00341000000000000000"><span class="arabic">1</span>
  Среднестатистическая настройка для максимальной
  производительности</a></h2>

  <p>Возможно для конкретного случаю лучше подойдут другие
  настройки. Внимательно изучите данное руководство и настройте
  PostgreSQL операясь на эту информацию.</p>

  <p>RAM -- размер памяти;</p>

  <ul>
    <li>shared_buffers = 1/8 RAM или больше (но не более 1/4);</li>

    <li>work_mem в 1/20 RAM;</li>

    <li>maintenance_work_mem в 1/4 RAM;</li>

    <li>max_fsm_relations в планируемое кол-во таблиц в базах *
    1.5;</li>

    <li>max_fsm_pages в max_fsm_relations * 2000;</li>

    <li>fsync = true;</li>

    <li>wal_sync_method = fdatasync;</li>

    <li>commit_delay = от 10 до 100 ;</li>

    <li>commit_siblings = от 5 до 10;</li>

    <li>effective_cache_size = 0.9 от значения cached, которое
    показывает free;</li>

    <li>random_page_cost = 2 для быстрых cpu, 4 для медленных;</li>

    <li>cpu_tuple_cost = 0.001 для быстрых cpu, 0.01 для
    медленных;</li>

    <li>cpu_index_tuple_cost = 0.0005 для быстрых cpu, 0.005 для
    медленных;</li>

    <li>autovacuum = on;</li>

    <li>autovacuum_vacuum_threshold = 1800;</li>

    <li>autovacuum_analyze_threshold = 900;</li>
  </ul>

  <h2><a name="SECTION00342000000000000000" id=
  "SECTION00342000000000000000"><span class="arabic">2</span>
  Среднестатистическая настройка для оконного приложения (1С), 2 ГБ
  памяти</a></h2>

  <ul>
    <li>maintenance_work_mem = 128MB</li>

    <li>effective_cache_size = 512MB</li>

    <li>work_mem = 640kB</li>

    <li>wal_buffers = 1536kB</li>

    <li>shared_buffers = 128MB</li>

    <li>max_connections = 500</li>
  </ul>

  <h2><a name="SECTION00343000000000000000" id=
  "SECTION00343000000000000000"><span class="arabic">3</span>
  Среднестатистическая настройка для Web приложения, 2 ГБ
  памяти</a></h2>

  <ul>
    <li>maintenance_work_mem = 128MB;</li>

    <li>checkpoint_completion_target = 0.7</li>

    <li>effective_cache_size = 1536MB</li>

    <li>work_mem = 4MB</li>

    <li>wal_buffers = 4MB</li>

    <li>checkpoint_segments = 8</li>

    <li>shared_buffers = 512MB</li>

    <li>max_connections = 500</li>
  </ul>

  <h2><a name="SECTION00344000000000000000" id=
  "SECTION00344000000000000000"><span class="arabic">4</span>
  Среднестатистическая настройка для Web приложения, 8 ГБ
  памяти</a></h2>

  <ul>
    <li>maintenance_work_mem = 512MB</li>

    <li>checkpoint_completion_target = 0.7</li>

    <li>effective_cache_size = 6GB</li>

    <li>work_mem = 16MB</li>

    <li>wal_buffers = 4MB</li>

    <li>checkpoint_segments = 8</li>

    <li>shared_buffers = 2GB</li>

    <li>max_connections = 500</li>
  </ul>

  <h1><a name="SECTION00350000000000000000" id=
  "SECTION00350000000000000000"><span class="arabic">5</span>
  Автоматическое создание оптимальных настроек: pgtune</a></h1>

  <p>Для оптимизации настроек для PostgreSQL Gregory Smith создал
  утилиту pgtune<a name="tex2html7" href="#foot543" id=
  "tex2html7"><sup><span class="arabic">7</span></sup></a> в
  расчете на обеспечение максимальной производительности для
  заданной аппаратной конфигурации. Утилита проста в использовании
  и в многих Linux системах может идти в составе пакетов. Если же
  нет, можно просто скачать архив и распаковать. Для начала:<br />
  <img width="590" height="95" align="bottom" border="0" src=
  "postgresql-img3.png" alt=
  "\begin{lstlisting}[label=lst:p_settings1,caption=Pgtune] pgtune -i $PGDATA/postgresql.conf -o $PGDATA/postgresql.conf.pgtune \end{lstlisting}" />
  <br />
  опцией [frame=tblr]-i, -input-config указываем текущий файл
  postgresql.conf, а [frame=tblr]-o, -output-config указываем имя
  файла для нового postgresql.conf.</p>

  <p>Есть также дополнительные опции для настройки конфига.</p>

  <ul>
    <li>[frame=single]-M, -memory Используйте этот параметр, чтобы
    определить общий объем системной памяти. Если не указано,
    pgtune будет пытаться использовать текущий объем системной
    памяти.</li>

    <li>[frame=single]-T, -type Указывает тип базы данных. Опции:
    DW, OLTP, Web, Mixed, Desktop.</li>

    <li>[frame=single]-c, -connections Указывает максимальное
    количество соединений. Если он не указан, это будет братся
    взависимости от типа базы данных.</li>
  </ul>

  <p>Хочется сразу добавить, что pgtune не панацея для оптимизации
  настройки PostgreSQL. Многие настройки зависят не только от
  аппаратной конфигурации, но и от размера базы данных, числа
  соединений и сложность запросов, так что оптимально настроить
  базу данных возможно учитывая все эти параметры.</p>

  <h1><a name="SECTION00360000000000000000" id=
  "SECTION00360000000000000000"><span class="arabic">6</span>
  Оптимизация БД и приложения</a></h1>Для быстрой работы каждого
  запроса в вашей базе в основном требуется следующее:

  <ol>
    <li>Отсутствие в базе мусора, мешающего добраться до актуальных
    данных. Можно сформулировать две подзадачи:

      <ol>
        <li>Грамотное проектирование базы. Освещение этого вопроса
        выходит далеко за рамки этой статьи.</li>

        <li>Сборка мусора, возникающего при работе СУБД.</li>
      </ol>
    </li>

    <li>Наличие быстрых путей доступа к данным -- индексов.</li>

    <li>Возможность использования оптимизатором этих быстрых
    путей.</li>

    <li>Обход известных проблем.</li>
  </ol>

  <h2><a name="SECTION00361000000000000000" id=
  "SECTION00361000000000000000"><span class="arabic">1</span>
  Поддержание базы в порядке</a></h2>В данном разделе описаны
  действия, которые должны периодически выполняться для каждой
  базы. От разработчика требуется только настроить их
  автоматическое выполнение (при помощи cron) и опытным путём
  подобрать его оптимальную частоту.

  <h3><a name="SECTION00361100000000000000" id=
  "SECTION00361100000000000000"><span class="arabic">1</span>
  Команда ANALYZE</a></h3>Служит для обновления информации о
  распределении данных в таблице. Эта информация используется
  оптимизатором для выбора наиболее быстрого плана выполнения
  запроса.

  <p>Обычно команда используется в связке VACUUM ANALYZE. Если в
  базе есть таблицы, данные в которых не изменяются и не удаляются,
  а лишь добавляются, то для таких таблиц можно использовать
  отдельную команду ANALYZE. Также стоит использовать эту команду
  для отдельной таблицы после добавления в неё большого количества
  записей.</p>

  <h3><a name="SECTION00361200000000000000" id=
  "SECTION00361200000000000000"><span class="arabic">2</span>
  Команда REINDEX</a></h3>Команда REINDEX используется для
  перестройки существующих индексов. Использовать её имеет смысл в
  случае:

  <ul>
    <li>порчи индекса;</li>

    <li>постоянного увеличения его размера.</li>
  </ul>

  <p>Второй случай требует пояснений. Индекс, как и таблица,
  содержит блоки со старыми версиями записей. PostgreSQL не всегда
  может заново использовать эти блоки, и поэтому файл с индексом
  постепенно увеличивается в размерах. Если данные в таблице часто
  меняются, то расти он может весьма быстро.</p>

  <p>Если вы заметили подобное поведение какого-то индекса, то
  стоит настроить для него периодическое выполнение команды
  REINDEX. Учтите: команда REINDEX, как и VACUUM FULL, полностью
  блокирует таблицу, поэтому выполнять её надо тогда, когда
  загрузка сервера минимальна.</p>

  <h2><a name="SECTION00362000000000000000" id=
  "SECTION00362000000000000000"><span class="arabic">2</span>
  Использование индексов</a></h2>Опыт показывает, что наиболее
  значительные проблемы с производительностью вызываются
  отсутствием нужных индексов. Поэтому столкнувшись с медленным
  запросом, в первую очередь проверьте, существуют ли индексы,
  которые он может использовать. Если нет -- постройте их. Излишек
  индексов, впрочем, тоже чреват проблемами:

  <ul>
    <li>Команды, изменяющие данные в таблице, должны изменить также
    и индексы. Очевидно, чем больше индексов построено для таблицы,
    тем медленнее это будет происходить.</li>

    <li>Оптимизатор перебирает возможные пути выполнения запросов.
    Если построено много ненужных индексов, то этот перебор будет
    идти дольше.</li>
  </ul>Единственное, что можно сказать с большой степенью
  определённости -- поля, являющиеся внешими ключами, и поля, по
  которым объединяются таблицы, индексировать надо обязательно.

  <h3><a name="SECTION00362100000000000000" id=
  "SECTION00362100000000000000"><span class="arabic">1</span>
  Команда EXPLAIN [ANALYZE]</a></h3>Команда EXPLAIN [запрос]
  показывает, каким образом PostgreSQL собирается выполнять ваш
  запрос. Команда EXPLAIN ANALYZE [запрос] выполняет запрос<a name=
  "tex2html8" href="#foot603" id="tex2html8"><sup><span class=
  "arabic">8</span></sup></a> и показывает как изначальный план,
  так и реальный процесс его выполнения.

  <p>Чтение вывода этих команд -- искусство, которое приходит с
  опытом. Для начала обращайте внимание на следующее:</p>

  <ul>
    <li>Использование полного просмотра таблицы (seq scan).</li>

    <li>Использование наиболее примитивного способа объединения
    таблиц (nested loop).</li>

    <li>Для EXPLAIN ANALYZE: нет ли больших отличий в
    предполагаемом количестве записей и реально выбранном? Если
    оптимизатор использует устаревшую статистику, то он может
    выбирать не самый быстрый план выполнения запроса.</li>
  </ul>

  <p>Следует отметить, что полный просмотр таблицы далеко не всегда
  медленнее просмотра по индексу. Если, например, в
  таблице-справочнике несколько сотен записей, умещающихся в
  одном-двух блоках на диске, то использование индекса приведёт
  лишь к тому, что придётся читать ещё и пару лишних блоков
  индекса. Если в запросе придётся выбрать 80% записей из большой
  таблицы, то полный просмотр опять же получится быстрее.</p>

  <p>При тестировании запросов с использованием EXPLAIN ANALYZE
  можно воспользоваться настройками, запрещающими оптимизатору
  использовать определённые планы выполнения. Например,</p>
  <pre>
SET enable_seqscan=false;
</pre>

  <p>запретит использование полного просмотра таблицы, и вы сможете
  выяснить, прав ли был оптимизатор, отказываясь от использования
  индекса. Ни в коем случае не следует прописывать подобные команды
  в postgresql.conf! Это может ускорить выполнение нескольких
  запросов, но сильно замедлит все остальные!</p>

  <h3><a name="SECTION00362200000000000000" id=
  "SECTION00362200000000000000"><span class="arabic">2</span>
  Использование собранной статистики</a></h3>Результаты работы
  сборщика статистики доступны через специальные системные
  представления. Наиболее интересны для наших целей следующие:

  <ul>
    <li><span class="textbf">pg_stat_user_tables</span> содержит --
    для каждой пользовательской таблицы в текущей базе данных --
    общее количество полных просмотров и просмотров с
    использованием индексов, общие количества записей, которые были
    возвращены в результате обоих типов просмотра, а также общие
    количества вставленных, изменённых и удалённых записей.</li>

    <li><span class="textbf">pg_stat_user_indexes</span> содержит
    -- для каждого пользовательского индекса в текущей базе данных
    -- общее количество просмотров, использовавших этот индекс,
    количество прочитанных записей, количество успешно прочитанных
    записей в таблице (может быть меньше предыдущего значения, если
    в индексе есть записи, указывающие на устаревшие записи в
    таблице).</li>

    <li><span class="textbf">pg_statio_user_tables</span> содержит
    -- для каждой пользовательской таблицы в текущей базе данных --
    общее количество блоков, прочитанных из таблицы, количество
    блоков, оказавшихся при этом в буфере (см. пункт 2.1.1), а
    также аналогичную статистику для всех индексов по таблице и,
    возможно, по связанной с ней таблицей TOAST.</li>
  </ul>

  <p>Из этих представлений можно узнать, в частности</p>

  <ul>
    <li>Для каких таблиц стоит создать новые индексы (индикатором
    служит большое количество полных просмотров и большое
    количество прочитанных блоков).</li>

    <li>Какие индексы вообще не используются в запросах. Их имеет
    смысл удалить, если, конечно, речь не идёт об индексах,
    обеспечивающих выполнение ограничений PRIMARY KEY и
    UNIQUE.</li>

    <li>Достаточен ли объём буфера сервера.</li>
  </ul>

  <p>Также возможен «дедуктивный» подход, при котором сначала
  создаётся большое количество индексов, а затем неиспользуемые
  индексы удаляются.</p>

  <h3><a name="SECTION00362300000000000000" id=
  "SECTION00362300000000000000"><span class="arabic">3</span>
  Возможности индексов в PostgreSQL</a></h3><span class=
  "textbf">Функциональные индексы</span> Вы можете построить индекс
  не только по полю/нескольким полям таблицы, но и по выражению,
  зависящему от полей. Пусть, например, в вашей таблице foo есть
  поле foo_name, и выборки часто делаются по условию «первая буква
  foo_name = 'буква', в любом регистре». Вы можете создать индекс
  <pre>
CREATE INDEX foo_name_first_idx 
ON foo ((lower(substr(foo_name, 1, 1))));
</pre>и запрос вида
  <pre>
SELECT * FROM foo 
WHERE lower(substr(foo_name, 1, 1)) = 'ы';
</pre>будет его использовать.

  <p><span class="textbf">Частичные индексы (partial
  indexes)</span> Под частичным индексом понимается индекс с
  предикатом WHERE. Пусть, например, у вас есть в базе таблица
  scheta с параметром uplocheno типа boolean. Записей, где
  uplocheno = false меньше, чем записей с uplocheno = true, а
  запросы по ним выполняются значительно чаще. Вы можете создать
  индекс</p>
  <pre>
CREATE INDEX scheta_neuplocheno ON scheta (id)
WHERE NOT uplocheno;
</pre>который будет использоваться запросом вида
  <pre>
SELECT * FROM scheta WHERE NOT uplocheno AND ...;
</pre>Достоинство подхода в том, что записи, не удовлетворяющие
условию WHERE, просто не попадут в индекс.

  <h2><a name="SECTION00363000000000000000" id=
  "SECTION00363000000000000000"><span class="arabic">3</span>
  Перенос логики на сторону сервера</a></h2>Этот пункт очевиден для
  опытных пользователей PostrgeSQL и предназначен для тех, кто
  использует или переносит на PostgreSQL приложения, написанные
  изначально для более примитивных СУБД.

  <p>Реализация части логики на стороне сервера через хранимые
  процедуры, триггеры, правила<a name="tex2html9" href="#foot628"
  id="tex2html9"><sup><span class="arabic">9</span></sup></a> часто
  позволяет ускорить работу приложения. Действительно, если
  несколько запросов объединены в процедуру, то не требуется</p>

  <ul>
    <li>пересылка промежуточных запросов на сервер;</li>

    <li>получение промежуточных результатов на клиент и их
    обработка.</li>
  </ul>

  <p>Кроме того, хранимые процедуры упрощают процесс разработки и
  поддержки: изменения надо вносить только на стороне сервера, а не
  менять запросы во всех приложениях.</p>

  <h2><a name="SECTION00364000000000000000" id=
  "SECTION00364000000000000000"><span class="arabic">4</span>
  Оптимизация конкретных запросов</a></h2>В этом разделе
  описываются запросы, для которых по разным причинам нельзя
  заставить оптимизатор использовать индексы, и которые будут
  всегда вызывать полный просмотр таблицы. Таким образом, если вам
  требуется использовать эти запросы в требовательном к
  быстродействию приложении, то придётся их изменить.

  <h3><a name="SECTION00364100000000000000" id=
  "SECTION00364100000000000000"><span class="arabic">1</span>
  SELECT count(*) FROM &lt;огромная таблица&gt;</a></h3>Функция
  count() работает очень просто: сначала выбираются все записи,
  удовлетворяющие условию, а потом к полученному набору записей
  применяется агрегатная функция -- считается количество выбраных
  строк. Информация о видимости записи для текущей транзакции (а
  конкурентным транзакциям может быть видимо разное количество
  записей в таблице!) не хранится в индексе, поэтому, даже если
  использовать для выполнения запроса индекс первичного ключа
  таблицы, всё равно потребуется чтение записей собственно из файла
  таблицы.

  <p><span class="textbf">Проблема</span> Запрос вида<br />
  <img width="589" height="72" align="bottom" border="0" src=
  "postgresql-img4.png" alt=
  "\begin{lstlisting}[language=SQL,label=lst:sql_performance1,caption=SQL] SELECT count(*) FROM foo; \end{lstlisting}" />
  <br />
  осуществляет полный просмотр таблицы foo, что весьма долго для
  таблиц с большим количеством записей.</p>

  <p><span class="textbf">Решение</span> Простого решения проблемы,
  к сожалению, нет. Возможны следу- ющие подходы:</p>

  <ol>
    <li>Если точное число записей не важно, а важен порядок<a name=
    "tex2html10" href="#foot638" id="tex2html10"><sup><span class=
    "arabic">10</span></sup></a>, то можно использовать информацию
    о количестве записей в таблице, собранную при выполнении
    команды ANALYZE:<br />
    <img width="589" height="95" align="bottom" border="0" src=
    "postgresql-img5.png" alt=
    "\begin{lstlisting}[language=SQL,label=lst:sql_performance2,caption=SQL] SELECT reltuples FROM pg_class WHERE relname = 'foo'; \end{lstlisting}" />
    <br /></li>

    <li>Если подобные выборки выполняются часто, а изменения в
    таблице достаточно редки, то можно завести вспомогательную
    таблицу, хранящую число записей в основной. На основную же
    таблицу повесить триггер, который будет уменьшать это число в
    случае удаления записи и увеличивать в случае вставки. Таким
    образом, для получения количества записей потребуется лишь
    выбрать одну запись из вспомогательной таблицы.</li>

    <li>Вариант предыдущего подхода, но данные во вспомогательной
    таблице обновляются через определённые промежутки времени
    (cron).</li>
  </ol>

  <h3><a name="SECTION00364200000000000000" id=
  "SECTION00364200000000000000"><span class="arabic">2</span>
  Медленый DISTINCT</a></h3>Текущая реализация DISTINCT для больших
  таблиц очень медленна. Но возможно использовать GROUP BY взамен
  DISTINCT. GROUP BY может использовать агрегирующий хэш, что
  значительно быстрее, чем DISTINCT.

  <p><br />
  <img width="598" height="441" align="bottom" border="0" src=
  "postgresql-img6.png" alt=
  "\begin{lstlisting}[language=SQL,label=lst:sql_performance3,caption=DISTINCT] pos... ... from g) a; count ------- 19125 (1 row) \par Time: 36,281 ms \end{lstlisting}" />
  <br /></p>

  <p><br />
  <img width="598" height="464" align="bottom" border="0" src=
  "postgresql-img7.png" alt=
  "\begin{lstlisting}[language=SQL,label=lst:sql_performance4,caption=GROUP BY] pos... ... i) a; count ------- 19125 (1 row) \par Time: 25,270 ms \par \end{lstlisting}" />
  <br /></p>

  <h2><a name="SECTION00365000000000000000" id=
  "SECTION00365000000000000000"><span class="arabic">5</span>
  Оптимизация запросов с помощью pgFouine</a></h2>pgFouine<a name=
  "tex2html11" href="#foot648" id="tex2html11"><sup><span class=
  "arabic">11</span></sup></a> -- это анализатор log-файлов для
  PostgreSQL, используемый для генерации детальных отчетов из
  log-файлов PostgreSQL. pgFouine поможет определить, какие запросы
  следует оптимизировать в первую очередь. pgFouine написан на
  языке программирования PHP с использованием
  объектно-ориентированных технологий и легко расширяется для
  поддержки специализированных отчетов, является свободным
  программным обеспечением и распространяется на условиях GNU
  General Public License. Утилита спроектирована таким образом,
  чтобы обработка очень больших log-файлов не требовала много
  ресурсов.

  <p>Для работы с pgFouine сначала нужно сконфигурировать
  PostgreSQL для создания нужного формата log-файлов:</p>

  <ul>
    <li>Чтобы включить протоколирование в syslog<br />
    <img width="590" height="118" align="bottom" border="0" src=
    "postgresql-img8.png" alt=
    "\begin{lstlisting}[label=lst:sql_performance5,caption=pgFouine] log_destination = 'syslog' redirect_stderr = off silent_mode = on \end{lstlisting}" />
    <br /></li>

    <li>Для записи запросов, длящихся дольше n миллисекунд:<br />
    <img width="590" height="118" align="bottom" border="0" src=
    "postgresql-img9.png" alt=
    "\begin{lstlisting}[label=lst:sql_performance6,caption=pgFouine] log_min_duration_statement = n log_duration = off log_statement = 'none' \end{lstlisting}" />
    <br /></li>
  </ul>

  <p>Для записи каждого обработанного запроса установите
  log_min_duration_statement на 0. Чтобы отключить запись запросов,
  установите этот параметр на -1.</p>

  <p>pgFouine -- простой в использовании инструмент командной
  строки. Следующая команда создаёт HTML-отчёт со стандартными
  параметрами:<br />
  <img width="589" height="95" align="bottom" border="0" src=
  "postgresql-img10.png" alt=
  "\begin{lstlisting}[label=lst:sql_performance7,caption=pgFouine] pgfouine.php -file your/log/file.log &gt; your-report.html \end{lstlisting}" />
  <br /></p>

  <p>С помощью этой строки можно отобразить текстовый отчёт с 10
  запросами на каждый экран на стандартном выводе:<br />
  <img width="589" height="95" align="bottom" border="0" src=
  "postgresql-img11.png" alt=
  "\begin{lstlisting}[label=lst:sql_performance8,caption=pgFouine] pgfouine.php -file your/log/file.log -top 10 -format text \end{lstlisting}" />
  <br /></p>

  <p>Более подробно о возможностях, а также много полезных
  примеров, можно найти на официальном сайта проекта --
  http://pgfouine.projects.postgresql.org.</p>

  <h1><a name="SECTION00370000000000000000" id=
  "SECTION00370000000000000000"><span class="arabic">7</span>
  Заключение</a></h1>К счастью, PostgreSQL не требует особо сложной
  настройки. В большинстве случаев вполне достаточно будет
  увеличить объём выделенной памяти, настроить периодическое
  поддержание базы в порядке и проверить наличие необходимых
  индексов. Более сложные вопросы можно обсудить в
  специализированном списке рассылки.

  <h1><a name="SECTION00400000000000000000" id=
  "SECTION00400000000000000000"><span class="arabic">3</span>
  Партиционирование</a></h1><br />
  <img width="428" height="93" align="bottom" border="0" src=
  "postgresql-img12.png" alt=
  "\begin{epigraphs} \qitem{Решая какую-либо проблему, все... ...самой проблемы.}{Народная мудрость} \end{epigraphs}" />
  <br />

  <h1><a name="SECTION00410000000000000000" id=
  "SECTION00410000000000000000"><span class="arabic">1</span>
  Введение</a></h1>Партиционирование (partitioning,
  секционирование) -- это разбиение больших структур баз данных
  (таблицы, индексы) разбить на меньшие кусочки. Звучит сложно, но
  на практике все просто.

  <p>Скорее всего у Вас есть несколько огромных таблиц (обычно всю
  нагрузку обеспечивают всего несколько таблиц СУБД из всех
  имеющихся). Причем чтение в большинстве случаев приходится только
  на самую последнюю их часть (т.е. активно читаются те данные,
  которые недавно появились). Примером тому может служить блог --
  на первую страницу (это последние 5...10 постов) приходится
  40...50% всей нагрузки, или новостной портал (суть одна и та же),
  или системы личных сообщений… впрочем понятно. Партиционирование
  таблицы позволяет базе данных делать интеллектуальную выборку --
  сначала СУБД уточнит, какой партиции соответствует Ваш запрос
  (если это реально) и только потом сделает этот запрос,
  применительно к нужной партиции (или нескольким партициям). Таким
  образом, в рассмотренном случае, Вы распределите нагрузку на
  таблицу по ее партициям. Следовательно выборка типа «SELECT *
  FROM articles ORDER BY id DESC LIMIT 10» будет выполняться только
  над последней партицией, которая значительно меньше всей
  таблицы.</p>

  <p>Итак, партиционирование дает ряд преимуществ:</p>

  <ul>
    <li>На определенные виды запросов (которые, в свою очередь,
    создают основную нагрузку на СУБД) мы можем улучшить
    производительность.</li>

    <li>Массовое удаление может быть произведено путем удаления
    одной или нескольких партиций (DROP TABLE гораздо быстрее, чем
    массовый DELETE).</li>

    <li>Редко используемые данные могут быть перенесены в другое
    хранилище.</li>
  </ul>

  <h1><a name="SECTION00420000000000000000" id=
  "SECTION00420000000000000000"><span class="arabic">2</span>
  Теория</a></h1>На текущий момент PostgreSQL поддерживает два
  критерия для создания партиций:

  <ul>
    <li>Партиционирование по диапазону значений (range) -- таблица
    разбивается на «диапазоны» значений по полю или набору полей в
    таблице, без перекрытия диапазонов значений, отнесенных к
    различным партициям. Например, диапазоны дат.</li>

    <li>Партиционирование по списку значений (list) -- таблица
    разбивается по спискам ключевые значения для каждой
    партиции.</li>
  </ul>

  <p>Чтобы настроить партиционирование таблици, достаточно
  выполните следующие действия:</p>

  <ul>
    <li>Создается «мастер» таблица, из которой все партиции будут
    наследоваться. Эта таблица не будет содержать данные. Так же не
    нужно ставить никаких ограничений на таблицу, если конечно они
    не будут дублироватся на партиции.</li>

    <li>Создайте несколько «дочерних» таблиц, которые наследуют от
    «мастер» таблицы.</li>

    <li>Добавить в «дочерние» таблицы значения, по которым они
    будут партициями. Стоить заметить, что значения партиций не
    должны пересекатся. Например:<br />
    <img width="590" height="95" align="bottom" border="0" src=
    "postgresql-img13.png" alt=
    "\begin{lstlisting}[language=SQL,label=lst:partitioning1,caption=Пример н�... ...ID BETWEEN 100 AND 200 ) CHECK ( outletID BETWEEN 200 AND 300 ) \end{lstlisting}" />
    <br />
    неверно заданы партиции, поскольку не понятно какой партиции
    пренадлежит значение 200.</li>

    <li>Для каждой партиции создать индекс по ключевому полю (или
    нескольким), а также указать любые другие требуемые
    индексы.</li>

    <li>При необходимости, создать триггер или правило для
    перенаправления данных с «мастер» таблици в соответствующую
    партицию.</li>

    <li>Убедиться, что параметр «constraint_exclusion» не отключен
    в postgresql.conf. Если его не включить, то запросы не будут
    оптимизированы при работе с партиционирование.</li>
  </ul>

  <h1><a name="SECTION00430000000000000000" id=
  "SECTION00430000000000000000"><span class="arabic">3</span>
  Практика использования</a></h1>Теперь начнем с практического
  примера. Представим, что в нашей системе есть таблица, в которую
  мы собираем данные о посещаемости нашего ресурса. На любой запрос
  пользователя наша система логирует действия в эту таблицу. И,
  например, в начале каждого месяца (неделю) нам нужно создавать
  отчет за предыдущий месяц (неделю). При этом, логи нужно хранить
  в течении 3 лет. Данные в такой таблице накапливаются быстро,
  если система активно используется. И вот, когда таблица уже с
  милионами, а то, и милиардами записей, создавать отчеты
  становится все сложнее (да и чистка старых записей становится не
  легким делом). Работа с такой таблицей создает огромную нагрузку
  на СУБД. Тут нам на помощь и приходит партиционирование.

  <h2><a name="SECTION00431000000000000000" id=
  "SECTION00431000000000000000"><span class="arabic">1</span>
  Настройка</a></h2>Для примера, мы имеем следующию таблицу:<br />
  <img width="590" height="210" align="bottom" border="0" src=
  "postgresql-img14.png" alt=
  "\begin{lstlisting}[language=SQL,label=lst:partitioning2,caption=&lt;&lt;Мастер&gt;&gt;... ...LL, logdate TIMESTAMP NOT NULL, data TEXT, some_state INT ); \end{lstlisting}" />
  <br />

  <p>Поскольку нам нужны отчеты каждый месяц, мы будем делить
  партиции по месяцам. Это поможет нам быстрее создавать отчеты и
  чистить старые данные.</p>

  <p>«Мастер» таблица будет «my_logs», структуру которой мы указали
  выше. Далее создадим «дочерние» таблици (партиции):<br />
  <img width="598" height="418" align="bottom" border="0" src=
  "postgresql-img15.png" alt=
  "\begin{lstlisting}[language=SQL,label=lst:partitioning3,caption=&lt;&lt;Дочерни... ...-01-01' AND logdate &lt; DATE '2010-02-01' ) ) INHERITS (my_logs); \end{lstlisting}" />
  <br /></p>

  <p>Данными командами мы создаем таблицы «my_logs2010m10»,
  «my_logs2010m11» и т.д., которые копируют структуру с «мастер»
  таблици (кроме индексов). Также с помощью «CHECK» мы задаем
  диапазон значений, который будет попадать в эту партицию (хочу
  опять напомнить, что диапазоны значений партиций не должны
  пересекатся!). Поскольку партиционирование будет работать по полю
  «logdate», мы создадим индекс на это поле на всех
  партициях:<br />
  <img width="590" height="233" align="bottom" border="0" src=
  "postgresql-img16.png" alt=
  "\begin{lstlisting}[language=SQL,label=lst:partitioning4,caption=Создание... ...REATE INDEX my_logs2011m01_logdate ON my_logs2011m01 (logdate); \end{lstlisting}" />
  <br /></p>

  <p>Далее для удобства создадим функцию, которая будет
  перенаправлять новые данные с «мастер» таблици в соответствующую
  партицию.<br />
  <img width="599" height="764" align="bottom" border="0" src=
  "postgresql-img17.png" alt=
  "\begin{lstlisting}[language=SQL,label=lst:partitioning5,caption=Функция �... ... END IF; RETURN NULL; END; \end{displaymath}LANGUAGE plpgsql; \end{lstlisting}" />
  <br /></p>

  <p>В функции ничего особенного нет: идет проверка поля «logdate»,
  по которой направляются данные в нужную партицию. При не
  нахождении требуемой партиции -- вызываем ошибку. Теперь осталось
  создать триггер на «мастер» таблицу для автоматического вызова
  данной функции:<br />
  <img width="590" height="141" align="bottom" border="0" src=
  "postgresql-img18.png" alt=
  "\begin{lstlisting}[language=SQL,label=lst:partitioning6,caption=Триггер] ... ..._logs FOR EACH ROW EXECUTE PROCEDURE my_logs_insert_trigger(); \end{lstlisting}" />
  <br /></p>

  <p>Партиционирование настроено и теперь мы готовы приступить к
  тестированию.</p>

  <h2><a name="SECTION00432000000000000000" id=
  "SECTION00432000000000000000"><span class="arabic">2</span>
  Тестирование</a></h2>Для начала добавим данные в нашу таблицу
  «my_logs»:<br />
  <img width="590" height="256" align="bottom" border="0" src=
  "postgresql-img19.png" alt=
  "\begin{lstlisting}[language=SQL,label=lst:partitioning7,caption=Данные] IN... ...ta, some_state) VALUES(1, '2010-12-15', '15.12.2010 data3', 1); \end{lstlisting}" />
  <br />

  <p>Теперь проверим где они хранятся:<br />
  <img width="590" height="141" align="bottom" border="0" src=
  "postgresql-img20.png" alt=
  "\begin{lstlisting}[language=SQL,label=lst:partitioning8,caption=&lt;&lt;Мастер&gt;&gt;... ...me_state ----+---------+---------+------+------------ (0 rows) \end{lstlisting}" />
  <br />
  Как видим в «мастер» таблицу данные не попали -- она чиста.
  Теперь проверим а есть ли вообще данные:<br />
  <img width="788" height="303" align="bottom" border="0" src=
  "postgresql-img21.png" alt=
  "\begin{lstlisting}[language=SQL,label=lst:partitioning9,caption=Проверка... ...ert 2010-12-15 00:00:00 \vert 15.12.2010 data3 \vert 1 (3 rows) \end{lstlisting}" />
  <br /></p>

  <p>Данные при этом выводятся без проблем. Проверим партиции,
  правильно ли хранятся данные:<br />
  <img width="796" height="395" align="bottom" border="0" src=
  "postgresql-img22.png" alt=
  "\begin{lstlisting}[language=SQL,label=lst:partitioning10,caption=Проверк�... ...vert 2010-11-10 00:00:00 \vert 10.11.2010 data2 \vert 1 (1 row) \end{lstlisting}" />
  <br /></p>

  <p>Отлично! Данные хранятся на требуемых нам партициях. При этом
  запросы к таблице «my_logs» менять не нужно:<br />
  <img width="796" height="487" align="bottom" border="0" src=
  "postgresql-img23.png" alt=
  "\begin{lstlisting}[language=SQL,label=lst:partitioning11,caption=Проверк�... ...ert 2010-11-10 00:00:00 \vert 10.11.2010 data2 \vert 1 (2 rows) \end{lstlisting}" />
  <br /></p>

  <h2><a name="SECTION00433000000000000000" id=
  "SECTION00433000000000000000"><span class="arabic">3</span>
  Управление партициями</a></h2>Обычно при работе с
  партиционированием старые партиции перестают получать данные и
  остаются неизменными. Это дает огоромное приемущество над работай
  с данными через партиции. Например, нам нужно удалить старые логи
  за 2008 год, 10 месяц. Нам достаточно выполить:<br />
  <img width="589" height="72" align="bottom" border="0" src=
  "postgresql-img24.png" alt=
  "\begin{lstlisting}[language=SQL,label=lst:partitioning12,caption=Чистка логов] DROP TABLE my_logs2008m10; \end{lstlisting}" />
  <br />
  поскольку «DROP TABLE» работает гораздо быстрее, чем удаление
  милионов записей индивидуально через «DELETE». Другой вариант,
  который более предпочтителен, просто удалить партицию из
  партиционирования, тем самым оставив данные в СУБД, но уже не
  доступные через «мастер» таблицу:<br />
  <img width="589" height="72" align="bottom" border="0" src=
  "postgresql-img25.png" alt=
  "\begin{lstlisting}[language=SQL,label=lst:partitioning13,caption=Удаляем ... ...рования] ALTER TABLE my_logs2008m10 NO INHERIT my_logs; \end{lstlisting}" />
  <br />
  Это удобно, если мы хотим эти данные потом перенести в другое
  хранилище или просто сохранить.

  <h2><a name="SECTION00434000000000000000" id=
  "SECTION00434000000000000000"><span class="arabic">4</span>
  Важность «constraint_exclusion» для
  партиционирования</a></h2>Параметр «constraint_exclusion»
  отвечает за оптимизацию запросов, что повышает производительность
  для партиционированых таблиц. Например, выпоним простой
  запрос:<br />
  <img width="1144" height="1572" align="bottom" border="0" src=
  "postgresql-img26.png" alt=
  "\begin{lstlisting}[language=SQL,label=lst:partitioning14,caption=&lt;&lt;constraint\_e... ...&gt; '2010-12-01 00:00:00'::timestamp without time zone) (22 rows) \end{lstlisting}" />
  <br />

  <p>Как видно через команду «EXPLAIN», данный запрос сканирует все
  партиции на наличие данных в них, что не логично, поскольку
  данное условие «logdate &gt; 2010-12-01» говорит о том, что
  данные должны братся только с партицый, где подходит такое
  условие. А теперь включим «constraint_exclusion»:<br />
  <img width="1143" height="833" align="bottom" border="0" src=
  "postgresql-img27.png" alt=
  "\begin{lstlisting}[language=SQL,label=lst:partitioning15,caption=&lt;&lt;constraint\_e... ...&gt; '2010-12-01 00:00:00'::timestamp without time zone) (10 rows) \end{lstlisting}" />
  <br /></p>

  <p>Как мы видим, теперь запрос работает правильно, и сканирует
  только партиции, что подходят под условие запроса. Но включать
  «constraint_exclusion» не желательно для баз, где нет
  партиционирования, поскольку команда «CHECK» будет проверятся на
  всех запросах, даже простых, а значит производительность сильно
  упадет. Начиная с 8.4 версии PostgreSQL «constraint_exclusion»
  может быть «on», «off» и «partition». По умолчанию (и
  рекомендуется) ставить «constraint_exclusion» не «on», и не
  «off», а «partition», который будет проверять «CHECK» только на
  партиционированых таблицах.</p>

  <h1><a name="SECTION00440000000000000000" id=
  "SECTION00440000000000000000"><span class="arabic">4</span>
  Заключение</a></h1>Партиционирование -- одна из самых простых и
  менее безболезненных методов уменьшения нагрузки на СУБД. Именно
  на этот вариант стоит посмотреть сперва, и если он не подходит по
  каким либо причинам -- переходить к более сложным. Но если в
  системе есть таблица, у которой актуальны только новые данные, но
  огромное количество старых (не актуальных) данных дает 50% или
  более нагрузки на СУБД -- Вам стоит внедрить партиционированию.

  <h1><a name="SECTION00500000000000000000" id=
  "SECTION00500000000000000000"><span class="arabic">4</span>
  Репликация</a></h1><br />
  <img width="428" height="93" align="bottom" border="0" src=
  "postgresql-img28.png" alt=
  "\begin{epigraphs} \qitem{Когда решаете проблему, ни о ч�... ...спокоиться.}{Ричард Филлипс Фейман} \end{epigraphs}" />
  <br />

  <h1><a name="SECTION00510000000000000000" id=
  "SECTION00510000000000000000"><span class="arabic">1</span>
  Введение</a></h1>Репликация (англ. replication) -- механизм
  синхронизации содержимого нескольких копий объекта (например,
  содержимого базы данных). Репликация -- это процесс, под которым
  понимается копирование данных из одного источника на множество
  других и наоборот. При репликации изменения, сделанные в одной
  копии объекта, могут быть распространены в другие копии.
  Репликация может быть синхронной или асинхронной.

  <p>В случае синхронной репликации, если данная реплика
  обновляется, все другие реплики того же фрагмента данных также
  должны быть обновлены в одной и той же транзакции. Логически это
  означает, что существует лишь одна версия данных. В большинстве
  продуктов синхронная репликация реализуется с помощью триггерных
  процедур (возможно, скрытых и управляемых системой). Но
  синхронная репликация имеет тот недостаток, что она создаёт
  дополнительную нагрузку при выполнении всех транзакций, в которых
  обновляются какие-либо реплики (кроме того, могут возникать
  проблемы, связанные с доступностью данных).</p>

  <p>В случае асинхронной репликации обновление одной реплики
  распространяется на другие спустя некоторое время, а не в той же
  транзакции. Таким образом, при асинхронной репликации вводится
  задержка, или время ожидания, в течение которого отдельные
  реплики могут быть фактически неидентичными (то есть определение
  реплика оказывается не совсем подходящим, поскольку мы не имеем
  дело с точными и своевременно созданными копиями). В большинстве
  продуктов асинхронная репликация реализуется посредством чтения
  журнала транзакций или постоянной очереди тех обновлений, которые
  подлежат распространению. Преимущество асинхронной репликации
  состоит в том, что дополнительные издержки репликации не связаны
  с транзакциями обновлений, которые могут иметь важное значение
  для функционирования всего предприятия и предъявлять высокие
  требования к производительности. К недостаткам этой схемы
  относится то, что данные могут оказаться несовместимыми (то есть
  несовместимыми с точки зрения пользователя). Иными словами,
  избыточность может проявляться на логическом уровне, а это,
  строго говоря, означает, что термин контролируемая избыточность в
  таком случае не применим.</p>

  <p>Рассмотрим кратко проблему согласованности (или, скорее,
  несогласованности). Дело в том, что реплики могут становиться
  несовместимыми в результате ситуаций, которые трудно (или даже
  невозможно) избежать и последствия которых трудно исправить. В
  частности, конфликты могут возникать по поводу того, в каком
  порядке должны применяться обновления. Например, предположим, что
  в результате выполнения транзакции А происходит вставка строки в
  реплику X, после чего транзакция B удаляет эту строку, а также
  допустим, что Y -- реплика X. Если обновления распространяются на
  Y, но вводятся в реплику Y в обратном порядке (например, из-за
  разных задержек при передаче), то транзакция B не находит в Y
  строку, подлежащую удалению, и не выполняет своё действие, после
  чего транзакция А вставляет эту строку. Суммарный эффект состоит
  в том, что реплика Y содержит указанную строку, а реплика X --
  нет.</p>

  <p>В целом задачи устранения конфликтных ситуаций и обеспечения
  согласованности реплик являются весьма сложными. Следует
  отметить, что, по крайней мере, в сообществе пользователей
  коммерческих баз данных термин репликация стал означать
  преимущественно (или даже исключительно) асинхронную
  репликацию.</p>

  <p>Основное различие между репликацией и управлением копированием
  заключается в следующем: Если используется репликация, то
  обновление одной реплики в конечном счёте распространяется на все
  остальные автоматически. В режиме управления копированием,
  напротив, не существует такого автоматического распространения
  обновлений. Копии данных создаются и управляются с помощью
  пакетного или фонового процесса, который отделён во времени от
  транзакций обновления. Управление копированием в общем более
  эффективно по сравнению с репликацией, поскольку за один раз
  могут копироваться большие объёмы данных. К недостаткам можно
  отнести то, что большую часть времени копии данных не идентичны
  базовым данным, поэтому пользователи должны учитывать, когда
  именно были синхронизированы эти данные. Обычно управление
  копированием упрощается благодаря тому требованию, чтобы
  обновления применялись в соответствии со схемой первичной копии
  того или иного вида.</p>

  <p>Для репликации PostgreSQL существует несколько решений, как
  закрытых, так и свободных. Закрытые системы репликации не будут
  рассматриваться в этой книге (ну, сами понимаете). Вот список
  свободных решений:</p>

  <ul>
    <li><span class="textbf">Slony-I</span><a name="tex2html12"
    href="#foot857" id="tex2html12"><sup><span class=
    "arabic">12</span></sup></a> -- асинхронная Master-Slave
    репликация, поддерживает каскады(cascading) и
    отказоустойчивость(failover). Slony-I использует триггеры
    PostgreSQL для привязки к событиям INSERT/ DELETE/UPDATE и
    хранимые процедуры для выполнения действий.</li>

    <li><span class="textbf">PGCluster</span><a name="tex2html13"
    href="#foot859" id="tex2html13"><sup><span class=
    "arabic">13</span></sup></a> -- синхронная Multi-Master
    репликация. Проект на мой взгляд мертв, поскольку уже год не
    обновлялся.</li>

    <li>
      <span class="textbf">pgpool-I/II</span><a name="tex2html14"
      href="#foot861" id="tex2html14"><sup><span class=
      "arabic">14</span></sup></a> -- это замечательный инструмент
      для PostgreSQL (лучше сразу работать с II версией). Позволяет
      делать:

      <ul>
        <li>репликацию (в том числе, с автоматическим переключением
        на резервный stand-by сервер);</li>

        <li>online-бэкап;</li>

        <li>pooling коннектов;</li>

        <li>очередь соединений;</li>

        <li>балансировку SELECT-запросов на несколько
        postgresql-серверов;</li>

        <li>разбиение запросов для параллельного выполнения над
        большими объемами данных.</li>
      </ul>
    </li>

    <li><span class="textbf">Bucardo</span><a name="tex2html15"
    href="#foot865" id="tex2html15"><sup><span class=
    "arabic">15</span></sup></a> -- асинхронная репликация, которая
    поддерживает Multi-Master и Master-Slave режимы, а также
    несколько видов синхронизации и обработки конфликтов.</li>

    <li><span class="textbf">Londiste</span><a name="tex2html16"
    href="#foot867" id="tex2html16"><sup><span class=
    "arabic">16</span></sup></a> -- асинхронная Master-Slave
    репликация. Входит в состав Skytools<a name="tex2html17" href=
    "#foot868" id="tex2html17"><sup><span class=
    "arabic">17</span></sup></a>. Проще в использовании, чем
    Slony-I.</li>

    <li><span class="textbf">Mammoth Replicator</span><a name=
    "tex2html18" href="#foot870" id="tex2html18"><sup><span class=
    "arabic">18</span></sup></a> -- асинхронная Multi-Master
    репликация.</li>

    <li><span class="textbf">Postgres-R</span><a name="tex2html19"
    href="#foot872" id="tex2html19"><sup><span class=
    "arabic">19</span></sup></a> -- асинхронная Multi-Master
    репликация.</li>

    <li><span class="textbf">RubyRep</span><a name="tex2html20"
    href="#foot874" id="tex2html20"><sup><span class=
    "arabic">20</span></sup></a> -- написанная на Ruby, асинхронная
    Multi-Master репликация, которая поддерживает PostgreSQL и
    MySQL.</li>
  </ul>

  <p>Это, конечно, не весь список свободных систем для репликации,
  но я думаю даже из этого есть что выбрать для PostgreSQL.</p>

  <h1><a name="SECTION00520000000000000000" id=
  "SECTION00520000000000000000"><span class="arabic">2</span>
  Bucardo</a></h1>

  <h2><a name="SECTION00521000000000000000" id=
  "SECTION00521000000000000000"><span class="arabic">1</span>
  Введение</a></h2>Bucardo -- асинхронная master-master или
  master-slave репликация PostgreSQL, которая написана на Perl.
  Система очень гибкая, поддерживает несколько видов синхронизации
  и обработки конфликтов.

  <h2><a name="SECTION00522000000000000000" id=
  "SECTION00522000000000000000"><span class="arabic">2</span>
  Установка</a></h2>Установку будем проводить на Ubuntu Server.
  Сначала нам нужно установить DBIx::Safe Perl модуль.<br />
  <img width="589" height="72" align="bottom" border="0" src=
  "postgresql-img29.png" alt=
  "\begin{lstlisting}[label=lst:bucardo1,caption=Установка] sudo aptitude install libdbix-safe-perl \end{lstlisting}" />
  <br />

  <p>Для других систем можно поставить из исходников<a name=
  "tex2html21" href="#foot1159" id="tex2html21"><sup><span class=
  "arabic">21</span></sup></a>:<br />
  <img width="590" height="141" align="bottom" border="0" src=
  "postgresql-img30.png" alt=
  "\begin{lstlisting}[label=lst:bucardo2,caption=Установка] tar xvfz DBIx-... ...e-1.2.5 perl Makefile.PL make &amp;&amp; make test &amp;&amp; sudo make install \end{lstlisting}" />
  <br /></p>

  <p>Теперь ставим сам Bucardo. Скачиваем<a name="tex2html22" href=
  "#foot1162" id="tex2html22"><sup><span class=
  "arabic">22</span></sup></a> его и инсталируем:<br />
  <img width="590" height="164" align="bottom" border="0" src=
  "postgresql-img31.png" alt=
  "\begin{lstlisting}[label=lst:bucardo3,caption=Установка] tar xvfz Bucar... ...tar.gz cd Bucardo-4.4.0 perl Makefile.PL make sudo make install \end{lstlisting}" />
  <br /></p>

  <p>Для работы Bucardo потребуется установить поддержку pl/perlu
  языка PostgreSQL.<br />
  <img width="589" height="72" align="bottom" border="0" src=
  "postgresql-img32.png" alt=
  "\begin{lstlisting}[label=lst:bucardo4,caption=Установка] sudo aptitude install postgresql-plperl-8.4 \end{lstlisting}" />
  <br /></p>

  <p>Можем приступать к настройке.</p>

  <h2><a name="SECTION00523000000000000000" id=
  "SECTION00523000000000000000"><span class="arabic">3</span>
  Настройка</a></h2>

  <h3><a name="SECTION00523100000000000000" id=
  "SECTION00523100000000000000"><span class="arabic">1</span>
  Инициализация Bucardo</a></h3>Запускаем установку командой:<br />
  <img width="589" height="72" align="bottom" border="0" src=
  "postgresql-img33.png" alt=
  "\begin{lstlisting}[label=lst:bucardo5,caption=Инициализация Bucardo] bucardo_ctl install \end{lstlisting}" />
  <br />

  <p>Bucardo покажет настройки подключения к PostgreSQL, которые
  можно будет изменить:<br />
  <img width="598" height="418" align="bottom" border="0" src=
  "postgresql-img34.png" alt=
  "\begin{lstlisting}[label=lst:bucardo6,caption=Инициализация Bucardo... ...stgres 4. Database: postgres 5. PID directory: /var/run/bucardo \end{lstlisting}" />
  <br /></p>

  <p>Когда вы измените требуемые настройки и подтвердите установку,
  Bucardo создаст пользователя bucardo и базу данных bucardo.
  Данный пользователь должен иметь право логинится через Unix
  socket, поэтому лучше заранее дать ему такие права в
  pg_hda.conf.</p>

  <h3><a name="SECTION00523200000000000000" id=
  "SECTION00523200000000000000"><span class="arabic">2</span>
  Настройка баз данных</a></h3>Теперь нам нужно настроить базы
  данных, с которыми будет работать Bucardo. Пусть у нас будет
  master_db и slave_db. Сначала настроим мастер:<br />
  <img width="590" height="118" align="bottom" border="0" src=
  "postgresql-img35.png" alt=
  "\begin{lstlisting}[label=lst:bucardo7,caption=Настройка баз данн... ...s herd=all_tables bucardo_ctl add all sequences herd=all_tables \end{lstlisting}" />
  <br />

  <p>Первой командой мы указали базу данных и дали ей имя master
  (для того, что в реальной жизни master_db и slave_db имеют
  одинаковое название и их нужно Bucardo отличать). Второй и третей
  командой мы указали реплицыровать все таблицы и
  последовательности, обьеденив их в групу all_tables.</p>

  <p>Дальше добавляем slave_db:<br />
  <img width="589" height="95" align="bottom" border="0" src=
  "postgresql-img36.png" alt=
  "\begin{lstlisting}[label=lst:bucardo8,caption=Настройка баз данн... ...ardo_ctl add db slave_db name=replica port=6543 host=slave_host \end{lstlisting}" />
  <br /></p>

  <p>Мы назвали replica базу данных в Bucardo.</p>

  <h3><a name="SECTION00523300000000000000" id=
  "SECTION00523300000000000000"><span class="arabic">3</span>
  Настройка синхронизации</a></h3>Теперь нам нужно настроить
  синхронизацию между этими базами данных. Делается это командой
  (master-slave):<br />
  <img width="589" height="95" align="bottom" border="0" src=
  "postgresql-img37.png" alt=
  "\begin{lstlisting}[label=lst:bucardo9,caption=Настройка синхрон�... ...dd sync delta type=pushdelta source=all_tables targetdb=replica \end{lstlisting}" />
  <br />

  <p>Данной командой мы установим Bucardo тригеры в PostgreSQL. А
  теперь по параметрам:</p>

  <ul>
    <li>
      <span class="textbf">type</span>

      <p>Это тип синхронизации. Существует 3 типа:</p>

      <ul>
        <li><span class="textbf">Fullcopy</span>. Полное
        копирование.</li>

        <li><span class="textbf">Pushdelta</span>. Master-slave
        репликация.</li>

        <li>
          <span class="textbf">Swap</span>. Master-master
          репликация. Для работы в таком режиме потребуется указать
          как Bucardo должен решать конфликты синхронизации. Для
          этого в таблице «goat» (в которой находятся таблицы и
          последовательности) нужно в «standard_conflict» поле
          поставить значение (это значение может быть разным для
          разных таблиц и последовательностей):

          <ul>
            <li>source -- при конфликте мы копируем данные с source
            (master_db в нашем случае).</li>

            <li>target -- при конфликте мы копируем данные с target
            (slave_db в нашем случае).</li>

            <li>skip -- конфликт мы просто не реплицируем. Не
            рекомендуется.</li>

            <li>random -- каждая БД имеет одинаковый шанс, что её
            изменение будет взято для решение конфликта.</li>

            <li>latest -- запись, которая была последней изменена
            решает конфликт.</li>

            <li>abort -- синхронизация прерывается.</li>
          </ul>
        </li>
      </ul>
    </li>

    <li>
      <span class="textbf">source</span>

      <p>Источник синхронизации.</p>
    </li>

    <li>
      <span class="textbf">targetdb</span>

      <p>БД, в которум производим репликацию.</p>
    </li>
  </ul>

  <p>Для master-master:<br />
  <img width="589" height="95" align="bottom" border="0" src=
  "postgresql-img38.png" alt=
  "\begin{lstlisting}[label=lst:bucardo10,caption=Настройка синхрон... ...ctl add sync delta type=swap source=all_tables targetdb=replica \end{lstlisting}" />
  <br /></p>

  <h3><a name="SECTION00523400000000000000" id=
  "SECTION00523400000000000000"><span class="arabic">4</span>
  Запуск/Остановка репликации</a></h3>Запуск репликации:<br />
  <img width="589" height="72" align="bottom" border="0" src=
  "postgresql-img39.png" alt=
  "\begin{lstlisting}[label=lst:bucardo11,caption=Запуск репликации] bucardo_ctl start \end{lstlisting}" />
  <br />

  <p>Остановка репликации:<br />
  <img width="589" height="72" align="bottom" border="0" src=
  "postgresql-img40.png" alt=
  "\begin{lstlisting}[label=lst:bucardo12,caption=Остановка репликации] bucardo_ctl stop \end{lstlisting}" />
  <br /></p>

  <h2><a name="SECTION00524000000000000000" id=
  "SECTION00524000000000000000"><span class="arabic">4</span> Общие
  задачи</a></h2>

  <h3><a name="SECTION00524100000000000000" id=
  "SECTION00524100000000000000"><span class="arabic">1</span>
  Просмотр значений конфигурации</a></h3>Просто используя эту
  команду:<br />
  <img width="589" height="72" align="bottom" border="0" src=
  "postgresql-img41.png" alt=
  "\begin{lstlisting}[label=lst:bucardo13,caption=Просмотр значений конфигурации] bucardo_ctl show all \end{lstlisting}" />
  <br />

  <h3><a name="SECTION00524200000000000000" id=
  "SECTION00524200000000000000"><span class="arabic">2</span>
  Изменения значений конфигурации</a></h3><br />
  <img width="589" height="72" align="bottom" border="0" src=
  "postgresql-img42.png" alt=
  "\begin{lstlisting}[label=lst:bucardo14,caption=Изменения значений конфигурациии] bucardo_ctl set name=value \end{lstlisting}" />
  <br />

  <p>Например:<br />
  <img width="589" height="72" align="bottom" border="0" src=
  "postgresql-img43.png" alt=
  "\begin{lstlisting}[label=lst:bucardo15,caption=Изменения значени... ...�фигурации] bucardo_ctl set syslog_facility=LOG_LOCAL3 \end{lstlisting}" />
  <br /></p>

  <h3><a name="SECTION00524300000000000000" id=
  "SECTION00524300000000000000"><span class="arabic">3</span>
  Перегрузка конфигурации</a></h3><br />
  <img width="589" height="72" align="bottom" border="0" src=
  "postgresql-img44.png" alt=
  "\begin{lstlisting}[label=lst:bucardo16,caption=Перегрузка конфигурации] bucardo_ctl reload_config \end{lstlisting}" />
  <br />

  <p>Более полный список команд --
  http://bucardo.org/wiki/Bucardo_ctl</p>

  <h1><a name="SECTION00530000000000000000" id=
  "SECTION00530000000000000000"><span class="arabic">3</span>
  Заключение</a></h1>Репликация -- одна из важнейших частей крупных
  приложений, которые работают на PostgreSQL. Она помогает
  распределять нагрузку на базу данных, делать фоновый бэкап одной
  из копий без нагрузки на центральный сервер, создавать отдельный
  сервер для логирования и м.д.

  <p>В главе было рассмотрено несколько видов репликации
  PostgreSQL. Нельзя четко сказать какая лучше всех. Потоковая
  репликация -- одна из самых лучших вариантов для поддержки
  идентичных кластеров баз данных, но доступна только с 9.0 версии
  PostgreSQL. Slony-I -- громоздкая и сложная в настройке система,
  но имеющая в своем арсенале множество функций, таких как
  поддержка каскадной репликации, отказоустойчивости (failover) и
  переключение между серверами (switchover). В тоже время Londiste
  не обладает подобным функционалом, но компактный и прост в
  установке. Bucardo -- система которая может быть или
  master-master, или master-slave репликацией, но не может
  обработать огромные обьекты, нет отказоустойчивости(failover) и
  переключение между серверами (switchover). RubyRep, как для
  master-master репликации, очень просто в установке и настройке,
  но за это ему приходится расплачиватся скоростью работы -- самый
  медленный из всех (синхронизация больших обьемов данных между
  таблицами).</p>

  <h1><a name="SECTION00600000000000000000" id=
  "SECTION00600000000000000000"><span class="arabic">5</span>
  Шардинг</a></h1><br />
  <img width="427" height="71" align="bottom" border="0" src=
  "postgresql-img45.png" alt=
  "\begin{epigraphs} \qitem{Если ешь слона, не пытайся зап�... ...о в рот целиком.}{Народная мудрость} \end{epigraphs}" />
  <br />

  <h1><a name="SECTION00610000000000000000" id=
  "SECTION00610000000000000000"><span class="arabic">1</span>
  Введение</a></h1>Шардинг -- разделение данных на уровне ресурсов.
  Концепция шардинга заключается в логическом разделении данных по
  различным ресурсам исходя из требований к нагрузке.

  <p>Рассмотрим пример. Пусть у нас есть приложение с регистрацией
  пользователей, которое позволяет писать друг другу личные
  сообщения. Допустим оно очень популярно и много людей им
  пользуются ежедневно. Естественно, что таблица с личными
  сообщениями будет намного больше всех остальных таблиц в базе
  (скажем, будет занимать 90% всех ресурсов). Зная это, мы можем
  подготовить для этой (только одной!) таблицы выделенный сервер
  помощнее, а остальные оставить на другом (послабее). Теперь мы
  можем идеально подстроить сервер для работы с одной специфической
  таблицей, постараться уместить ее в память, возможно,
  дополнительно партиционировать ее и т.д. Такое распределение
  называется вертикальным шардингом.</p>

  <p>Что делать, если наша таблица с сообщениями стала настолько
  большой, что даже выделенный сервер под нее одну уже не спасает.
  Необходимо делать горизонтальный шардинг -- т.е. разделение одной
  таблицы по разным ресурсам. Как это выглядит на практике? Все
  просто. На разных серверах у нас будет таблица с одинаковой
  структурой, но разными данными. Для нашего случая с сообщениями,
  мы можем хранить первые 10 миллионов сообщений на одном сервере,
  вторые 10 - на втором и т.д. Т.е. необходимо иметь критерий
  шардинга -- какой-то параметр, который позволит определять, на
  каком именно сервере лежат те или иные данные.</p>

  <p>Обычно, в качестве параметра шардинга выбирают ID пользователя
  (user_id) -- это позволяет делить данные по серверам равномерно и
  просто. Т.о. при получении личных сообщений пользователей
  алгоритм работы будет такой:</p>

  <ul>
    <li>Определить, на каком сервере БД лежат сообщения
    пользователя исходя из user_id</li>

    <li>Инициализировать соединение с этим сервером</li>

    <li>Выбрать сообщения</li>
  </ul>

  <p>Задачу определения конкретного сервера можно решать двумя
  путями:</p>

  <ul>
    <li>Хранить в одном месте хеш-таблицу с соответствиями
    «пользователь=сервер». Тогда, при определении сервера, нужно
    будет выбрать сервер из этой таблицы. В этом случае узкое место
    -- это большая таблица соответсвия, которую нужно хранить в
    одном месте. Для таких целей очень хорошо подходят базы данных
    «ключ=значение»</li>

    <li>Определять имя сервера с помощью числового (буквенного)
    преобразования. Например, можно вычислять номер сервера, как
    остаток от деления на определенное число (количество серверов,
    между которыми Вы делите таблицу). В этом случае узкое место --
    это проблема добавления новых серверов -- Вам придется делать
    перераспределение данных между новым количеством серверов.</li>
  </ul>

  <p>Для шардинга не существует решения на уровне известных
  платформ, т.к. это весьма специфическая для отдельно взятого
  приложения задача.</p>

  <p>Естественно, делая горизонтальный шардинг, Вы ограничиваете
  себя в возможности выборок, которые требуют пересмотра всей
  таблицы (например, последние посты в блогах людей будет достать
  невозможно, если таблица постов шардится). Такие задачи придется
  решать другими подходами. Например, для описанного примера, можно
  при появлении нового поста, заносить его ID в общий стек,
  размером в 100 элементом.</p>

  <p>Горизонтальный шардинг имеет одно явное преимущество -- он
  бесконечно масштабируем. Для создания шардинга PostgreSQL
  существует несколько решений:</p>

  <ul>
    <li><span class="textbf">Greenplum Database</span><a name=
    "tex2html23" href="#foot1343" id="tex2html23"><sup><span class=
    "arabic">23</span></sup></a></li>

    <li><span class="textbf">GridSQL for EnterpriseDB Advanced
    Server</span><a name="tex2html24" href="#foot1345" id=
    "tex2html24"><sup><span class="arabic">24</span></sup></a></li>

    <li><span class="textbf">Sequoia</span><a name="tex2html25"
    href="#foot1347" id="tex2html25"><sup><span class=
    "arabic">25</span></sup></a></li>

    <li><span class="textbf">PL/Proxy</span><a name="tex2html26"
    href="#foot1349" id="tex2html26"><sup><span class=
    "arabic">26</span></sup></a></li>

    <li><span class="textbf">HadoopDB</span><a name="tex2html27"
    href="#foot1351" id="tex2html27"><sup><span class=
    "arabic">27</span></sup></a> (Shared-nothing clustering)</li>
  </ul>

  <h1><a name="SECTION00620000000000000000" id=
  "SECTION00620000000000000000"><span class="arabic">2</span>
  Заключение</a></h1>В данной главе расмотрено лиш базовые
  настройки кластеров БД. Про кластеры PostgreSQL потребуется
  написать отдельную книгу, чтобы растмотреть все шаги с
  установкой, настройкой и работой кластеров. Надеюсь, что несмотря
  на это, информация будет полезна многим читателям.

  <h1><a name="SECTION00700000000000000000" id=
  "SECTION00700000000000000000"><span class="arabic">6</span>
  Мультиплексоры соединений</a></h1><br />
  <img width="428" height="93" align="bottom" border="0" src=
  "postgresql-img46.png" alt=
  "\begin{epigraphs} \qitem{Если сразу успеха не добились,... ...�о упорствовать?}{Уильям Клод Филдс} \end{epigraphs}" />
  <br />

  <h1><a name="SECTION00710000000000000000" id=
  "SECTION00710000000000000000"><span class="arabic">1</span>
  Введение</a></h1>Мультиплексоры соединений(программы для создания
  пула коннектов) позволяют уменьшить накладные расходы на базу
  данных, когда огромное количество физических соединений тянет
  производительность PostgreSQL вниз. Это особенно важно на
  Windows, когда система ограничивает большое количество
  соединений. Это также важно для веб-приложений, где количество
  соединений может быть очень большим.

  <p>Программы, которые создают пулы соединений:</p>

  <ul>
    <li>PgBouncer</li>

    <li>Pgpool</li>
  </ul>

  <p>Также некоторые администраторы PostgreSQL с успехом используют
  Memcached для уменьшения работы БД за счет кэширования
  данных.</p>

  <h1><a name="SECTION00720000000000000000" id=
  "SECTION00720000000000000000"><span class="arabic">2</span>
  PgBouncer</a></h1>Это мультиплексор соединений для PostgreSQL от
  компании Skype. Существуют три режима управления.

  <ul>
    <li><span class="textbf">Session Pooling.</span> Наиболее
    «вежливый» режим. При начале сессии клиенту выделяется
    соединение с сервером; оно приписано ему в течение всей сессии
    и возвращается в пул только после отсоединения клиента.</li>

    <li><span class="textbf">Transaction Pooling.</span> Клиент
    владеет соединением с бакендом только в течение транзакции.
    Когда PgBouncer замечает, что транзакция завершилась, он
    возвращает соединение назад в пул.</li>

    <li><span class="textbf">Statement Pooling.</span> Наиболее
    агрессивный режим. Соединение с бакендом возвращается назад в
    пул сразу после завершения запроса. Транзакции с несколькими
    запросами в этом режиме не разрешены, так как они гарантировано
    будут отменены. Также не работают подготовленные выражения
    (prepared statements) в этом режиме.</li>
  </ul>

  <p>К достоинствам PgBouncer относится:</p>

  <ul>
    <li>малое потребление памяти (менее 2 КБ на соединение);</li>

    <li>отсутствие привязки к одному серверу баз данных;</li>

    <li>реконфигурация настроек без рестарта.</li>
  </ul>

  <p>Базовая утилита запускается так:<br />
  <img width="589" height="72" align="bottom" border="0" src=
  "postgresql-img47.png" alt=
  "\begin{lstlisting}[label=lst:pgbouncer1,caption=PgBouncer] pgbouncer [-d][-R][-v][-u user] &lt;pgbouncer.ini&gt; \end{lstlisting}" />
  <br /></p>

  <p>Простой пример для конфига:<br />
  <img width="598" height="303" align="bottom" border="0" src=
  "postgresql-img48.png" alt=
  "\begin{lstlisting}[label=lst:pgbouncer2,caption=PgBouncer] [databases] template1... ... = pgbouncer.log pidfile = pgbouncer.pid admin_users = someuser \end{lstlisting}" />
  <br /></p>

  <p>Нужно создать файл пользователей userlist.txt примерного
  содержания:''someuser'' ''same_password_as_in_server''</p>

  <p>Админский доступ из консоли к базе данных pgbouncer:<br />
  <img width="589" height="72" align="bottom" border="0" src=
  "postgresql-img49.png" alt=
  "\begin{lstlisting}[label=lst:pgbouncer3,caption=PgBouncer] psql -h 127.0.0.1 -p 6543 pgbouncer \end{lstlisting}" />
  <br /></p>

  <p>Здесь можно получить различную статистическую информацию с
  помощью команды SHOW.</p>

  <h1><a name="SECTION00730000000000000000" id=
  "SECTION00730000000000000000"><span class="arabic">3</span>
  PgPool-II vs PgBouncer</a></h1>

  <p>Все очень просто. PgBouncer намного лучше работает с пулами
  соединений, чем PgPool-II. Если вам не нужны остальные фичи,
  которыми владеет PgPool-II (ведь пулы коннектов это мелочи к его
  функционалу), то конечно лучше использовать PgBouncer.</p>

  <ul>
    <li>PgBouncer потребляет меньше памяти, чем PgPool-II</li>

    <li>у PgBouncer возможно настроить очередь соединений</li>

    <li>в PgBouncer можно настраивать псевдо базы данных (на
    сервере они могут называтся по другому)</li>
  </ul>

  <p>Хотя некоторые используют PgBouncer и PgPool-II совместно.</p>

  <h1><a name="SECTION00800000000000000000" id=
  "SECTION00800000000000000000"><span class="arabic">7</span> Бэкап
  и восстановление PostgreSQL</a></h1><br />
  <img width="427" height="160" align="bottom" border="0" src=
  "postgresql-img50.png" alt=
  "\begin{epigraphs} \qitem{Есть два типа администраторов... ...изойти, она случается.}{Закон Мэрфи} \end{epigraphs}" />
  <br />

  <h1><a name="SECTION00810000000000000000" id=
  "SECTION00810000000000000000"><span class="arabic">1</span>
  Введение</a></h1>Любой хороший сисадмин знает -- бэкапы нужны
  всегда. На сколько бы надежна не казалась Ваша система, всегда
  может произойти случай, который был не учтен, и из-за которого
  могут быть потеряны данные.

  <p>Тоже самое касается и PostgreSQL баз данных. Бекапы должны
  быть! Посыпавшийся винчестер на сервере, ошибка в фаловой
  системе, ошибка в другой программе, которая перетерла весь
  каталог PostgreSQL и многое другое приведет только к плачевному
  результату. И даже если у Вас репликация с множеством слейвов,
  это не означает, что система в безопасности -- неверный запрос на
  мастер (DELETE, DROP), и у слейвов такая же порция данных (точнее
  их отсутствие).</p>

  <p>Существуют три принципиально различных подхода к резервному
  копированию данных PostgreSQL:</p>

  <ul>
    <li>SQL бэкап;</li>

    <li>Бекап уровня файловой системы;</li>

    <li>Непрерывное резервное копирование;</li>
  </ul>Каждый из этих подходов имеет свои сильные и слабые стороны.

  <h1><a name="SECTION00820000000000000000" id=
  "SECTION00820000000000000000"><span class="arabic">2</span> SQL
  бэкап</a></h1>Идея этого подхода в создании текстового файла с
  командами SQL. Такой файл можно передать обратно на сервер и
  воссоздать базу данных в том же состоянии, в котором она была во
  время бэкапа. У PostgreSQL для этого есть специальная утилита --
  pg_dump. Пример использования pg_dump:<br />
  <img width="589" height="72" align="bottom" border="0" src=
  "postgresql-img51.png" alt=
  "\begin{lstlisting}[label=lst:backups1,caption=Создаем бэкап с помощью pg\_dump] pg_dump dbname &gt; outfile \end{lstlisting}" />
  <br />

  <p>Для восстановления такого бэкапа достаточно выполнить:<br />
  <img width="589" height="72" align="bottom" border="0" src=
  "postgresql-img52.png" alt=
  "\begin{lstlisting}[label=lst:backups2,caption=Восстанавливаем бэкап] psql dbname &lt; infile \end{lstlisting}" />
  <br /></p>

  <p>При этом базу данных «dbname» потребуется создать перед
  восстановлением. Также потребуется создать пользователей, которые
  имеют доступ к данным, которые восстанавливаются (это можно и не
  делать, но тогда просто в выводе восстановления будут ошибки).
  Если нам требуется, чтобы восстановление прекратилось при
  возникновении ошибки, тогда потребуется восстанавливать бэкап
  таким способом:<br />
  <img width="589" height="72" align="bottom" border="0" src=
  "postgresql-img53.png" alt=
  "\begin{lstlisting}[label=lst:backups3,caption=Восстанавливаем бэкап] psql --set ON_ERROR_STOP=on dbname &lt; infile \end{lstlisting}" />
  <br /></p>

  <p>Также, можно делать бэкап и сразу восстанавливать его на
  другую базу:<br />
  <img width="589" height="72" align="bottom" border="0" src=
  "postgresql-img54.png" alt=
  "\begin{lstlisting}[label=lst:backups4,caption=Бекап в другую БД] pg_dump -h host1 dbname \vert psql -h host2 dbname \end{lstlisting}" />
  <br /></p>

  <p>После восстановления бэкапа желательно запустить «ANALYZE»,
  чтобы оптимизатор запросов обновил статистику.</p>

  <p>А что, если нужно сделать бэкап не одной базы данных, а всех,
  да и еще получить в бэкапе информацию про роли и таблицы? В таком
  случае у PostgreSQL есть утилита pg_dumpall. pg_dumpall
  используется для создания бэкапа данных всего кластера
  PostgreSQL:<br />
  <img width="589" height="72" align="bottom" border="0" src=
  "postgresql-img55.png" alt=
  "\begin{lstlisting}[label=lst:backups5,caption=Бекап кластера PostgreSQL] pg_dumpall &gt; outfile \end{lstlisting}" />
  <br /></p>

  <p>Для восстановления такого бэкапа достаточно выполнить от
  суперпользователя:<br />
  <img width="589" height="72" align="bottom" border="0" src=
  "postgresql-img56.png" alt=
  "\begin{lstlisting}[label=lst:backups6,caption=Восстановления бэкапа PostgreSQL] psql -f infile postgres \end{lstlisting}" />
  <br /></p>

  <h2><a name="SECTION00821000000000000000" id=
  "SECTION00821000000000000000"><span class="arabic">1</span> SQL
  бэкап больших баз данных</a></h2>Некоторые операционные системы
  имеют ограничения на максимальный размер файла, что может
  вызывають проблемы при создании больших бэкапов через pg_dump. К
  счастью, pg_dump можете бэкапить в стандартный вывод. Так что
  можно использовать стандартные инструменты Unix, чтобы обойти эту
  проблему. Есть несколько возможных способов:

  <ul>
    <li>
      <span class="textbf">Использовать сжатие для бэкапа.</span>

      <p>Можно использовать программу сжатия данных, например
      GZIP:<br />
      <img width="589" height="72" align="bottom" border="0" src=
      "postgresql-img57.png" alt=
      "\begin{lstlisting}[label=lst:backups7,caption=Сжатие бэкапа PostgreSQL] pg_dump dbname \vert gzip &gt; filename.gz \end{lstlisting}" />
      <br /></p>

      <p>Восстановление:<br />
      <img width="589" height="72" align="bottom" border="0" src=
      "postgresql-img58.png" alt=
      "\begin{lstlisting}[label=lst:backups8,caption=Восстановление бэкапа PostgreSQL] gunzip -c filename.gz \vert psql dbname \end{lstlisting}" />
      <br />
      или<br />
      <img width="589" height="72" align="bottom" border="0" src=
      "postgresql-img59.png" alt=
      "\begin{lstlisting}[label=lst:backups9,caption=Восстановление бэкапа PostgreSQL] cat filename.gz \vert gunzip \vert psql dbname \end{lstlisting}" />
      <br /></p>
    </li>

    <li>
      <span class="textbf">Использовать команду split.</span>

      <p>Команда split позволяет разделить вывод в файлы меньшего
      размера, которые являются подходящими по размеру для файловой
      системы. Например, бэкап делится на куски по 1
      мегабайту:<br />
      <img width="589" height="72" align="bottom" border="0" src=
      "postgresql-img60.png" alt=
      "\begin{lstlisting}[label=lst:backups10,caption=Создание бэкапа PostgreSQL] pg_dump dbname \vert split -b 1m - filename \end{lstlisting}" />
      <br />
      Восстановление:<br />
      <img width="589" height="72" align="bottom" border="0" src=
      "postgresql-img61.png" alt=
      "\begin{lstlisting}[label=lst:backups11,caption=Восстановление бэкапа PostgreSQL] cat filename* \vert psql dbname \end{lstlisting}" />
      <br /></p>
    </li>

    <li>
      <span class="textbf">Использовать пользовательский формат
      дампа pg_dump</span>

      <p>PostgreSQL построен на системе с библиотекой сжатия Zlib,
      поэтому пользовательский формат бэкапа будет в сжатом виде.
      Это похоже на метод с импользованием GZIP, но он имеет
      дополнительное преимущество -- таблицы могут быть
      восстановлены выборочно:<br />
      <img width="589" height="72" align="bottom" border="0" src=
      "postgresql-img62.png" alt=
      "\begin{lstlisting}[label=lst:backups12,caption=Создание бэкапа PostgreSQL] pg_dump -Fc dbname &gt; filename \end{lstlisting}" />
      <br />
      Через psql такой бэкап не восстановить, но для этого есть
      утилита pg_restore:<br />
      <img width="589" height="72" align="bottom" border="0" src=
      "postgresql-img63.png" alt=
      "\begin{lstlisting}[label=lst:backups13,caption=Восстановление бэкапа PostgreSQL] pg_restore -d dbname filename \end{lstlisting}" />
      <br /></p>
    </li>
  </ul>

  <p>При слишком большой базе данных, вариант с командой split
  нужно комбинировать с сжатием данных.</p>

  <h1><a name="SECTION00830000000000000000" id=
  "SECTION00830000000000000000"><span class="arabic">3</span> Бекап
  уровня файловой системы</a></h1>Альтернативный метод резервного
  копирования заключается в непосредственном копировании файлов,
  которые PostgreSQL использует для хранения данных в базе данных.
  Например:<br />
  <img width="589" height="72" align="bottom" border="0" src=
  "postgresql-img64.png" alt=
  "\begin{lstlisting}[label=lst:backups14,caption=Бэкап PostgreSQL файлов] tar -cf backup.tar /usr/local/pgsql/data \end{lstlisting}" />
  <br />

  <p>Но есть два ограничения, которые делает этот метод
  нецелесообразным, или, по крайней мере, уступающим SQL
  бэкапу:</p>

  <ul>
    <li>PostgreSQL база данных должна быть остановленна, для того,
    чтобы получить актуальный бэкап (PostgreSQL держит множество
    обьектов в памяти, буферизация файловой системы). Излишне
    говорить, что во время восстановления такого бэкапа потребуется
    также остановить PostgreSQL.</li>

    <li>Не получится востановить только определенные данные с
    такого бэкапа.</li>
  </ul>

  <p>Как альтернатива, можно делать снимки (snapshot) файлов
  системы (папки с файлами PostgreSQL). В таком случае
  останавливать PostgreSQL не требуется. Однако, резервная копия,
  созданная таким образом, сохраняет файлы базы данных в состоянии,
  как если бы сервер базы данных был неправильно остановлен.
  Поэтому при запуске PostgreSQL из резервной копии, он будет
  думать, что предыдущий экземпляр сервера вышел из строя и
  повторит журнала WAL. Это не проблема, просто надо знать про это
  (и не забыть включить WAL файлы в резервную копию). Также, если
  файловая система PostgreSQL распределена по разным файловым
  система, то такой метод бэкапа будет очень не надежным -- снимки
  файлов системы должны быть сделаны одновременно(!!!). Почитайте
  документацию файловой системы очень внимательно, прежде чем
  доверять снимкам файлов системы в таких ситуациях.</p>

  <p>Также возможен вариант с использованием rsync. Первым запуском
  rsync мы копируем основные файлы с директории PostgreSQL
  (PostgreSQL при этом продолжает работу). После этого мы
  останавливаем PostgreSQL и запускаем повторно rsync. Второй
  запуск rsync пройдет гораздо быстрее, чем первый, потому что
  будет передавать относительно небольшой размер данных, и конечный
  результат будет соответствовать остановленной СУБД. Этот метод
  позволяет делать бекап уровня файловой системы с минимальным
  временем простоя.</p>

  <h1><a name="SECTION00840000000000000000" id=
  "SECTION00840000000000000000"><span class="arabic">4</span>
  Непрерывное резервное копирование</a></h1>PostgreSQL поддерживает
  упреждаюшию запись логов (Write Ahead Log, WAL) в pg_xlog
  директорию, которая находится в директории данных СУБД. В логи
  пишутся все изменения сделаные с данными в СУБД. Этот журнал
  существует прежде всего для безопасности во время краха
  PostgreSQL: если происходят сбои в системе, базы данных могут
  быть восстановлены с помощью «перезапуска» этого журнала. Тем не
  менее, существование журнала делает возможным использование
  третью стратегии для резервного копирования баз данных: мы можем
  объединить бекап уровня файловой системы с резервной копией WAL
  файлов. Если требуется восстановить такой бэкап, то мы
  восстановливаем файлы резервной копии файловой системы, а затем
  «перезапускаем» с резервной копии файлов WAL для приведения
  системы к актуальному состоянию. Этот подход является более
  сложным для администрирования, чем любой из предыдущих подходов,
  но он имеет некоторые преимущества:

  <ul>
    <li>Не нужно согласовывать файлы резервной копии системы. Любая
    внутренняя противоречивость в резервной копии будет исправлена
    путем преобразования журнала (не отличается от того, что
    происходит во время восстановления после сбоя).</li>

    <li>Восстановление состояния сервера для определенного момента
    времени.</li>

    <li>Если мы постоянно будем «скармливать» файлы WAL на другую
    машину, которая была загружена с тех же файлов резервной базы,
    то у нас будет резервный сервер PostgreSQL всегда в актуальном
    состоянии (создание сервера горячего резерва).</li>
  </ul>

  <p>Как и бэкап файловой системы, этот метод может поддерживать
  только восстановление всей базы данных кластера. Кроме того, он
  требует много места для хранения WAL файлов.</p>

  <h2><a name="SECTION00841000000000000000" id=
  "SECTION00841000000000000000"><span class="arabic">1</span>
  Настройка</a></h2>Первый шаг -- активировать архивирование. Эта
  процедура будет копировать WAL файлы в архивный каталог из
  стандартного каталога pg_xlog. Это делается в файле
  postgresql.conf:<br />
  <img width="590" height="141" align="bottom" border="0" src=
  "postgresql-img65.png" alt=
  "\begin{lstlisting}[label=lst:backups15,caption=Настройка архивир... ...l/archives/%f' archive_timeout = 300 ..." />
  <br />

  <p>После этого необходимо перенести файлы (в порядке их
  появления) в архивный каталог. Для этого можно использовать
  функцию rsync. Можно поставить функцию в список задач крона и,
  таким образом, файлы могут автоматически перемещаться между
  хостми каждые несколько минут.<br />
  <img width="590" height="95" align="bottom" border="0" src=
  "postgresql-img66.png" alt=
  "\begin{lstlisting}[label=lst:backups16,caption=Копирование WAL фай... ...prod1:/data/pgsql/archives/ /data/pgsql/archives/ &gt; /dev/null \end{lstlisting}" />
  <br /></p>

  <p>В конце, необходимо скопировать файлы в каталог pg_xlog на
  сервере PostgreSQL (он должен быть в режиме восстановления). Для
  этого создается в каталоге данных PostgreSQL создать файл
  recovery.conf с заданной командой копирования файлов из архива в
  нужную директорию:<br />
  <img width="589" height="95" align="bottom" border="0" src=
  "postgresql-img67.png" alt=
  "\begin{lstlisting}[label=lst:backups17,caption=recovery.conf] restore_command = 'cp /data/pgsql/archives/%f ''%p''' \end{lstlisting}" />
  <br /></p>

  <p>Документация PostgreSQL предлагает хорошее описание настройки
  непрерывного копирования, поэтому я не углублялся в детали
  (например, как перенести директорию СУБД с одного сервера на
  другой, какие могут быть проблемы). Более подробно вы можете
  почитать по этой ссылке
  http://www.postgresql.org/docs/9.0/static/continuous-archiving.html.</p>

  <h1><a name="SECTION00850000000000000000" id=
  "SECTION00850000000000000000"><span class="arabic">5</span>
  Заключение</a></h1>В любом случае, усилия и время, затраченные на
  создание оптимальной системы создания бэкапов, будут оправданы.
  Невозможно предугадать когда произойдут проблемы с базой данных,
  поэтому бэкапы должны быть настроены для PostgreSQL (особенно,
  если это продакшн система).

  <p><br /></p>
  <hr />

  <h4>Footnotes</h4>

  <dl>
    <dt><a name="foot340" id="foot340">... мусор</a><a href=
    "postgresql.html#tex2html1"><sup><span class=
    "arabic">1</span></sup></a></dt>

    <dd>под которым понимаются старые версии изменённых/удалённых
    записей</dd>

    <dt><a name="foot357" id="foot357">... часто</a><a href=
    "postgresql.html#tex2html2"><sup><span class=
    "arabic">2</span></sup></a></dt>

    <dd>«слишком часто» можно определить как «чаще раза в минуту».
    Вы также можете задать параметр checkpoint_warning (в
    секундах): в журнал сервера будут писаться предупреждения, если
    контрольные точки происходят чаще заданного.</dd>

    <dt><a name="foot368" id="foot368">... логов</a><a href=
    "postgresql.html#tex2html3"><sup><span class=
    "arabic">3</span></sup></a></dt>

    <dd>буфер находится в разделяемой памяти и является общим для
    всех процессов</dd>

    <dt><a name="foot374" id="foot374">... запроса</a><a href=
    "postgresql.html#tex2html4"><sup><span class=
    "arabic">4</span></sup></a></dt>

    <dd>Указывает планировщику на размер самого большого объекта в
    базе данных, который теоретически может быть закеширован</dd>

    <dt><a name="foot508" id="foot508">... noatime</a><a href=
    "postgresql.html#tex2html5"><sup><span class=
    "arabic">5</span></sup></a></dt>

    <dd>при этом не будет отслеживаться время последнего доступа к
    файлу</dd>

    <dt><a name="foot510" id="foot510">... дисков</a><a href=
    "postgresql.html#tex2html6"><sup><span class=
    "arabic">6</span></sup></a></dt>

    <dd>несколько логических разделов на одном диске здесь,
    очевидно, не помогут: головка всё равно будет одна</dd>

    <dt><a name="foot543" id="foot543">... pgtune</a><a href=
    "postgresql.html#tex2html7"><sup><span class=
    "arabic">7</span></sup></a></dt>

    <dd>http://pgtune.projects.postgresql.org/</dd>

    <dt><a name="foot603" id="foot603">... запрос</a><a href=
    "postgresql.html#tex2html8"><sup><span class=
    "arabic">8</span></sup></a></dt>

    <dd>и поэтому EXPLAIN ANALYZE DELETE ... -- не слишком хорошая
    идея</dd>

    <dt><a name="foot628" id="foot628">... правила</a><a href=
    "postgresql.html#tex2html9"><sup><span class=
    "arabic">9</span></sup></a></dt>

    <dd>RULE -- реализованное в PostgreSQL расширение стандарта
    SQL, позволяющее, в частности, создавать обновляемые
    представления</dd>

    <dt><a name="foot638" id="foot638">... порядок</a><a href=
    "postgresql.html#tex2html10"><sup><span class=
    "arabic">10</span></sup></a></dt>

    <dd>«на нашем форуме более 10000 зарегистрированных
    пользователей, оставивших более 50000 сообщений!»</dd>

    <dt><a name="foot648" id="foot648">... pgFouine</a><a href=
    "postgresql.html#tex2html11"><sup><span class=
    "arabic">11</span></sup></a></dt>

    <dd>http://pgfouine.projects.postgresql.org/</dd>

    <dt><a name="foot857" id="foot857">...Slony-I</a><a href=
    "postgresql.html#tex2html12"><sup><span class=
    "arabic">12</span></sup></a></dt>

    <dd>http://www.slony.info/</dd>

    <dt><a name="foot859" id="foot859">...PGCluster</a><a href=
    "postgresql.html#tex2html13"><sup><span class=
    "arabic">13</span></sup></a></dt>

    <dd>http://pgfoundry.org/projects/pgcluster/</dd>

    <dt><a name="foot861" id="foot861">...pgpool-I/II</a><a href=
    "postgresql.html#tex2html14"><sup><span class=
    "arabic">14</span></sup></a></dt>

    <dd>http://pgpool.projects.postgresql.org/</dd>

    <dt><a name="foot865" id="foot865">...Bucardo</a><a href=
    "postgresql.html#tex2html15"><sup><span class=
    "arabic">15</span></sup></a></dt>

    <dd>http://bucardo.org/</dd>

    <dt><a name="foot867" id="foot867">...Londiste</a><a href=
    "postgresql.html#tex2html16"><sup><span class=
    "arabic">16</span></sup></a></dt>

    <dd>
    http://skytools.projects.postgresql.org/doc/londiste.ref.html</dd>

    <dt><a name="foot868" id="foot868">... Skytools</a><a href=
    "postgresql.html#tex2html17"><sup><span class=
    "arabic">17</span></sup></a></dt>

    <dd>http://pgfoundry.org/projects/skytools/</dd>

    <dt><a name="foot870" id="foot870">... Replicator</a><a href=
    "postgresql.html#tex2html18"><sup><span class=
    "arabic">18</span></sup></a></dt>

    <dd>
    http://www.commandprompt.com/products/mammothreplicator/</dd>

    <dt><a name="foot872" id="foot872">...Postgres-R</a><a href=
    "postgresql.html#tex2html19"><sup><span class=
    "arabic">19</span></sup></a></dt>

    <dd>http://www.postgres-r.org/</dd>

    <dt><a name="foot874" id="foot874">...RubyRep</a><a href=
    "postgresql.html#tex2html20"><sup><span class=
    "arabic">20</span></sup></a></dt>

    <dd>http://www.rubyrep.org/</dd>

    <dt><a name="foot1159" id="foot1159">... исходников</a><a href=
    "postgresql.html#tex2html21"><sup><span class=
    "arabic">21</span></sup></a></dt>

    <dd>http://search.cpan.org/CPAN/authors/id/T/TU/TURNSTEP/</dd>

    <dt><a name="foot1162" id="foot1162">... Скачиваем</a><a href=
    "postgresql.html#tex2html22"><sup><span class=
    "arabic">22</span></sup></a></dt>

    <dd>http://bucardo.org/wiki/Bucardo#Obtaining_Bucardo</dd>

    <dt><a name="foot1343" id="foot1343">... Database</a><a href=
    "postgresql.html#tex2html23"><sup><span class=
    "arabic">23</span></sup></a></dt>

    <dd>
    http://www.greenplum.com/index.php?page=greenplum-database</dd>

    <dt><a name="foot1345" id="foot1345">... Server</a><a href=
    "postgresql.html#tex2html24"><sup><span class=
    "arabic">24</span></sup></a></dt>

    <dd>http://www.enterprisedb.com/products/gridsql.do</dd>

    <dt><a name="foot1347" id="foot1347">...Sequoia</a><a href=
    "postgresql.html#tex2html25"><sup><span class=
    "arabic">25</span></sup></a></dt>

    <dd>
    http://www.continuent.com/community/lab-projects/sequoia</dd>

    <dt><a name="foot1349" id="foot1349">...PL/Proxy</a><a href=
    "postgresql.html#tex2html26"><sup><span class=
    "arabic">26</span></sup></a></dt>

    <dd>
    http://plproxy.projects.postgresql.org/doc/tutorial.html</dd>

    <dt><a name="foot1351" id="foot1351">...HadoopDB</a><a href=
    "postgresql.html#tex2html27"><sup><span class=
    "arabic">27</span></sup></a></dt>

    <dd>http://db.cs.yale.edu/hadoopdb/hadoopdb.html</dd>
  </dl><br />
  <hr />
</body>
</html>
