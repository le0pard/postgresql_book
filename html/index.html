<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Работа с PostgreSQL: настройка и масштабирование</title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<div id="header">
<h1 class="title">Работа с PostgreSQL: настройка и масштабирование</h1>
<h3 class="date">Creative Commons Attribution-NonCommercial 4.0 International<br />2010–2014</h3>
</div>
<div id="TOC">
<ul>
<li><a href="#введение">Введение</a></li>
<li><a href="#настройка-производительности">Настройка производительности</a><ul>
<li><a href="#введение-1">Введение</a><ul>
<li><a href="#не-используйте-настройки-по-умолчанию">Не используйте настройки по умолчанию</a></li>
<li><a href="#используйте-актуальную-версию-сервера">Используйте актуальную версию сервера</a></li>
<li><a href="#стоит-ли-доверять-тестам-производительности">Стоит ли доверять тестам производительности</a></li>
</ul></li>
<li><a href="#настройка-сервера">Настройка сервера</a><ul>
<li><a href="#используемая-память">Используемая память</a></li>
<li><a href="#журнал-транзакций-и-контрольные-точки">Журнал транзакций и контрольные точки</a></li>
<li><a href="#планировщик-запросов">Планировщик запросов</a></li>
<li><a href="#сбор-статистики">Сбор статистики</a></li>
</ul></li>
<li><a href="#диски-и-файловые-системы">Диски и файловые системы</a><ul>
<li><a href="#перенос-журнала-транзакций-на-отдельный-диск">Перенос журнала транзакций на отдельный диск</a></li>
<li><a href="#cluster">CLUSTER</a></li>
</ul></li>
<li><a href="#примеры-настроек">Примеры настроек</a><ul>
<li><a href="#среднестатистическая-настройка-для-максимальной-производительности">Среднестатистическая настройка для максимальной производительности</a></li>
<li><a href="#среднестатистическая-настройка-для-оконного-приложения-1с-2-гб-памяти">Среднестатистическая настройка для оконного приложения (1С), 2 ГБ памяти</a></li>
<li><a href="#среднестатистическая-настройка-для-web-приложения-2-гб-памяти">Среднестатистическая настройка для Web приложения, 2 ГБ памяти</a></li>
<li><a href="#среднестатистическая-настройка-для-web-приложения-8-гб-памяти">Среднестатистическая настройка для Web приложения, 8 ГБ памяти</a></li>
</ul></li>
<li><a href="#автоматическое-создание-оптимальных-настроек-pgtune">Автоматическое создание оптимальных настроек: pgtune</a></li>
<li><a href="#оптимизация-бд-и-приложения">Оптимизация БД и приложения</a><ul>
<li><a href="#поддержание-базы-в-порядке">Поддержание базы в порядке</a></li>
<li><a href="#использование-индексов">Использование индексов</a></li>
<li><a href="#перенос-логики-на-сторону-сервера">Перенос логики на сторону сервера</a></li>
<li><a href="#оптимизация-конкретных-запросов">Оптимизация конкретных запросов</a></li>
<li><a href="#утилиты-для-оптимизации-запросов">Утилиты для оптимизации запросов</a></li>
</ul></li>
<li><a href="#заключение">Заключение</a></li>
</ul></li>
<li><a href="#партиционирование">Партиционирование</a><ul>
<li><a href="#введение-2">Введение</a></li>
<li><a href="#теория">Теория</a></li>
<li><a href="#практика-использования">Практика использования</a><ul>
<li><a href="#настройка">Настройка</a></li>
<li><a href="#тестирование">Тестирование</a></li>
<li><a href="#управление-партициями">Управление партициями</a></li>
<li><a href="#важность-constraint_exclusion-для-партиционирования">Важность «constraint_exclusion» для партиционирования</a></li>
</ul></li>
<li><a href="#заключение-1">Заключение</a></li>
</ul></li>
<li><a href="#репликация">Репликация</a><ul>
<li><a href="#введение-3">Введение</a></li>
<li><a href="#streaming-replication-потоковая-репликация">Streaming Replication (Потоковая репликация)</a><ul>
<li><a href="#введение-4">Введение</a></li>
<li><a href="#установка">Установка</a></li>
<li><a href="#настройка-1">Настройка</a></li>
<li><a href="#общие-задачи">Общие задачи</a></li>
</ul></li>
<li><a href="#slony-i">Slony-I</a><ul>
<li><a href="#введение-5">Введение</a></li>
<li><a href="#установка-1">Установка</a></li>
<li><a href="#sec:slonyI">Настройка</a></li>
<li><a href="#общие-задачи-1">Общие задачи</a></li>
<li><a href="#устранение-неисправностей">Устранение неисправностей</a></li>
</ul></li>
<li><a href="#sec:londiste">Londiste</a><ul>
<li><a href="#введение-6">Введение</a></li>
<li><a href="#установка-2">Установка</a></li>
<li><a href="#настройка-2">Настройка</a></li>
<li><a href="#общие-задачи-2">Общие задачи</a></li>
<li><a href="#устранение-неисправностей-1">Устранение неисправностей</a></li>
</ul></li>
<li><a href="#bucardo">Bucardo</a><ul>
<li><a href="#введение-7">Введение</a></li>
<li><a href="#установка-3">Установка</a></li>
<li><a href="#настройка-3">Настройка</a></li>
<li><a href="#общие-задачи-3">Общие задачи</a></li>
</ul></li>
<li><a href="#rubyrep">RubyRep</a><ul>
<li><a href="#введение-8">Введение</a></li>
<li><a href="#установка-4">Установка</a></li>
<li><a href="#настройка-4">Настройка</a></li>
<li><a href="#устранение-неисправностей-2">Устранение неисправностей</a></li>
</ul></li>
<li><a href="#заключение-2">Заключение</a></li>
</ul></li>
<li><a href="#шардинг">Шардинг</a><ul>
<li><a href="#введение-9">Введение</a></li>
<li><a href="#sec:plproxy">PL/Proxy</a><ul>
<li><a href="#установка-5">Установка</a></li>
<li><a href="#настройка-5">Настройка</a></li>
<li><a href="#все-ли-так-просто">Все ли так просто?</a></li>
</ul></li>
<li><a href="#sec:postgres-xc">Postgres-XC</a><ul>
<li><a href="#архитектура">Архитектура</a></li>
<li><a href="#установка-6">Установка</a></li>
<li><a href="#распределение-данных-и-масштабируемость">Распределение данных и масштабируемость</a></li>
<li><a href="#таблицы-и-запросы-к-ним">Таблицы и запросы к ним</a></li>
<li><a href="#высокая-доступность-ha">Высокая доступность (HA)</a></li>
<li><a href="#ограничения">Ограничения</a></li>
<li><a href="#заключение-3">Заключение</a></li>
</ul></li>
<li><a href="#hadoopdb">HadoopDB</a><ul>
<li><a href="#установка-и-настройка">Установка и настройка</a></li>
<li><a href="#заключение-4">Заключение</a></li>
</ul></li>
<li><a href="#заключение-5">Заключение</a></li>
</ul></li>
<li><a href="#pgpool-ii">PgPool-II</a><ul>
<li><a href="#введение-10">Введение</a></li>
<li><a href="#sec:pgpool-II-begin">Давайте начнем!</a><ul>
<li><a href="#установка-pgpool-ii">Установка pgpool-II</a></li>
<li><a href="#файлы-конфигурации">Файлы конфигурации</a></li>
<li><a href="#настройка-команд-pcp">Настройка команд PCP</a></li>
<li><a href="#подготовка-узлов-баз-данных">Подготовка узлов баз данных</a></li>
<li><a href="#запускостановка-pgpool-ii">Запуск/Остановка pgpool-II</a></li>
</ul></li>
<li><a href="#sec:pgpool-II-replica">Ваша первая репликация</a><ul>
<li><a href="#настройка-репликации">Настройка репликации</a></li>
<li><a href="#проверка-репликации">Проверка репликации</a></li>
</ul></li>
<li><a href="#ваш-первый-параллельный-запрос">Ваш первый параллельный запрос</a><ul>
<li><a href="#настройка-параллельного-запроса">Настройка параллельного запроса</a></li>
<li><a href="#настройка-systemdb">Настройка SystemDB</a></li>
<li><a href="#установка-правил-распределения-данных">Установка правил распределения данных</a></li>
<li><a href="#установка-правил-репликации">Установка правил репликации</a></li>
<li><a href="#проверка-параллельного-запроса">Проверка параллельного запроса</a></li>
</ul></li>
<li><a href="#master-slave-режим">Master-slave режим</a><ul>
<li><a href="#streaming-replication-потоковая-репликация-1">Streaming Replication (Потоковая репликация)</a></li>
</ul></li>
<li><a href="#онлайн-восстановление">Онлайн восстановление</a><ul>
<li><a href="#streaming-replication-потоковая-репликация-2">Streaming Replication (Потоковая репликация)</a></li>
</ul></li>
<li><a href="#заключение-6">Заключение</a></li>
</ul></li>
<li><a href="#мультиплексоры-соединений">Мультиплексоры соединений</a><ul>
<li><a href="#введение-11">Введение</a></li>
<li><a href="#pgbouncer">PgBouncer</a></li>
<li><a href="#pgpool-ii-vs-pgbouncer">PgPool-II vs PgBouncer</a></li>
</ul></li>
<li><a href="#кэширование-в-postgresql">Кэширование в PostgreSQL</a><ul>
<li><a href="#введение-12">Введение</a></li>
<li><a href="#sec:pgmemcache">Pgmemcache</a><ul>
<li><a href="#установка-7">Установка</a></li>
<li><a href="#настройка-6">Настройка</a></li>
<li><a href="#проверка-1">Проверка</a></li>
<li><a href="#заключение-7">Заключение</a></li>
</ul></li>
</ul></li>
<li><a href="#расширения">Расширения</a><ul>
<li><a href="#введение-13">Введение</a></li>
<li><a href="#postgis">PostGIS</a></li>
<li><a href="#pgsphere">pgSphere</a></li>
<li><a href="#hstore">HStore</a><ul>
<li><a href="#пример-использования">Пример использования</a></li>
<li><a href="#заключение-8">Заключение</a></li>
</ul></li>
<li><a href="#plv8">PLV8</a><ul>
<li><a href="#скорость-работы">Скорость работы</a></li>
<li><a href="#использование">Использование</a></li>
<li><a href="#вывод">Вывод</a></li>
</ul></li>
<li><a href="#smlar">Smlar</a><ul>
<li><a href="#похожесть">Похожесть</a></li>
<li><a href="#расчет-похожести">Расчет похожести</a></li>
<li><a href="#smlar-1">Smlar</a></li>
<li><a href="#пример-поиск-дубликатов-картинок">Пример: поиск дубликатов картинок</a></li>
<li><a href="#вывод-1">Вывод</a></li>
</ul></li>
<li><a href="#postpic">PostPic</a></li>
<li><a href="#fuzzystrmatch">Fuzzystrmatch</a></li>
<li><a href="#tsearch2">Tsearch2</a></li>
<li><a href="#openfts">OpenFTS</a></li>
<li><a href="#plproxy">PL/Proxy</a></li>
<li><a href="#texcaller">Texcaller</a></li>
<li><a href="#pgmemcache">Pgmemcache</a></li>
<li><a href="#prefix">Prefix</a></li>
<li><a href="#dblink">Dblink</a></li>
<li><a href="#ltree">Ltree</a></li>
<li><a href="#заключение-9">Заключение</a></li>
</ul></li>
<li><a href="#бэкап-и-восстановление-postgresql">Бэкап и восстановление PostgreSQL</a><ul>
<li><a href="#введение-14">Введение</a></li>
<li><a href="#sql-бэкап">SQL бэкап</a><ul>
<li><a href="#sql-бэкап-больших-баз-данных">SQL бэкап больших баз данных</a></li>
</ul></li>
<li><a href="#бекап-уровня-файловой-системы">Бекап уровня файловой системы</a></li>
<li><a href="#непрерывное-резервное-копирование">Непрерывное резервное копирование</a><ul>
<li><a href="#настройка-7">Настройка</a></li>
</ul></li>
<li><a href="#утилиты-для-непрерывного-резервного-копирования">Утилиты для непрерывного резервного копирования</a><ul>
<li><a href="#wal-e">WAL-E</a></li>
<li><a href="#barman">Barman</a></li>
</ul></li>
<li><a href="#заключение-12">Заключение</a></li>
</ul></li>
<li><a href="#стратегии-масштабирования-для-postgresql">Стратегии масштабирования для PostgreSQL</a><ul>
<li><a href="#введение-15">Введение</a><ul>
<li><a href="#суть-проблемы">Суть проблемы</a></li>
</ul></li>
<li><a href="#проблема-чтения-данных">Проблема чтения данных</a><ul>
<li><a href="#методы-решения">Методы решения</a></li>
</ul></li>
<li><a href="#проблема-записи-данных">Проблема записи данных</a><ul>
<li><a href="#методы-решения-1">Методы решения</a></li>
</ul></li>
<li><a href="#заключение-13">Заключение</a></li>
</ul></li>
<li><a href="#советы-по-разным-вопросам-performance-snippets">Советы по разным вопросам (Performance Snippets)</a><ul>
<li><a href="#введение-16">Введение</a></li>
<li><a href="#советы">Советы</a><ul>
<li><a href="#размер-объектов-в-базе-данных">Размер объектов в базе данных</a></li>
<li><a href="#размер-самых-больших-таблиц">Размер самых больших таблиц</a></li>
<li><a href="#средний-count">«Средний» count</a></li>
<li><a href="#узнать-значение-по-умолчанию-у-поля-в-таблице">Узнать значение по умолчанию у поля в таблице</a></li>
<li><a href="#случайное-число-из-диапазона">Случайное число из диапазона</a></li>
<li><a href="#алгоритм-луна">Алгоритм Луна</a></li>
<li><a href="#выборка-и-сортировка-по-данному-набору-данных">Выборка и сортировка по данному набору данных</a></li>
<li><a href="#quine-запрос-который-выводит-сам-себя">Quine — запрос который выводит сам себя</a></li>
<li><a href="#ускоряем-like">Ускоряем LIKE</a></li>
<li><a href="#поиск-дубликатов-индексов">Поиск дубликатов индексов</a></li>
<li><a href="#размер-и-статистика-использования-индексов">Размер и статистика использования индексов</a></li>
</ul></li>
</ul></li>
</ul>
</div>
<h1 id="введение">Введение</h1>
<p>Данная книга не дает ответы на все вопросы по работе с PostgreSQL. Главное её задание — показать возможности PostgreSQL, методики настройки и масштабируемости этой СУБД. В любом случае, выбор метода решения поставленной задачи остается за разработчиком или администратором СУБД.</p>
<h1 id="настройка-производительности">Настройка производительности</h1>
<h2 id="введение-1">Введение</h2>
<p>Скорость работы, вообще говоря, не является основной причиной использования реляционных СУБД. Более того, первые реляционные базы работали медленнее своих предшественников. Выбор этой технологии был вызван скорее</p>
<ul>
<li><p>возможностью возложить поддержку целостности данных на СУБД;</p></li>
<li><p>независимостью логической структуры данных от физической.</p></li>
</ul>
<p>Эти особенности позволяют сильно упростить написание приложений, но требуют для своей реализации дополнительных ресурсов.</p>
<p>Таким образом, прежде чем искать ответ на вопрос «как заставить РСУБД работать быстрее в моей задаче?», следует ответить на вопрос «нет ли более подходящего средства для решения моей задачи, чем РСУБД?» Иногда использование другого средства потребует меньше усилий, чем настройка производительности.</p>
<p>Данная глава посвящена возможностям повышения производительности PostgreSQL. Глава не претендует на исчерпывающее изложение вопроса, наиболее полным и точным руководством по использованию PostgreSQL является, конечно, официальная документация и официальный FAQ. Также существует англоязычный список рассылки postgresql-performance, посвящённый именно этим вопросам. Глава состоит из двух разделов, первый из которых ориентирован скорее на администратора, второй — на разработчика приложений. Рекомендуется прочесть оба раздела: отнесение многих вопросов к какому-то одному из них весьма условно.</p>
<h3 id="не-используйте-настройки-по-умолчанию">Не используйте настройки по умолчанию</h3>
<p>По умолчанию PostgreSQL сконфигурирован таким образом, чтобы он мог быть запущен практически на любом компьютере и не слишком мешал при этом работе других приложений. Это особенно касается используемой памяти. Настройки по умолчанию подходят только для следующего использования: с ними вы сможете проверить, работает ли установка PostgreSQL, создать тестовую базу уровня записной книжки и потренироваться писать к ней запросы. Если вы собираетесь разрабатывать (а тем более запускать в работу) реальные приложения, то настройки придётся радикально изменить. В дистрибутиве PostgreSQL, к сожалению, не поставляется файлов с «рекомендуемыми» настройками. Вообще говоря, такие файлы создать весьма сложно, т.к. оптимальные настройки конкретной установки PostgreSQL будут определяться:</p>
<ul>
<li><p>конфигурацией компьютера;</p></li>
<li><p>объёмом и типом данных, хранящихся в базе;</p></li>
<li><p>отношением числа запросов на чтение и на запись;</p></li>
<li><p>тем, запущены ли другие требовательные к ресурсам процессы (например, веб-сервер).</p></li>
</ul>
<h3 id="используйте-актуальную-версию-сервера">Используйте актуальную версию сервера</h3>
<p>Если у вас стоит устаревшая версия PostgreSQL, то наибольшего ускорения работы вы сможете добиться, обновив её до текущей. Укажем лишь наиболее значительные из связанных с производительностью изменений.</p>
<ul>
<li><p>В версии 7.1 появился журнал транзакций, до того данные в таблицу сбрасывались каждый раз при успешном завершении транзакции.</p></li>
<li><p>В версии 7.2 появились:</p>
<ul>
<li><p>новая версия команды VACUUM, не требующая блокировки;</p></li>
<li><p>команда ANALYZE, строящая гистограмму распределения данных в столбцах, что позволяет выбирать более быстрые планы выполнения запросов;</p></li>
<li><p>подсистема сбора статистики.</p></li>
</ul></li>
<li><p>В версии 7.4 была ускорена работа многих сложных запросов (включая печально известные подзапросы IN/NOT IN).</p></li>
<li><p>В версии 8.0 были внедрены метки восстановления, улучшение управления буфером, CHECKPOINT и VACUUM улучшены.</p></li>
<li><p>В версии 8.1 был улучшен одновременный доступ к разделяемой памяти, автоматическое использование индексов для MIN() и MAX(), pg_autovacuum внедрен в сервер (автоматизирован), повышение производительности для секционированных таблиц.</p></li>
<li><p>В версии 8.2 была улучшена скорость множества SQL запросов, усовершенствован сам язык запросов.</p></li>
<li><p>В версии 8.3 внедрен полнотекстовый поиск, поддержка SQL/XML стандарта, параметры конфигурации сервера могут быть установлены на основе отдельных функций.</p></li>
<li><p>В версии 8.4 были внедрены общие табличные выражения, рекурсивные запросы, параллельное восстановление, улучшена производительность для EXISTS/NOT EXISTS запросов.</p></li>
<li><p>В версии 9.0 «асинхронная репликация из коробки», VACUUM/VACUUM FULL стали быстрее, расширены хранимые процедуры.</p></li>
<li><p>В версии 9.1 «синхронная репликация из коробки», нелогируемые таблицы (очень быстрые на запись, но при падении БД данные могут пропасть), новые типы индексов, наследование таблиц в запросах теперь может вернуться многозначительно отсортированные результаты, позволяющие оптимизации MIN/MAX.</p></li>
<li><p>В версии 9.2 «каскадная репликация из коробки», сканирование по индексу, JSON тип данных, типы данных на диапазоны, сортировка в памяти улучшена на 25%, ускорена команда COPY.</p></li>
</ul>
<p>Следует также отметить, что большая часть изложенного в статье материала относится к версии сервера не ниже 8.4.</p>
<h3 id="стоит-ли-доверять-тестам-производительности">Стоит ли доверять тестам производительности</h3>
<p>Перед тем, как заниматься настройкой сервера, вполне естественно ознакомиться с опубликованными данными по производительности, в том числе в сравнении с другими СУБД. К сожалению, многие тесты служат не столько для облегчения вашего выбора, сколько для продвижения конкретных продуктов в качестве «самых быстрых». При изучении опубликованных тестов в первую очередь обратите внимание, соответствует ли величина и тип нагрузки, объём данных и сложность запросов в тесте тому, что вы собираетесь делать с базой? Пусть, например, обычное использование вашего приложения подразумевает несколько одновременно работающих запросов на обновление к таблице в миллионы записей. В этом случае СУБД, которая в несколько раз быстрее всех остальных ищет запись в таблице в тысячу записей, может оказаться не лучшим выбором. Ну и наконец, вещи, которые должны сразу насторожить:</p>
<ul>
<li><p>Тестирование устаревшей версии СУБД.</p></li>
<li><p>Использование настроек по умолчанию (или отсутствие информации о настройках).</p></li>
<li><p>Тестирование в однопользовательском режиме (если, конечно, вы не предполагаете использовать СУБД именно так).</p></li>
<li><p>Использование расширенных возможностей одной СУБД при игнорировании расширенных возможностей другой.</p></li>
<li><p>Использование заведомо медленно работающих запросов (см. пункт 3.4).</p></li>
</ul>
<h2 id="настройка-сервера">Настройка сервера</h2>
<p>В этом разделе описаны рекомендуемые значения параметров, влияющих на производительность СУБД. Эти параметры обычно устанавливаются в конфигурационном файле postgresql.conf и влияют на все базы в текущей установке.</p>
<h3 id="используемая-память">Используемая память</h3>
<h4 id="общий-буфер-сервера-shared_buffers">Общий буфер сервера: shared_buffers</h4>
<p>PostgreSQL не читает данные напрямую с диска и не пишет их сразу на диск. Данные загружаются в общий буфер сервера, находящийся в разделяемой памяти, серверные процессы читают и пишут блоки в этом буфере, а затем уже изменения сбрасываются на диск.</p>
<p>Если процессу нужен доступ к таблице, то он сначала ищет нужные блоки в общем буфере. Если блоки присутствуют, то он может продолжать работу, если нет — делается системный вызов для их загрузки. Загружаться блоки могут как из файлового кэша ОС, так и с диска, и эта операция может оказаться весьма «дорогой».</p>
<p>Если объём буфера недостаточен для хранения часто используемых рабочих данных, то они будут постоянно писаться и читаться из кэша ОС или с диска, что крайне отрицательно скажется на производительности.</p>
<p>В то же время не следует устанавливать это значение слишком большим: это НЕ вся память, которая нужна для работы PostgreSQL, это только размер разделяемой между процессами PostgreSQL памяти, которая нужна для выполнения активных операций. Она должна занимать меньшую часть оперативной памяти вашего компьютера, так как PostgreSQL полагается на то, что операционная система кэширует файлы, и не старается дублировать эту работу. Кроме того, чем больше памяти будет отдано под буфер, тем меньше останется операционной системе и другим приложениям, что может привести к своппингу.</p>
<p>К сожалению, чтобы знать точное число shared_buffers, нужно учесть количество оперативной памяти компьютера, размер базы данных, число соединений и сложность запросов, так что лучше воспользуемся несколькими простыми правилами настройки.</p>
<p>На выделенных серверах полезным объемом будет значение от 8 МБ до 2 ГБ. Объем может быть выше, если у вас большие активные порции базы данных, сложные запросы, большое число одновременных соединений, длительные транзакции, вам доступен большой объем оперативной памяти или большее количество процессоров. И, конечно же, не забываем об остальных приложениях. Выделив слишком много памяти для базы данных, мы можем получить ухудшение производительности. В качестве начальных значений можете попробовать следующие:</p>
<ul>
<li><p>Начните с 4 МБ (512) для рабочей станции</p></li>
<li><p>Средний объём данных и 256–512 МБ доступной памяти: 16–32 МБ (2048–4096)</p></li>
<li><p>Большой объём данных и 1–4 ГБ доступной памяти: 64–256 МБ (8192–32768)</p></li>
</ul>
<p>Для тонкой настройки параметра установите для него большое значение и потестируйте базу при обычной нагрузке. Проверяйте использование разделяемой памяти при помощи ipcs или других утилит(например, free или vmstat). Рекомендуемое значение параметра будет примерно в 1,2 –2 раза больше, чем максимум использованной памяти. Обратите внимание, что память под буфер выделяется при запуске сервера, и её объём при работе не изменяется. Учтите также, что настройки ядра операционной системы могут не дать вам выделить большой объём памяти. В руководстве администратора PostgreSQL описано, как можно изменить эти настройки: <a href="http://www.postgresql.org/docs/devel/static/kernel-resources.html">www.postgresql.org</a></p>
<p>Вот несколько примеров, полученных на личном опыте и при тестировании:</p>
<ul>
<li><p>Laptop, Celeron processor, 384 МБ RAM, база данных 25 МБ: 12 МБ</p></li>
<li><p>Athlon server, 1 ГБ RAM, база данных поддержки принятия решений 10 ГБ: 200 МБ</p></li>
<li><p>Quad PIII server, 4 ГБ RAM, 40 ГБ, 150 соединений, «тяжелые» транзакции: 1 ГБ</p></li>
<li><p>Quad Xeon server, 8 ГБ RAM, 200 ГБ, 300 соединений, «тяжелые» транзакции: 2 ГБ</p></li>
</ul>
<h4 id="память-для-сортировки-результата-запроса-work_mem">Память для сортировки результата запроса: work_mem</h4>
<p>Ранее известное как sort_mem, было переименовано, так как сейчас определяет максимальное количество оперативной памяти, которое может выделить одна операция сортировки, агрегации и др. Это не разделяемая память, work_mem выделяется отдельно на каждую операцию (от одного до нескольких раз за один запрос). Разумное значение параметра определяется следующим образом: количество доступной оперативной памяти (после того, как из общего объема вычли память, требуемую для других приложений, и shared_buffers) делится на максимальное число одновременных запросов умноженное на среднее число операций в запросе, которые требуют памяти.</p>
<p>Если объём памяти недостаточен для сортировки некоторого результата, то серверный процесс будет использовать временные файлы. Если же объём памяти слишком велик, то это может привести к своппингу.</p>
<p>Объём памяти задаётся параметром work_mem в файле postgresql.conf. Единица измерения параметра — 1 кБ. Значение по умолчанию — 1024. В качестве начального значения для параметра можете взять 2–4% доступной памяти. Для веб-приложений обычно устанавливают низкие значения work_mem, так как запросов обычно много, но они простые, обычно хватает от 512 до 2048 КБ. С другой стороны, приложения для поддержки принятия решений с сотнями строк в каждом запросе и десятками миллионов столбцов в таблицах фактов часто требуют work_mem порядка 500 МБ. Для баз данных, которые используются и так, и так, этот параметр можно устанавливать для каждого запроса индивидуально, используя настройки сессии. Например, при памяти 1–4 ГБ рекомендуется устанавливать 32–128 MB.</p>
<h4 id="память-для-работы-команды-vacuum-maintenance_work_mem">Память для работы команды VACUUM: maintenance_work_mem</h4>
<p>Предыдущее название в PostgreSQL 7.x vacuum_mem. Этот параметр задаёт объём памяти, используемый командами VACUUM, ANALYZE, CREATE INDEX, и добавления внешних ключей. Чтобы операции выполнялись максимально быстро, нужно устанавливать этот параметр тем выше, чем больше размер таблиц в вашей базе данных. Неплохо бы устанавливать его значение от 50 до 75% размера вашей самой большой таблицы или индекса или, если точно определить невозможно, от 32 до 256 МБ. Следует устанавливать большее значение, чем для work_mem. Слишком большие значения приведут к использованию свопа. Например, при памяти 1–4 ГБ рекомендуется устанавливать 128–512 MB.</p>
<h4 id="free-space-map-как-избавиться-от-vacuum-full">Free Space Map: как избавиться от VACUUM FULL</h4>
<p>Особенностями версионных движков БД (к которым относится и используемый в PostgreSQL) является следующее:</p>
<ul>
<li><p>Транзакции, изменяющие данные в таблице, не блокируют транзакции, читающие из неё данные, и наоборот (это хорошо);</p></li>
<li><p>При изменении данных в таблице (командами UPDATE или DELETE) накапливается мусор<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> (а это плохо).</p></li>
</ul>
<p>В каждой СУБД сборка мусора реализована особым образом, в PostgreSQL для этой цели применяется команда VACUUM (описана в пункте 3.1.1).</p>
<p>До версии 7.2 команда VACUUM полностью блокировала таблицу. Начиная с версии 7.2, команда VACUUM накладывает более слабую блокировку, позволяющую параллельно выполнять команды SELECT, INSERT, UPDATE и DELETE над обрабатываемой таблицей. Старый вариант команды называется теперь VACUUM FULL.</p>
<p>Новый вариант команды не пытается удалить все старые версии записей и, соответственно, уменьшить размер файла, содержащего таблицу, а лишь помечает занимаемое ими место как свободное. Для информации о свободном месте есть следующие настройки:</p>
<ul>
<li><p><strong>max_fsm_relations</strong></p>
<p>Максимальное количество таблиц, для которых будет отслеживаться свободное место в общей карте свободного пространства. Эти данные собираются VACUUM. Параметр max_fsm_relations должен быть не меньше общего количества таблиц во всех базах данной установки (лучше с запасом).</p></li>
<li><p><strong>max_fsm_pages</strong></p>
<p>Данный параметр определяет размер реестра, в котором хранится информация о частично освобождённых страницах данных, готовых к заполнению новыми данными. Значение этого параметра нужно установить чуть больше, чем полное число страниц, которые могут быть затронуты операциями обновления или удаления между выполнением VACUUM. Чтобы определить это число, можно запустить VACUUM VERBOSE ANALYZE и выяснить общее число страниц, используемых базой данных. max_fsm_pages обычно требует немного памяти, так что на этом параметре лучше не экономить.</p></li>
</ul>
<p>Если эти параметры установлены верно и информация обо всех изменениях помещается в FSM, то команды VACUUM будет достаточно для сборки мусора, если нет – понадобится VACUUM FULL, во время работы которой нормальное использование БД сильно затруднено.</p>
<p><strong>ВНИМАНИЕ!</strong> Начиная с 8.4 версии fsm параметры были убраны, поскольку Free Space Map сохраняется на жесткий диск, а не в память.</p>
<h4 id="прочие-настройки">Прочие настройки</h4>
<ul>
<li><p><strong>temp_buffers</strong></p>
<p>Буфер под временные объекты, в основном для временных таблиц. Можно установить порядка 16 МБ.</p></li>
<li><p><strong>max_prepared_transactions</strong></p>
<p>Количество одновременно подготавливаемых транзакций (PREPARE TRANSACTION). Можно оставить по дефолту — 5.</p></li>
<li><p><strong>vacuum_cost_delay</strong></p>
<p>Если у вас большие таблицы, и производится много одновременных операций записи, вам может пригодиться функция, которая уменьшает затраты на I/O для VACUUM, растягивая его по времени. Чтобы включить эту функциональность, нужно поднять значение vacuum_cost_delay выше 0. Используйте разумную задержку от 50 до 200 мс. Для более тонкой настройки повышайте vacuum_cost_page_hit и понижайте vacuum_cost_page_limit. Это ослабит влияние VACUUM, увеличив время его выполнения. В тестах с параллельными транзакциями Ян Вик (Jan Wieck) получил, что при значениях delay — 200, page_hit — 6 и предел — 100 влияние VACUUM уменьшилось более чем на 80%, но его длительность увеличилась втрое.</p></li>
<li><p><strong>max_stack_depth</strong></p>
<p>Специальный стек для сервера, в идеале он должен совпадать с размером стека, выставленном в ядре ОС. Установка большего значения, чем в ядре, может привести к ошибкам. Рекомендуется устанавливать 2–4 MB.</p></li>
<li><p><strong>max_files_per_process</strong></p>
<p>Максимальное количество файлов, открываемых процессом и его подпроцессами в один момент времени. Уменьшите данный параметр, если в процессе работы наблюдается сообщение «Too many open files».</p></li>
</ul>
<h3 id="журнал-транзакций-и-контрольные-точки">Журнал транзакций и контрольные точки</h3>
<p>Журнал транзакций PostgreSQL работает следующим образом: все изменения в файлах данных (в которых находятся таблицы и индексы) производятся только после того, как они были занесены в журнал транзакций, при этом записи в журнале должны быть гарантированно записаны на диск.</p>
<p>В этом случае нет необходимости сбрасывать на диск изменения данных при каждом успешном завершении транзакции: в случае сбоя БД может быть восстановлена по записям в журнале. Таким образом, данные из буферов сбрасываются на диск при проходе контрольной точки: либо при заполнении нескольких (параметр checkpoint_segments, по умолчанию 3) сегментов журнала транзакций, либо через определённый интервал времени (параметр checkpoint_timeout, измеряется в секундах, по умолчанию 300).</p>
<p>Изменение этих параметров прямо не повлияет на скорость чтения, но может принести большую пользу, если данные в базе активно изменяются.</p>
<h4 id="уменьшение-количества-контрольных-точек-checkpoint_segments">Уменьшение количества контрольных точек: checkpoint_segments</h4>
<p>Если в базу заносятся большие объёмы данных, то контрольные точки могут происходить слишком часто<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>. При этом производительность упадёт из-за постоянного сбрасывания на диск данных из буфера.</p>
<p>Для увеличения интервала между контрольными точками нужно увеличить количество сегментов журнала транзакций (checkpoint_segments). Данный параметр определяет количество сегментов (каждый по 16 МБ) лога транзакций между контрольными точками. Этот параметр не имеет особого значения для базы данных, предназначенной преимущественно для чтения, но для баз данных со множеством транзакций увеличение этого параметра может оказаться жизненно необходимым. В зависимости от объема данных установите этот параметр в диапазоне от 12 до 256 сегментов и, если в логе появляются предупреждения (warning) о том, что контрольные точки происходят слишком часто, постепенно увеличивайте его. Место, требуемое на диске, вычисляется по формуле (checkpoint_segments * 2 + 1) * 16 МБ, так что убедитесь, что у вас достаточно свободного места. Например, если вы выставите значение 32, вам потребуется больше 1 ГБ дискового пространства.</p>
<p>Следует также отметить, что чем больше интервал между контрольными точками, тем дольше будут восстанавливаться данные по журналу транзакций после сбоя.</p>
<h4 id="fsync-и-стоит-ли-его-трогать">fsync и стоит ли его трогать</h4>
<p>Наиболее радикальное из возможных решений — выставить значение «off» параметру fsync. При этом записи в журнале транзакций не будут принудительно сбрасываться на диск, что даст большой прирост скорости записи. Учтите: вы жертвуете надёжностью, в случае сбоя целостность базы будет нарушена, и её придётся восстанавливать из резервной копии!</p>
<p>Использовать этот параметр рекомендуется лишь в том случае, если вы всецело доверяете своему «железу» и своему источнику бесперебойного питания. Ну или если данные в базе не представляют для вас особой ценности.</p>
<h4 id="прочие-настройки-1">Прочие настройки</h4>
<ul>
<li><p><strong>commit_delay</strong> (в микросекундах, 0 по умолчанию) и <strong>commit_siblings</strong> (5 по умолчанию)</p>
<p>определяют задержку между попаданием записи в буфер журнала транзакций и сбросом её на диск. Если при успешном завершении транзакции активно не менее commit_siblings транзакций, то запись будет задержана на время commit_delay. Если за это время завершится другая транзакция, то их изменения будут сброшены на диск вместе, при помощи одного системного вызова. Эти параметры позволят ускорить работу, если параллельно выполняется много «мелких» транзакций.</p></li>
<li><p><strong>wal_sync_method</strong></p>
<p>Метод, который используется для принудительной записи данных на диск. Если fsync=off, то этот параметр не используется. Возможные значения:</p>
<ul>
<li><p>open_datasync — запись данных методом open() с параметром O_DSYNC</p></li>
<li><p>fdatasync — вызов метода fdatasync() после каждого commit</p></li>
<li><p>fsync_writethrough — вызов fsync() после каждого commit, игнорируя параллельные процессы</p></li>
<li><p>fsync — вызов fsync() после каждого commit</p></li>
<li><p>open_sync — запись данных методом open() с параметром O_SYNC</p></li>
</ul>
<p>Не все эти методы доступны на разных ОС. По умолчанию устанавливается первый, который доступен для системы.</p></li>
<li><p><strong>full_page_writes</strong></p>
<p>Установите данный параметр в off, если fsync=off. Иначе, когда этот параметр on, PostgreSQL записывает содержимое каждой записи в журнал транзакций при первой модификации таблицы. Это необходимо, поскольку данные могут записаться лишь частично, если в ходе процесса «упала» ОС. Это приведет к тому, что на диске окажутся новые данные смешанные со старыми. Строкового уровня записи в журнал транзакций может быть недостаточно, чтобы полностью восстановить данные после «падения». full_page_writes гарантирует корректное восстановление, ценой увеличения записываемых данных в журнал транзакций (Единственный способ снижения объема записи в журнал транзакций заключается в увеличении checkpoint_interval).</p></li>
<li><p><strong>wal_buffers</strong></p>
<p>Количество памяти используемое в SHARED MEMORY для ведения транзакционных логов<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>. Стоит увеличить буфер до 256–512 кБ, что позволит лучше работать с большими транзакциями. Например, при доступной памяти 1–4 ГБ рекомендуется устанавливать 256–1024 КБ.</p></li>
</ul>
<h3 id="планировщик-запросов">Планировщик запросов</h3>
<p>Следующие настройки помогают планировщику запросов правильно оценивать стоимости различных операций и выбирать оптимальный план выполнения запроса. Существуют 3 настройки планировщика, на которые стоит обратить внимание:</p>
<ul>
<li><p><strong>default_statistics_target</strong></p>
<p>Этот параметр задаёт объём статистики, собираемой командой ANALYZE (см. пункт 3.1.2). Увеличение параметра заставит эту команду работать дольше, но может позволить оптимизатору строить более быстрые планы, используя полученные дополнительные данные. Объём статистики для конкретного поля может быть задан командой ALTER TABLE …SET STATISTICS.</p></li>
<li><p><strong>effective_cache_size</strong></p>
<p>Этот параметр сообщает PostgreSQL примерный объём файлового кэша операционной системы, оптимизатор использует эту оценку для построения плана запроса<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>.</p>
<p>Пусть в вашем компьютере 1,5 ГБ памяти, параметр shared_buffers установлен в 32 МБ, а параметр effective_cache_size в 800 МБ. Если запросу нужно 700 МБ данных, то PostgreSQL оценит, что все нужные данные уже есть в памяти и выберет более агрессивный план с использованием индексов и merge joins. Но если effective_cache_size будет всего 200 МБ, то оптимизатор вполне может выбрать более эффективный для дисковой системы план, включающий полный просмотр таблицы.</p>
<p>На выделенном сервере имеет смысл выставлять effective_cache_size в 2/3 от всей оперативной памяти; на сервере с другими приложениями сначала нужно вычесть из всего объема RAM размер дискового кэша ОС и память, занятую остальными процессами.</p></li>
<li><p><strong>random_page_cost</strong></p>
<p>Переменная, указывающая на условную стоимость индексного доступа к страницам данных. На серверах с быстрыми дисковыми массивами имеет смысл уменьшать изначальную настройку до 3.0, 2.5 или даже до 2.0. Если же активная часть вашей базы данных намного больше размеров оперативной памяти, попробуйте поднять значение параметра. Можно подойти к выбору оптимального значения и со стороны производительности запросов. Если планировщик запросов чаще, чем необходимо, предпочитает последовательные просмотры (sequential scans) просмотрам с использованием индекса (index scans), понижайте значение. И наоборот, если планировщик выбирает просмотр по медленному индексу, когда не должен этого делать, настройку имеет смысл увеличить. После изменения тщательно тестируйте результаты на максимально широком наборе запросов. Никогда не опускайте значение random_page_cost ниже 2.0; если вам кажется, что random_page_cost нужно еще понижать, разумнее в этом случае менять настройки статистики планировщика.</p></li>
</ul>
<h3 id="сбор-статистики">Сбор статистики</h3>
<p>У PostgreSQL также есть специальная подсистема — сборщик статистики, — которая в реальном времени собирает данные об активности сервера. Поскольку сбор статистики создает дополнительные накладные расходы на базу данных, то система может быть настроена как на сбор, так и не сбор статистики вообще. Эта система контролируется следующими параметрами, принимающими значения true/false:</p>
<ul>
<li><p><strong>track_counts</strong> включать ли сбор статистики. По умолчанию включён, поскольку autovacuum демону требуется сбор статистики. Отключайте, только если статистика вас совершенно не интересует (как и autovacuum).</p></li>
<li><p><strong>track_functions</strong> отслеживание использования определенных пользователем функций.</p></li>
<li><p><strong>track_activities</strong> передавать ли сборщику статистики информацию о текущей выполняемой команде и времени начала её выполнения. По умолчанию эта возможность включена. Следует отметить, что эта информация будет доступна только привилегированным пользователям и пользователям, от лица которых запущены команды, так что проблем с безопасностью быть не должно.</p></li>
</ul>
<p>Данные, полученные сборщиком статистики, доступны через специальные системные представления. При установках по умолчанию собирается очень мало информации, рекомендуется включить все возможности: дополнительная нагрузка будет невелика, в то время как полученные данные позволят оптимизировать использование индексов (а также помогут оптимальной работе autovacuum демону).</p>
<h2 id="диски-и-файловые-системы">Диски и файловые системы</h2>
<p>Очевидно, что от качественной дисковой подсистемы в сервере БД зависит немалая часть производительности. Вопросы выбора и тонкой настройки «железа», впрочем, не являются темой данной главы, ограничимся уровнем файловой системы.</p>
<p>Единого мнения насчёт наиболее подходящей для PostgreSQL файловой системы нет, поэтому рекомендуется использовать ту, которая лучше всего поддерживается вашей операционной системой. При этом учтите, что современные журналирующие файловые системы не намного медленнее нежурналирующих, а выигрыш — быстрое восстановление после сбоев — от их использования велик.</p>
<p>Вы легко можете получить выигрыш в производительности без побочных эффектов, если примонтируете файловую систему, содержащую базу данных, с параметром noatime<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>.</p>
<h3 id="перенос-журнала-транзакций-на-отдельный-диск">Перенос журнала транзакций на отдельный диск</h3>
<p>При доступе к диску изрядное время занимает не только собственно чтение данных, но и перемещение магнитной головки.</p>
<p>Если в вашем сервере есть несколько физических дисков (несколько логических разделов на одном диске здесь, очевидно, не помогут: головка всё равно будет одна), то вы можете разнести файлы базы данных и журнал транзакций по разным дискам. Данные в сегменты журнала пишутся последовательно, более того, записи в журнале транзакций сразу сбрасываются на диск, поэтому в случае нахождения его на отдельном диске магнитная головка не будет лишний раз двигаться, что позволит ускорить запись.</p>
<p>Порядок действий:</p>
<ul>
<li><p>Остановите сервер (!).</p></li>
<li><p>Перенесите каталоги pg_clog и pg_xlog, находящийся в каталоге с базами данных, на другой диск.</p></li>
<li><p>Создайте на старом месте символическую ссылку.</p></li>
<li><p>Запустите сервер.</p></li>
</ul>
<p>Примерно таким же образом можно перенести и часть файлов, содержащих таблицы и индексы, на другой диск, но здесь потребуется больше кропотливой ручной работы, а при внесении изменений в схему базы процедуру, возможно, придётся повторить.</p>
<h3 id="cluster">CLUSTER</h3>
<p>CLUSTER table [ USING index ] — команда для упорядочивания записей таблицы на диске согласно индексу, что иногда за счет уменьшения доступа к диску ускоряет выполнение запроса. Возможно создать только один физический порядок в таблице, поэтому и таблица может иметь только один кластерный индекс. При таком условии нужно тщательно выбирать, какой индекс будет использоваться для кластерного индекса.</p>
<p>Кластеризация по индексу позволяет сократить время поиска по диску: во время поиска по индексу выборка данных может быть значительно быстрее, так как последовательность данных в таком же порядке, как и индекс. Из минусов можно отметить то, что команда CLUSTER требует «ACCESS EXCLUSIVE» блокировку, что предотвращает любые другие операции с данными (чтения и записи) пока кластеризация не завершит выполнение. Также кластеризация индекса в PostgreSQL не утверждает четкий порядок следования, поэтому требуется повторно выполнять CLUSTER для поддержания таблицы в порядке.</p>
<h2 id="примеры-настроек">Примеры настроек</h2>
<h3 id="среднестатистическая-настройка-для-максимальной-производительности">Среднестатистическая настройка для максимальной производительности</h3>
<p>Возможно для конкретного случая лучше подойдут другие настройки. Внимательно изучите данное руководство и настройте PostgreSQL опираясь на эту информацию.</p>
<p>RAM — размер памяти;</p>
<ul>
<li><p>shared_buffers = 1/8 RAM или больше (но не более 1/4);</p></li>
<li><p>work_mem в 1/20 RAM;</p></li>
<li><p>maintenance_work_mem в 1/4 RAM;</p></li>
<li><p>max_fsm_relations в планируемое кол–во таблиц в базах * 1.5;</p></li>
<li><p>max_fsm_pages в max_fsm_relations * 2000;</p></li>
<li><p>fsync = true;</p></li>
<li><p>wal_sync_method = fdatasync;</p></li>
<li><p>commit_delay = от 10 до 100 ;</p></li>
<li><p>commit_siblings = от 5 до 10;</p></li>
<li><p>effective_cache_size = 0.9 от значения cached, которое показывает free;</p></li>
<li><p>random_page_cost = 2 для быстрых cpu, 4 для медленных;</p></li>
<li><p>cpu_tuple_cost = 0.001 для быстрых cpu, 0.01 для медленных;</p></li>
<li><p>cpu_index_tuple_cost = 0.0005 для быстрых cpu, 0.005 для медленных;</p></li>
<li><p>autovacuum = on;</p></li>
<li><p>autovacuum_vacuum_threshold = 1800;</p></li>
<li><p>autovacuum_analyze_threshold = 900;</p></li>
</ul>
<h3 id="среднестатистическая-настройка-для-оконного-приложения-1с-2-гб-памяти">Среднестатистическая настройка для оконного приложения (1С), 2 ГБ памяти</h3>
<ul>
<li><p>maintenance_work_mem = 128MB</p></li>
<li><p>effective_cache_size = 512MB</p></li>
<li><p>work_mem = 640kB</p></li>
<li><p>wal_buffers = 1536kB</p></li>
<li><p>shared_buffers = 128MB</p></li>
<li><p>max_connections = 500</p></li>
</ul>
<h3 id="среднестатистическая-настройка-для-web-приложения-2-гб-памяти">Среднестатистическая настройка для Web приложения, 2 ГБ памяти</h3>
<ul>
<li><p>maintenance_work_mem = 128MB;</p></li>
<li><p>checkpoint_completion_target = 0.7</p></li>
<li><p>effective_cache_size = 1536MB</p></li>
<li><p>work_mem = 4MB</p></li>
<li><p>wal_buffers = 4MB</p></li>
<li><p>checkpoint_segments = 8</p></li>
<li><p>shared_buffers = 512MB</p></li>
<li><p>max_connections = 500</p></li>
</ul>
<h3 id="среднестатистическая-настройка-для-web-приложения-8-гб-памяти">Среднестатистическая настройка для Web приложения, 8 ГБ памяти</h3>
<ul>
<li><p>maintenance_work_mem = 512MB</p></li>
<li><p>checkpoint_completion_target = 0.7</p></li>
<li><p>effective_cache_size = 6GB</p></li>
<li><p>work_mem = 16MB</p></li>
<li><p>wal_buffers = 4MB</p></li>
<li><p>checkpoint_segments = 8</p></li>
<li><p>shared_buffers = 2GB</p></li>
<li><p>max_connections = 500</p></li>
</ul>
<h2 id="автоматическое-создание-оптимальных-настроек-pgtune">Автоматическое создание оптимальных настроек: pgtune</h2>
<p>Для оптимизации настроек для PostgreSQL Gregory Smith создал утилиту pgtune<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a> в расчёте на обеспечение максимальной производительности для заданной аппаратной конфигурации. Утилита проста в использовании и во многих Linux системах может идти в составе пакетов. Если же нет, можно просто скачать архив и распаковать. Для начала:</p>
<pre><code>pgtune -i $PGDATA/postgresql.conf \
-o $PGDATA/postgresql.conf.pgtune</code></pre>
<p>опцией <code>-i, --input-config</code> указываем текущий файл postgresql.conf, а <code>-o, --output-config</code> указываем имя файла для нового postgresql.conf.</p>
<p>Есть также дополнительные опции для настройки конфига.</p>
<ul>
<li><p><code>-M, --memory</code> Используйте этот параметр, чтобы определить общий объем системной памяти. Если не указано, pgtune будет пытаться использовать текущий объем системной памяти.</p></li>
<li><p><code>-T, --type</code> Указывает тип базы данных. Опции: DW, OLTP, Web, Mixed, Desktop.</p></li>
<li><p><code>-c, --connections</code> Указывает максимальное количество соединений. Если он не указан, то будет браться в зависимости от типа базы данных.</p></li>
</ul>
<p>Хочется сразу добавить, что pgtune не панацея для оптимизации настройки PostgreSQL. Многие настройки зависят не только от аппаратной конфигурации, но и от размера базы данных, числа соединений и сложности запросов, так что оптимально настроить базу данных возможно только учитывая все эти параметры.</p>
<h2 id="оптимизация-бд-и-приложения">Оптимизация БД и приложения</h2>
<p>Для быстрой работы каждого запроса в вашей базе в основном требуется следующее:</p>
<ol>
<li><p>Отсутствие в базе мусора, мешающего добраться до актуальных данных. Можно сформулировать две подзадачи:</p>
<ol>
<li><p>Грамотное проектирование базы. Освещение этого вопроса выходит далеко за рамки этой книги.</p></li>
<li><p>Сборка мусора, возникающего при работе СУБД.</p></li>
</ol></li>
<li><p>Наличие быстрых путей доступа к данным — индексов.</p></li>
<li><p>Возможность использования оптимизатором этих быстрых путей.</p></li>
<li><p>Обход известных проблем.</p></li>
</ol>
<h3 id="поддержание-базы-в-порядке">Поддержание базы в порядке</h3>
<p>В данном разделе описаны действия, которые должны периодически выполняться для каждой базы. От разработчика требуется только настроить их автоматическое выполнение (при помощи cron) и опытным путём подобрать оптимальную частоту.</p>
<h4 id="команда-analyze">Команда ANALYZE</h4>
<p>Служит для обновления информации о распределении данных в таблице. Эта информация используется оптимизатором для выбора наиболее быстрого плана выполнения запроса.</p>
<p>Обычно команда используется в связке с VACUUM ANALYZE. Если в базе есть таблицы, данные в которых не изменяются и не удаляются, а лишь добавляются, то для таких таблиц можно использовать отдельную команду ANALYZE. Также стоит использовать эту команду для отдельной таблицы после добавления в неё большого количества записей.</p>
<h4 id="команда-reindex">Команда REINDEX</h4>
<p>Команда REINDEX используется для перестройки существующих индексов. Использовать её имеет смысл в случае:</p>
<ul>
<li><p>порчи индекса;</p></li>
<li><p>постоянного увеличения его размера.</p></li>
</ul>
<p>Второй случай требует пояснений. Индекс, как и таблица, содержит блоки со старыми версиями записей. PostgreSQL не всегда может заново использовать эти блоки, и поэтому файл с индексом постепенно увеличивается в размерах. Если данные в таблице часто меняются, то расти он может весьма быстро.</p>
<p>Если вы заметили подобное поведение какого-то индекса, то стоит настроить для него периодическое выполнение команды REINDEX. Учтите: команда REINDEX, как и VACUUM FULL, полностью блокирует таблицу, поэтому выполнять её надо тогда, когда загрузка сервера минимальна.</p>
<h3 id="использование-индексов">Использование индексов</h3>
<p>Опыт показывает, что наиболее значительные проблемы с производительностью вызываются отсутствием нужных индексов. Поэтому столкнувшись с медленным запросом, в первую очередь проверьте, существуют ли индексы, которые он может использовать. Если нет — постройте их. Излишек индексов, впрочем, тоже чреват проблемами:</p>
<ul>
<li><p>Команды, изменяющие данные в таблице, должны изменить также и индексы. Очевидно, чем больше индексов построено для таблицы, тем медленнее это будет происходить.</p></li>
<li><p>Оптимизатор перебирает возможные пути выполнения запросов. Если построено много ненужных индексов, то этот перебор будет идти дольше.</p></li>
</ul>
<p>Единственное, что можно сказать с большой степенью определённости — поля, являющиеся внешними ключами, и поля, по которым объединяются таблицы, индексировать надо обязательно.</p>
<h4 id="команда-explain-analyze">Команда EXPLAIN [ANALYZE]</h4>
<p>Команда EXPLAIN [запрос] показывает, каким образом PostgreSQL собирается выполнять ваш запрос. Команда EXPLAIN ANALYZE [запрос] выполняет запрос<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a> и показывает как изначальный план, так и реальный процесс его выполнения.</p>
<p>Чтение вывода этих команд — искусство, которое приходит с опытом. Для начала обращайте внимание на следующее:</p>
<ul>
<li><p>Использование полного просмотра таблицы (seq scan).</p></li>
<li><p>Использование наиболее примитивного способа объединения таблиц (nested loop).</p></li>
<li><p>Для EXPLAIN ANALYZE: нет ли больших отличий в предполагаемом количестве записей и реально выбранном? Если оптимизатор использует устаревшую статистику, то он может выбирать не самый быстрый план выполнения запроса.</p></li>
</ul>
<p>Следует отметить, что полный просмотр таблицы далеко не всегда медленнее просмотра по индексу. Если, например, в таблице–справочнике несколько сотен записей, умещающихся в одном-двух блоках на диске, то использование индекса приведёт лишь к тому, что придётся читать ещё и пару лишних блоков индекса. Если в запросе придётся выбрать 80% записей из большой таблицы, то полный просмотр опять же получится быстрее.</p>
<p>При тестировании запросов с использованием EXPLAIN ANALYZE можно воспользоваться настройками, запрещающими оптимизатору использовать определённые планы выполнения. Например,</p>
<pre><code>SET enable_seqscan=false;</code></pre>
<p>запретит использование полного просмотра таблицы, и вы сможете выяснить, прав ли был оптимизатор, отказываясь от использования индекса. Ни в коем случае не следует прописывать подобные команды в postgresql.conf! Это может ускорить выполнение нескольких запросов, но сильно замедлит все остальные!</p>
<h4 id="использование-собранной-статистики">Использование собранной статистики</h4>
<p>Результаты работы сборщика статистики доступны через специальные системные представления. Наиболее интересны для наших целей следующие:</p>
<ul>
<li><p><strong>pg_stat_user_tables</strong> содержит — для каждой пользовательской таблицы в текущей базе данных — общее количество полных просмотров и просмотров с использованием индексов, общие количества записей, которые были возвращены в результате обоих типов просмотра, а также общие количества вставленных, изменённых и удалённых записей.</p></li>
<li><p><strong>pg_stat_user_indexes</strong> содержит — для каждого пользовательского индекса в текущей базе данных — общее количество просмотров, использовавших этот индекс, количество прочитанных записей, количество успешно прочитанных записей в таблице (может быть меньше предыдущего значения, если в индексе есть записи, указывающие на устаревшие записи в таблице).</p></li>
<li><p><strong>pg_statio_user_tables</strong> содержит — для каждой пользовательской таблицы в текущей базе данных — общее количество блоков, прочитанных из таблицы, количество блоков, оказавшихся при этом в буфере (см. пункт 2.1.1), а также аналогичную статистику для всех индексов по таблице и, возможно, по связанной с ней таблицей TOAST.</p></li>
</ul>
<p>Из этих представлений можно узнать, в частности:</p>
<ul>
<li><p>Для каких таблиц стоит создать новые индексы (индикатором служит большое количество полных просмотров и большое количество прочитанных блоков).</p></li>
<li><p>Какие индексы вообще не используются в запросах. Их имеет смысл удалить, если, конечно, речь не идёт об индексах, обеспечивающих выполнение ограничений PRIMARY KEY и UNIQUE.</p></li>
<li><p>Достаточен ли объём буфера сервера.</p></li>
</ul>
<p>Также возможен «дедуктивный» подход, при котором сначала создаётся большое количество индексов, а затем неиспользуемые индексы удаляются.</p>
<h4 id="возможности-индексов-в-postgresql">Возможности индексов в PostgreSQL</h4>
<p><strong>Функциональные индексы</strong> Вы можете построить индекс не только по полю/нескольким полям таблицы, но и по выражению, зависящему от полей. Пусть, например, в вашей таблице foo есть поле foo_name, и выборки часто делаются по условию «первая буква foo_name = ’буква’, в любом регистре». Вы можете создать индекс</p>
<pre><code>CREATE INDEX foo_name_first_idx 
ON foo ((lower(substr(foo_name, 1, 1))));</code></pre>
<p>и запрос вида</p>
<pre><code>SELECT * FROM foo 
WHERE lower(substr(foo_name, 1, 1)) = &#39;ы&#39;;</code></pre>
<p>будет его использовать.</p>
<p><strong>Частичные индексы (partial indexes)</strong> Под частичным индексом понимается индекс с предикатом WHERE. Пусть, например, у вас есть в базе таблица scheta с параметром uplocheno типа boolean. Записей, где uplocheno = false меньше, чем записей с uplocheno = true, а запросы по ним выполняются значительно чаще. Вы можете создать индекс</p>
<pre><code>CREATE INDEX scheta_neuplocheno ON scheta (id)
WHERE NOT uplocheno;</code></pre>
<p>который будет использоваться запросом вида</p>
<pre><code>SELECT * FROM scheta WHERE NOT uplocheno AND ...;</code></pre>
<p>Достоинство подхода в том, что записи, не удовлетворяющие условию WHERE, просто не попадут в индекс.</p>
<h3 id="перенос-логики-на-сторону-сервера">Перенос логики на сторону сервера</h3>
<p>Этот пункт очевиден для опытных пользователей PostrgeSQL и предназначен для тех, кто использует или переносит на PostgreSQL приложения, написанные изначально для более примитивных СУБД.</p>
<p>Реализация части логики на стороне сервера через хранимые процедуры, триггеры, правила<a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a> часто позволяет ускорить работу приложения. Действительно, если несколько запросов объединены в процедуру, то не требуется</p>
<ul>
<li><p>пересылка промежуточных запросов на сервер;</p></li>
<li><p>получение промежуточных результатов на клиент и их обработка.</p></li>
</ul>
<p>Кроме того, хранимые процедуры упрощают процесс разработки и поддержки: изменения надо вносить только на стороне сервера, а не менять запросы во всех приложениях.</p>
<h3 id="оптимизация-конкретных-запросов">Оптимизация конкретных запросов</h3>
<p>В этом разделе описываются запросы, для которых по разным причинам нельзя заставить оптимизатор использовать индексы, и которые будут всегда вызывать полный просмотр таблицы. Таким образом, если вам требуется использовать эти запросы в требовательном к быстродействию приложении, то придётся их изменить.</p>
<h4 id="select-count-from-огромная-таблица">SELECT count(*) FROM &lt;огромная таблица&gt;</h4>
<p>Функция count() работает очень просто: сначала выбираются все записи, удовлетворяющие условию, а потом к полученному набору записей применяется агрегатная функция — считается количество выбранных строк. Информация о видимости записи для текущей транзакции (а конкурентным транзакциям может быть видимо разное количество записей в таблице!) не хранится в индексе, поэтому, даже если использовать для выполнения запроса индекс первичного ключа таблицы, всё равно потребуется чтение записей собственно из файла таблицы.</p>
<p><strong>Проблема</strong> Запрос вида</p>
<pre><code>SELECT count(*) FROM foo;</code></pre>
<p>осуществляет полный просмотр таблицы foo, что весьма долго для таблиц с большим количеством записей.</p>
<p><strong>Решение</strong> Простого решения проблемы, к сожалению, нет. Возможны следующие подходы:</p>
<ol>
<li><p>Если точное число записей не важно, а важен порядок<a href="#fn9" class="footnoteRef" id="fnref9"><sup>9</sup></a>, то можно использовать информацию о количестве записей в таблице, собранную при выполнении команды ANALYZE:</p>
<pre><code>SELECT reltuples FROM pg_class WHERE relname = &#39;foo&#39;;</code></pre></li>
<li><p>Если подобные выборки выполняются часто, а изменения в таблице достаточно редки, то можно завести вспомогательную таблицу, хранящую число записей в основной. На основную же таблицу повесить триггер, который будет уменьшать это число в случае удаления записи и увеличивать в случае вставки. Таким образом, для получения количества записей потребуется лишь выбрать одну запись из вспомогательной таблицы.</p></li>
<li><p>Вариант предыдущего подхода, но данные во вспомогательной таблице обновляются через определённые промежутки времени (cron).</p></li>
</ol>
<h4 id="медленный-distinct">Медленный DISTINCT</h4>
<p>Текущая реализация DISTINCT для больших таблиц очень медленна. Но возможно использовать GROUP BY взамен DISTINCT. GROUP BY может использовать агрегирующий хэш, что значительно быстрее, чем DISTINCT (актуально до версии 8.4 и ниже).</p>
<pre><code>postgres=# select count(*) from (select distinct i from g) a;
 count 
-------
 19125
(1 row)

Time: 580,553 ms


postgres=# select count(*) from (select distinct i from g) a;
 count 
-------
 19125
(1 row)

Time: 36,281 ms</code></pre>
<pre><code>postgres=# select count(*) from (select i from g group by i) a;
 count 
-------
 19125
(1 row)

Time: 26,562 ms


postgres=# select count(*) from (select i from g group by i) a;
 count 
-------
 19125
(1 row)

Time: 25,270 ms</code></pre>
<h3 id="утилиты-для-оптимизации-запросов">Утилиты для оптимизации запросов</h3>
<h4 id="pgfouine">pgFouine</h4>
<p>pgFouine<a href="#fn10" class="footnoteRef" id="fnref10"><sup>10</sup></a> — это анализатор log-файлов для PostgreSQL, используемый для генерации детальных отчетов из log-файлов PostgreSQL. pgFouine поможет определить, какие запросы следует оптимизировать в первую очередь. pgFouine написан на языке программирования PHP с использованием объектно-ориентированных технологий и легко расширяется для поддержки специализированных отчетов, является свободным программным обеспечением и распространяется на условиях GNU General Public License. Утилита спроектирована таким образом, чтобы обработка очень больших log-файлов не требовала много ресурсов.</p>
<p>Для работы с pgFouine сначала нужно сконфигурировать PostgreSQL для создания нужного формата log-файлов:</p>
<ul>
<li><p>Чтобы включить протоколирование в syslog</p>
<pre><code>log_destination = &#39;syslog&#39;
redirect_stderr = off
silent_mode = on</code></pre></li>
<li><p>Для записи запросов, длящихся дольше n миллисекунд:</p>
<pre><code>log_min_duration_statement = n
log_duration = off
log_statement = &#39;none&#39;</code></pre></li>
</ul>
<p>Для записи каждого обработанного запроса установите log_min_duration_statement на 0. Чтобы отключить запись запросов, установите этот параметр на -1.</p>
<p>pgFouine — простой в использовании инструмент командной строки. Следующая команда создаёт HTML-отчёт со стандартными параметрами:</p>
<pre><code>pgfouine.php -file your/log/file.log &gt; your-report.html</code></pre>
<p>С помощью этой строки можно отобразить текстовый отчёт с 10 запросами на каждый экран на стандартном выводе:</p>
<pre><code>pgfouine.php -file your/log/file.log -top 10 -format text</code></pre>
<p>Более подробно о возможностях, а также много полезных примеров, можно найти на официальном сайта проекта <a href="http://pgfouine.projects.pgfoundry.org/">pgfouine.projects.pgfoundry.org</a>.</p>
<h4 id="pgbadger">pgBadger</h4>
<p>pgBadger<a href="#fn11" class="footnoteRef" id="fnref11"><sup>11</sup></a> — аналогичная утилита, что и pgFouine, но написанная на Perl. Еще одно большое преимущество проекта в том, что он более активно сейчас разрабатывается (на момент написания этого текста последний релиз pgFouine был в 24.02.2010, а последняя версия pgBadger — 12.10.2012). Установка pgBadger проста:</p>
<pre><code>tar xzf pgbadger-2.x.tar.gz
cd pgbadger-2.x/
perl Makefile.PL
make &amp;&amp; sudo make install</code></pre>
<p>Как и в случае с pgFouine нужно настроить PostgreSQL логи:</p>
<pre><code>logging_collector = on
log_min_messages = debug1
log_min_error_statement = debug1
log_min_duration_statement = 0
log_line_prefix = &#39;%t [%p]: [%l-1] user=%u,db=%d &#39;
log_checkpoints = on
log_connections = on
log_disconnections = on
log_lock_waits = on
log_temp_files = 0</code></pre>
<p>Парсим логи PostgreSQL через pgBadger:</p>
<pre><code>$ ./pgbadger ~/pgsql/master/pg_log/postgresql-2012-08-30_132*
[========================&gt;] Parsed 10485768 bytes of 10485768 (100.00%)
[========================&gt;] Parsed 10485828 bytes of 10485828 (100.00%)
[========================&gt;] Parsed 10485851 bytes of 10485851 (100.00%)
[========================&gt;] Parsed 10485848 bytes of 10485848 (100.00%)
[========================&gt;] Parsed 10485839 bytes of 10485839 (100.00%)
[========================&gt;] Parsed 982536 bytes of 982536 (100.00%)</code></pre>
<p>В результате получится HTML файлы, которые содержат статистику по запросам к PostgreSQL. Более подробно о возможностях можно найти на официальном сайта проекта <a href="http://dalibo.github.com/pgbadger/">dalibo.github.com/pgbadger</a>.</p>
<h4 id="pg_stat_statements">pg_stat_statements</h4>
<p>pg_stat_statements — расширение для сбора статистики выполнения запросов в рамках всего сервера. Преимущество данного расширения в том, что ему не требуется собирать и парсить логи PostgreSQL, как это делает pgFouine и pgBadger. Для начала установим и настроим его:</p>
<pre><code>shared_preload_libraries = &#39;pg_stat_statements&#39;
custom_variable_classes = &#39;pg_stat_statements&#39; # данная настройка нужна для PostgreSQL 9.1 и ниже

pg_stat_statements.max = 10000
pg_stat_statements.track = all</code></pre>
<p>После внесения этих параметров PostgreSQL потребуется перегрузить. Параметры конфигурации pg_stat_statements:</p>
<ol>
<li><p>«pg_stat_statements.max (integer)» — максимальное количество sql запросов, которые будет хранится расширением (удаляются записи с наименьшим количеством вызовов)</p></li>
<li><p>«pg_stat_statements.track (enum)» — какие SQL запросы требуется записывать. Возможные параметры: top (только запросы от приложения/клиента), all (все запросы, например в функциях) и none (отключить сбор статистики).</p></li>
<li><p>«pg_stat_statements.save (boolean)» — следует ли сохранять собранную статистику после остановки PostgreSQL. По умолчанию включено.</p></li>
</ol>
<p>Далее активируем расширение:</p>
<pre><code># CREATE EXTENSION pg_stat_statements;</code></pre>
<p>Пример собранной статистики:</p>
<pre><code># SELECT query, calls, total_time, rows, 100.0 * shared_blks_hit /
               nullif(shared_blks_hit + shared_blks_read, 0) AS hit_percent
          FROM pg_stat_statements ORDER BY total_time DESC LIMIT 10;
-[ RECORD 1 ]----------------------------------------------------------------------------
query       | SELECT query, calls, total_time, rows, ? * shared_blks_hit /
            |                nullif(shared_blks_hit + shared_blks_read, ?) AS hit_percent
            |           FROM pg_stat_statements ORDER BY total_time DESC LIMIT ?;
calls       | 3
total_time  | 0.994
rows        | 7
hit_percent | 100.0000000000000000
-[ RECORD 2 ]----------------------------------------------------------------------------
query       | insert into x (i) select generate_series(?,?);
calls       | 2
total_time  | 0.591
rows        | 110
hit_percent | 100.0000000000000000
-[ RECORD 3 ]----------------------------------------------------------------------------
query       | select * from x where i = ?;
calls       | 2
total_time  | 0.157
rows        | 6
hit_percent | 100.0000000000000000
-[ RECORD 4 ]----------------------------------------------------------------------------
query       | SELECT pg_stat_statements_reset();
calls       | 1
total_time  | 0.102
rows        | 1
hit_percent | </code></pre>
<p>Для сброса статистики есть команда pg_stat_statements_reset:</p>
<pre><code># SELECT pg_stat_statements_reset();
-[ RECORD 1 ]------------+-
pg_stat_statements_reset | 

# SELECT query, calls, total_time, rows, 100.0 * shared_blks_hit /
               nullif(shared_blks_hit + shared_blks_read, 0) AS hit_percent
          FROM pg_stat_statements ORDER BY total_time DESC LIMIT 10;
-[ RECORD 1 ]-----------------------------------
query       | SELECT pg_stat_statements_reset();
calls       | 1
total_time  | 0.175
rows        | 1
hit_percent | </code></pre>
<p>Хочется сразу отметить, что расширение только с версии PostgreSQL 9.2 contrib нормализирует SQL запросы. В версиях 9.1 и ниже SQL запросы сохраняются как есть, а значит «select * from table where id = 3» и «select * from table where id = 21» буду разными записями, что почти бесполезно для сбора полезной статистики.</p>
<h2 id="заключение">Заключение</h2>
<p>К счастью, PostgreSQL не требует особо сложной настройки. В большинстве случаев вполне достаточно будет увеличить объём выделенной памяти, настроить периодическое поддержание базы в порядке и проверить наличие необходимых индексов. Более сложные вопросы можно обсудить в специализированном списке рассылки.</p>
<h1 id="партиционирование">Партиционирование</h1>
<h2 id="введение-2">Введение</h2>
<p>Партиционирование (partitioning, секционирование) — это разбиение больших структур баз данных (таблицы, индексы) на меньшие кусочки. Звучит сложно, но на практике все просто.</p>
<p>Скорее всего у Вас есть несколько огромных таблиц (обычно всю нагрузку обеспечивают всего несколько таблиц СУБД из всех имеющихся). Причем чтение в большинстве случаев приходится только на самую последнюю их часть (т.е. активно читаются те данные, которые недавно появились). Примером тому может служить блог — на первую страницу (это последние 5…10 постов) приходится 40…50% всей нагрузки, или новостной портал (суть одна и та же), или системы личных сообщений, впрочем понятно. Партиционирование таблицы позволяет базе данных делать интеллектуальную выборку — сначала СУБД уточнит, какой партиции соответствует Ваш запрос (если это реально) и только потом сделает этот запрос, применительно к нужной партиции (или нескольким партициям). Таким образом, в рассмотренном случае, Вы распределите нагрузку на таблицу по ее партициям. Следовательно выборка типа «SELECT * FROM articles ORDER BY id DESC LIMIT 10» будет выполняться только над последней партицией, которая значительно меньше всей таблицы.</p>
<p>Итак, партиционирование дает ряд преимуществ:</p>
<ul>
<li><p>На определенные виды запросов (которые, в свою очередь, создают основную нагрузку на СУБД) мы можем улучшить производительность.</p></li>
<li><p>Массовое удаление может быть произведено путем удаления одной или нескольких партиций (DROP TABLE гораздо быстрее, чем массовый DELETE).</p></li>
<li><p>Редко используемые данные могут быть перенесены в другое хранилище.</p></li>
</ul>
<h2 id="теория">Теория</h2>
<p>На текущий момент PostgreSQL поддерживает два критерия для создания партиций:</p>
<ul>
<li><p>Партиционирование по диапазону значений (range) — таблица разбивается на «диапазоны» значений по полю или набору полей в таблице, без перекрытия диапазонов значений, отнесенных к различным партициям. Например, диапазоны дат.</p></li>
<li><p>Партиционирование по списку значений (list) — таблица разбивается по спискам ключевых значений для каждой партиции.</p></li>
</ul>
<p>Чтобы настроить партиционирование таблицы, достаточно выполните следующие действия:</p>
<ul>
<li><p>Создается «мастер» таблица, из которой все партиции будут наследоваться. Эта таблица не будет содержать данные. Также не нужно ставить никаких ограничений на таблицу, если конечно они не будут дублироваться на партиции.</p></li>
<li><p>Создайте несколько «дочерних» таблиц, которые наследуют от «мастер» таблицы.</p></li>
<li><p>Добавить в «дочерние» таблицы значения, по которым они будут партициями. Стоить заметить, что значения партиций не должны пересекаться. Например:</p>
<pre><code>CHECK ( outletID BETWEEN 100 AND 200 )
CHECK ( outletID BETWEEN 200 AND 300 )</code></pre>
<p>неверно заданы партиции, поскольку непонятно какой партиции принадлежит значение 200.</p></li>
<li><p>Для каждой партиции создать индекс по ключевому полю (или нескольким), а также указать любые другие требуемые индексы.</p></li>
<li><p>При необходимости, создать триггер или правило для перенаправления данных с «мастер» таблицы в соответствующую партицию.</p></li>
<li><p>Убедиться, что параметр «constraint_exclusion» не отключен в postgresql.conf. Если его не включить, то запросы не будут оптимизированы при работе с партиционированием.</p></li>
</ul>
<h2 id="практика-использования">Практика использования</h2>
<p>Теперь начнем с практического примера. Представим, что в нашей системе есть таблица, в которую мы собираем данные о посещаемости нашего ресурса. На любой запрос пользователя наша система логирует действия в эту таблицу. И, например, в начале каждого месяца (неделю) нам нужно создавать отчет за предыдущий месяц (неделю). При этом, логи нужно хранить в течении 3 лет. Данные в такой таблице накапливаются быстро, если система активно используется. И вот, когда в таблице уже миллионы, а то, и миллиарды записей, создавать отчеты становится все сложнее (да и чистка старых записей становится не легким делом). Работа с такой таблицей создает огромную нагрузку на СУБД. Тут нам на помощь и приходит партиционирование.</p>
<h3 id="настройка">Настройка</h3>
<p>Для примера, мы имеем следующую таблицу:</p>
<pre><code>CREATE TABLE my_logs (
    id              SERIAL PRIMARY KEY,
    user_id         INT NOT NULL,
    logdate         TIMESTAMP NOT NULL,
    data            TEXT,
    some_state      INT
);</code></pre>
<p>Поскольку нам нужны отчеты каждый месяц, мы будем делить партиции по месяцам. Это поможет нам быстрее создавать отчеты и чистить старые данные.</p>
<p>«Мастер» таблица будет «my_logs», структуру которой мы указали выше. Далее создадим «дочерние» таблицы (партиции):</p>
<pre><code>CREATE TABLE my_logs2010m10 (
    CHECK ( logdate &gt;= DATE &#39;2010-10-01&#39; AND logdate &lt; DATE &#39;2010-11-01&#39; )
) INHERITS (my_logs);
CREATE TABLE my_logs2010m11 (
    CHECK ( logdate &gt;= DATE &#39;2010-11-01&#39; AND logdate &lt; DATE &#39;2010-12-01&#39; )
) INHERITS (my_logs);
CREATE TABLE my_logs2010m12 (
    CHECK ( logdate &gt;= DATE &#39;2010-12-01&#39; AND logdate &lt; DATE &#39;2011-01-01&#39; )
) INHERITS (my_logs);
CREATE TABLE my_logs2011m01 (
    CHECK ( logdate &gt;= DATE &#39;2011-01-01&#39; AND logdate &lt; DATE &#39;2010-02-01&#39; )
) INHERITS (my_logs);</code></pre>
<p>Данными командами мы создаем таблицы «my_logs2010m10», «my_logs2010m11» и т.д., которые копируют структуру с «мастер» таблицы (кроме индексов). Также с помощью «CHECK» мы задаем диапазон значений, который будет попадать в эту партицию (хочу опять напомнить, что диапазоны значений партиций не должны пересекаться!). Поскольку партиционирование будет работать по полю «logdate», мы создадим индекс на это поле на всех партициях:</p>
<pre><code>CREATE INDEX my_logs2010m10_logdate ON my_logs2010m10 (logdate);
CREATE INDEX my_logs2010m11_logdate ON my_logs2010m11 (logdate);
CREATE INDEX my_logs2010m12_logdate ON my_logs2010m12 (logdate);
CREATE INDEX my_logs2011m01_logdate ON my_logs2011m01 (logdate);</code></pre>
<p>Далее для удобства создадим функцию, которая будет перенаправлять новые данные с «мастер» таблицы в соответствующую партицию.</p>
<pre><code>CREATE OR REPLACE FUNCTION my_logs_insert_trigger()
RETURNS TRIGGER AS $$
BEGIN
    IF ( NEW.logdate &gt;= DATE &#39;2010-10-01&#39; AND
         NEW.logdate &lt; DATE &#39;2010-11-01&#39; ) THEN
        INSERT INTO my_logs2010m10 VALUES (NEW.*);
    ELSIF ( NEW.logdate &gt;= DATE &#39;2010-11-01&#39; AND
            NEW.logdate &lt; DATE &#39;2010-12-01&#39; ) THEN
        INSERT INTO my_logs2010m11 VALUES (NEW.*);
    ELSIF ( NEW.logdate &gt;= DATE &#39;2010-12-01&#39; AND
            NEW.logdate &lt; DATE &#39;2011-01-01&#39; ) THEN
        INSERT INTO my_logs2010m12 VALUES (NEW.*);
    ELSIF ( NEW.logdate &gt;= DATE &#39;2011-01-01&#39; AND
            NEW.logdate &lt; DATE &#39;2011-02-01&#39; ) THEN
        INSERT INTO my_logs2011m01 VALUES (NEW.*);
    ELSE
        RAISE EXCEPTION &#39;Date out of range.  Fix the my_logs_insert_trigger() function!&#39;;
    END IF;
    RETURN NULL;
END;
$$
LANGUAGE plpgsql;</code></pre>
<p>В функции ничего особенного нет: идет проверка поля «logdate», по которой направляются данные в нужную партицию. При не нахождении требуемой партиции — вызываем ошибку. Теперь осталось создать триггер на «мастер» таблицу для автоматического вызова данной функции:</p>
<pre><code>CREATE TRIGGER insert_my_logs_trigger
    BEFORE INSERT ON my_logs
    FOR EACH ROW EXECUTE PROCEDURE my_logs_insert_trigger();</code></pre>
<p>Партиционирование настроено и теперь мы готовы приступить к тестированию.</p>
<h3 id="тестирование">Тестирование</h3>
<p>Для начала добавим данные в нашу таблицу «my_logs»:</p>
<pre><code>INSERT INTO my_logs (user_id,logdate, data, some_state) VALUES(1, &#39;2010-10-30&#39;, &#39;30.10.2010 data&#39;, 1);
INSERT INTO my_logs (user_id,logdate, data, some_state) VALUES(2, &#39;2010-11-10&#39;, &#39;10.11.2010 data2&#39;, 1);
INSERT INTO my_logs (user_id,logdate, data, some_state) VALUES(1, &#39;2010-12-15&#39;, &#39;15.12.2010 data3&#39;, 1);</code></pre>
<p>Теперь проверим где они хранятся:</p>
<pre><code>partitioning_test=# SELECT * FROM ONLY my_logs;
 id | user_id | logdate | data | some_state 
----+---------+---------+------+------------
(0 rows)</code></pre>
<p>Как видим в «мастер» таблицу данные не попали — она чиста. Теперь проверим а есть ли вообще данные:</p>
<pre><code>partitioning_test=# SELECT * FROM my_logs;
 id | user_id |       logdate       |       data       | some_state 
----+---------+---------------------+------------------+------------
  1 |       1 | 2010-10-30 00:00:00 | 30.10.2010 data  |          1
  2 |       2 | 2010-11-10 00:00:00 | 10.11.2010 data2 |          1
  3 |       1 | 2010-12-15 00:00:00 | 15.12.2010 data3 |          1
(3 rows)</code></pre>
<p>Данные при этом выводятся без проблем. Проверим партиции, правильно ли хранятся данные:</p>
<pre><code>partitioning_test=# Select * from my_logs2010m10;
 id | user_id |       logdate       |      data       | some_state 
----+---------+---------------------+-----------------+------------
  1 |       1 | 2010-10-30 00:00:00 | 30.10.2010 data |          1
(1 row)

partitioning_test=# Select * from my_logs2010m11;
 id | user_id |       logdate       |       data       | some_state 
----+---------+---------------------+------------------+------------
  2 |       2 | 2010-11-10 00:00:00 | 10.11.2010 data2 |          1
(1 row)</code></pre>
<p>Отлично! Данные хранятся на требуемых нам партициях. При этом запросы к таблице «my_logs» менять не нужно:</p>
<pre><code>partitioning_test=# SELECT * FROM my_logs WHERE user_id = 2;
 id | user_id |       logdate       |       data       | some_state 
----+---------+---------------------+------------------+------------
  2 |       2 | 2010-11-10 00:00:00 | 10.11.2010 data2 |          1
(1 row)

partitioning_test=# SELECT * FROM my_logs WHERE data LIKE &#39;%0.1%&#39;;
 id | user_id |       logdate       |       data       | some_state 
----+---------+---------------------+------------------+------------
  1 |       1 | 2010-10-30 00:00:00 | 30.10.2010 data  |          1
  2 |       2 | 2010-11-10 00:00:00 | 10.11.2010 data2 |          1
(2 rows)</code></pre>
<h3 id="управление-партициями">Управление партициями</h3>
<p>Обычно при работе с партиционированием старые партиции перестают получать данные и остаются неизменными. Это дает огромное преимущество над работой с данными через партиции. Например, нам нужно удалить старые логи за 2008 год, 10 месяц. Нам достаточно выполнить:</p>
<pre><code>DROP TABLE my_logs2008m10;</code></pre>
<p>поскольку «DROP TABLE» работает гораздо быстрее, чем удаление миллионов записей индивидуально через «DELETE». Другой вариант, который более предпочтителен, просто удалить партицию из партиционирования, тем самым оставив данные в СУБД, но уже не доступные через «мастер» таблицу:</p>
<pre><code>ALTER TABLE my_logs2008m10 NO INHERIT my_logs; </code></pre>
<p>Это удобно, если мы хотим эти данные потом перенести в другое хранилище или просто сохранить.</p>
<h3 id="важность-constraint_exclusion-для-партиционирования">Важность «constraint_exclusion» для партиционирования</h3>
<p>Параметр «constraint_exclusion» отвечает за оптимизацию запросов, что повышает производительность для партиционированых таблиц. Например, выполним простой запрос:</p>
<pre><code>partitioning_test=# SET constraint_exclusion = off;
partitioning_test=# EXPLAIN SELECT * FROM my_logs WHERE logdate &gt; &#39;2010-12-01&#39;;

                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Result  (cost=6.81..104.66 rows=1650 width=52)
   -&gt;  Append  (cost=6.81..104.66 rows=1650 width=52)
         -&gt;  Bitmap Heap Scan on my_logs  (cost=6.81..20.93 rows=330 width=52)
               Recheck Cond: (logdate &gt; &#39;2010-12-01 00:00:00&#39;::timestamp without time zone)
               -&gt;  Bitmap Index Scan on my_logs_logdate  (cost=0.00..6.73 rows=330 width=0)
                     Index Cond: (logdate &gt; &#39;2010-12-01 00:00:00&#39;::timestamp without time zone)
         -&gt;  Bitmap Heap Scan on my_logs2010m10 my_logs  (cost=6.81..20.93 rows=330 width=52)
               Recheck Cond: (logdate &gt; &#39;2010-12-01 00:00:00&#39;::timestamp without time zone)
               -&gt;  Bitmap Index Scan on my_logs2010m10_logdate  (cost=0.00..6.73 rows=330 width=0)
                     Index Cond: (logdate &gt; &#39;2010-12-01 00:00:00&#39;::timestamp without time zone)
         -&gt;  Bitmap Heap Scan on my_logs2010m11 my_logs  (cost=6.81..20.93 rows=330 width=52)
               Recheck Cond: (logdate &gt; &#39;2010-12-01 00:00:00&#39;::timestamp without time zone)
               -&gt;  Bitmap Index Scan on my_logs2010m11_logdate  (cost=0.00..6.73 rows=330 width=0)
                     Index Cond: (logdate &gt; &#39;2010-12-01 00:00:00&#39;::timestamp without time zone)
         -&gt;  Bitmap Heap Scan on my_logs2010m12 my_logs  (cost=6.81..20.93 rows=330 width=52)
               Recheck Cond: (logdate &gt; &#39;2010-12-01 00:00:00&#39;::timestamp without time zone)
               -&gt;  Bitmap Index Scan on my_logs2010m12_logdate  (cost=0.00..6.73 rows=330 width=0)
                     Index Cond: (logdate &gt; &#39;2010-12-01 00:00:00&#39;::timestamp without time zone)
         -&gt;  Bitmap Heap Scan on my_logs2011m01 my_logs  (cost=6.81..20.93 rows=330 width=52)
               Recheck Cond: (logdate &gt; &#39;2010-12-01 00:00:00&#39;::timestamp without time zone)
               -&gt;  Bitmap Index Scan on my_logs2011m01_logdate  (cost=0.00..6.73 rows=330 width=0)
                     Index Cond: (logdate &gt; &#39;2010-12-01 00:00:00&#39;::timestamp without time zone)
(22 rows)</code></pre>
<p>Как видно через команду «EXPLAIN», данный запрос сканирует все партиции на наличие данных в них, что не логично, поскольку данное условие «logdate &gt; 2010-12-01» говорит о том, что данные должны браться только с партиций, где подходит такое условие. А теперь включим «constraint_exclusion»:</p>
<pre><code>partitioning_test=# SET constraint_exclusion = on;
SET
partitioning_test=# EXPLAIN SELECT * FROM my_logs WHERE logdate &gt; &#39;2010-12-01&#39;;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Result  (cost=6.81..41.87 rows=660 width=52)
   -&gt;  Append  (cost=6.81..41.87 rows=660 width=52)
         -&gt;  Bitmap Heap Scan on my_logs  (cost=6.81..20.93 rows=330 width=52)
               Recheck Cond: (logdate &gt; &#39;2010-12-01 00:00:00&#39;::timestamp without time zone)
               -&gt;  Bitmap Index Scan on my_logs_logdate  (cost=0.00..6.73 rows=330 width=0)
                     Index Cond: (logdate &gt; &#39;2010-12-01 00:00:00&#39;::timestamp without time zone)
         -&gt;  Bitmap Heap Scan on my_logs2010m12 my_logs  (cost=6.81..20.93 rows=330 width=52)
               Recheck Cond: (logdate &gt; &#39;2010-12-01 00:00:00&#39;::timestamp without time zone)
               -&gt;  Bitmap Index Scan on my_logs2010m12_logdate  (cost=0.00..6.73 rows=330 width=0)
                     Index Cond: (logdate &gt; &#39;2010-12-01 00:00:00&#39;::timestamp without time zone)
(10 rows)</code></pre>
<p>Как мы видим, теперь запрос работает правильно, и сканирует только партиции, что подходят под условие запроса. Но включать «constraint_exclusion» не желательно для баз, где нет партиционирования, поскольку команда «CHECK» будет проверятся на всех запросах, даже простых, а значит производительность сильно упадет. Начиная с 8.4 версии PostgreSQL «constraint_exclusion» может быть «on», «off» и «partition». По умолчанию (и рекомендуется) ставить «constraint_exclusion» не «on», и не «off», а «partition», который будет проверять «CHECK» только на партиционированых таблицах.</p>
<h2 id="заключение-1">Заключение</h2>
<p>Партиционирование — одна из самых простых и менее безболезненных методов уменьшения нагрузки на СУБД. Именно на этот вариант стоит посмотреть сперва, и если он не подходит по каким либо причинам — переходить к более сложным. Но если в системе есть таблица, у которой актуальны только новые данные, но огромное количество старых (не актуальных) данных дает 50% или более нагрузки на СУБД — Вам стоит внедрить партиционирование.</p>
<h1 id="репликация">Репликация</h1>
<h2 id="введение-3">Введение</h2>
<p>Репликация (англ. replication) — механизм синхронизации содержимого нескольких копий объекта (например, содержимого базы данных). Репликация — это процесс, под которым понимается копирование данных из одного источника на множество других и наоборот. При репликации изменения, сделанные в одной копии объекта, могут быть распространены в другие копии. Репликация может быть синхронной или асинхронной.</p>
<p>В случае синхронной репликации, если данная реплика обновляется, все другие реплики того же фрагмента данных также должны быть обновлены в одной и той же транзакции. Логически это означает, что существует лишь одна версия данных. В большинстве продуктов синхронная репликация реализуется с помощью триггерных процедур (возможно, скрытых и управляемых системой). Но синхронная репликация имеет тот недостаток, что она создаёт дополнительную нагрузку при выполнении всех транзакций, в которых обновляются какие-либо реплики (кроме того, могут возникать проблемы, связанные с доступностью данных).</p>
<p>В случае асинхронной репликации обновление одной реплики распространяется на другие спустя некоторое время, а не в той же транзакции. Таким образом, при асинхронной репликации вводится задержка, или время ожидания, в течение которого отдельные реплики могут быть фактически неидентичными (то есть определение реплика оказывается не совсем подходящим, поскольку мы не имеем дело с точными и своевременно созданными копиями). В большинстве продуктов асинхронная репликация реализуется посредством чтения журнала транзакций или постоянной очереди тех обновлений, которые подлежат распространению. Преимущество асинхронной репликации состоит в том, что дополнительные издержки репликации не связаны с транзакциями обновлений, которые могут иметь важное значение для функционирования всего предприятия и предъявлять высокие требования к производительности. К недостаткам этой схемы относится то, что данные могут оказаться несовместимыми (то есть несовместимыми с точки зрения пользователя). Иными словами, избыточность может проявляться на логическом уровне, а это, строго говоря, означает, что термин контролируемая избыточность в таком случае не применим.</p>
<p>Рассмотрим кратко проблему согласованности (или, скорее, несогласованности). Дело в том, что реплики могут становиться несовместимыми в результате ситуаций, которые трудно (или даже невозможно) избежать и последствия которых трудно исправить. В частности, конфликты могут возникать по поводу того, в каком порядке должны применяться обновления. Например, предположим, что в результате выполнения транзакции А происходит вставка строки в реплику X, после чего транзакция B удаляет эту строку, а также допустим, что Y — реплика X. Если обновления распространяются на Y, но вводятся в реплику Y в обратном порядке (например, из-за разных задержек при передаче), то транзакция B не находит в Y строку, подлежащую удалению, и не выполняет своё действие, после чего транзакция А вставляет эту строку. Суммарный эффект состоит в том, что реплика Y содержит указанную строку, а реплика X — нет.</p>
<p>В целом задачи устранения конфликтных ситуаций и обеспечения согласованности реплик являются весьма сложными. Следует отметить, что, по крайней мере, в сообществе пользователей коммерческих баз данных термин репликация стал означать преимущественно (или даже исключительно) асинхронную репликацию.</p>
<p>Основное различие между репликацией и управлением копированием заключается в следующем: Если используется репликация, то обновление одной реплики в конечном счёте распространяется на все остальные автоматически. В режиме управления копированием, напротив, не существует такого автоматического распространения обновлений. Копии данных создаются и управляются с помощью пакетного или фонового процесса, который отделён во времени от транзакций обновления. Управление копированием в общем более эффективно по сравнению с репликацией, поскольку за один раз могут копироваться большие объёмы данных. К недостаткам можно отнести то, что большую часть времени копии данных не идентичны базовым данным, поэтому пользователи должны учитывать, когда именно были синхронизированы эти данные. Обычно управление копированием упрощается благодаря тому требованию, чтобы обновления применялись в соответствии со схемой первичной копии того или иного вида.</p>
<p>Для репликации PostgreSQL существует несколько решений, как закрытых, так и свободных. Закрытые системы репликации не будут рассматриваться в этой книге (ну, сами понимаете). Вот список свободных решений:</p>
<ul>
<li><p><a href="http://www.slony.info/">Slony-I</a> — асинхронная Master-Slave репликация, поддерживает каскады(cascading) и отказоустойчивость(failover). Slony-I использует триггеры PostgreSQL для привязки к событиям INSERT/ DELETE/UPDATE и хранимые процедуры для выполнения действий.</p></li>
<li><p><a href="http://pgfoundry.org/projects/pgcluster/">PGCluster</a> — синхронная Multi-Master репликация. Проект на мой взгляд мертв, поскольку уже год не обновлялся.</p></li>
<li><p><a href="http://pgpool.projects.postgresql.org/">pgpool-I/II</a> — это замечательный инструмент для PostgreSQL (лучше сразу работать с II версией). Позволяет делать:</p>
<ul>
<li><p>репликацию (в том числе, с автоматическим переключением на резервный stand-by сервер);</p></li>
<li><p>online-бэкап;</p></li>
<li><p>pooling коннектов;</p></li>
<li><p>очередь соединений;</p></li>
<li><p>балансировку SELECT-запросов на несколько postgresql-серверов;</p></li>
<li><p>разбиение запросов для параллельного выполнения над большими объемами данных.</p></li>
</ul></li>
<li><p><a href="http://bucardo.org/">Bucardo</a> — асинхронная репликация, которая поддерживает Multi-Master и Master-Slave режимы, а также несколько видов синхронизации и обработки конфликтов.</p></li>
<li><p><a href="http://skytools.projects.postgresql.org/doc/londiste.ref.html">Londiste</a> — асинхронная Master-Slave репликация. Входит в состав Skytools<a href="#fn12" class="footnoteRef" id="fnref12"><sup>12</sup></a>. Проще в использовании, чем Slony-I.</p></li>
<li><p><a href="http://www.commandprompt.com/products/mammothreplicator/">Mammoth Replicator</a> — асинхронная Multi-Master репликация.</p></li>
<li><p><a href="http://www.postgres-r.org/">Postgres-R</a> — асинхронная Multi-Master репликация.</p></li>
<li><p><a href="http://www.rubyrep.org/">RubyRep</a> — написанная на Ruby, асинхронная Multi-Master репликация, которая поддерживает PostgreSQL и MySQL.</p></li>
</ul>
<p>Это, конечно, не весь список свободных систем для репликации, но я думаю даже из этого есть что выбрать для PostgreSQL.</p>
<h2 id="streaming-replication-потоковая-репликация">Streaming Replication (Потоковая репликация)</h2>
<h3 id="введение-4">Введение</h3>
<p>Потоковая репликация (Streaming Replication, SR) дает возможность непрерывно отправлять и применять wall xlog записи на резервные сервера для создания точной копии текущего. Данная функциональность появилась у PostgreSQL начиная с 9 версии (репликация из коробки!). Этот тип репликации простой, надежный и, вероятней всего, будет использоваться в качестве стандартной репликации в большинстве высоконагруженных приложений, что используют PostgreSQL.</p>
<p>Отличительными особенностями решения являются:</p>
<ul>
<li><p>репликация всего инстанса PostgreSQL</p></li>
<li><p>асинхронный механизм репликации</p></li>
<li><p>простота установки</p></li>
<li><p>мастер база данных может обслуживать огромное количество слейвов из-за минимальной нагрузки</p></li>
</ul>
<p>К недостаткам можно отнести:</p>
<ul>
<li><p>невозможность реплицировать только определенную базу данных из всех на PostgreSQL инстансе</p></li>
<li><p>асинхронный механизм — слейв отстает от мастера (но в отличие от других методов репликации, это отставание очень короткое, и может составлять всего лишь одну транзакцию, в зависимости от скорости сети, нагруженности БД и настроек «Hot Standby»)</p></li>
</ul>
<h3 id="установка">Установка</h3>
<p>Для начала нам потребуется PostgreSQL не ниже 9 версии. В момент написания этой главы была доступна 9.0.1 версия. Все работы, как полагается, будут проводится на ОС Linux.</p>
<h3 id="настройка-1">Настройка</h3>
<p>Для начала обозначим мастер сервер как masterdb(192.168.0.10) и слейв как slavedb(192.168.0.20).</p>
<h4 id="предварительная-настройка">Предварительная настройка</h4>
<p>Для начала позволим определенному пользователю без пароля ходить по ssh. Пусть это будет postgres юзер. Если же нет, то создаем набором команд:</p>
<pre><code>$sudo groupadd userssh
$sudo useradd -m -g userssh -d /home/userssh -s /bin/bash \
-c &quot;user ssh allow&quot; userssh</code></pre>
<p>Дальше выполняем команды от имени пользователя (в данном случае postgres):</p>
<pre><code>su postgres</code></pre>
<p>Генерим RSA-ключ для обеспечения аутентификации в условиях отсутствия возможности использовать пароль:</p>
<pre><code>postgres@localhost ~ $ ssh-keygen -t rsa -P &quot;&quot;
Generating public/private rsa key pair.
Enter file in which to save the key (/var/lib/postgresql/.ssh/id_rsa): 
Created directory &#39;/var/lib/postgresql/.ssh&#39;.
Your identification has been saved in /var/lib/postgresql/.ssh/id_rsa.
Your public key has been saved in /var/lib/postgresql/.ssh/id_rsa.pub.
The key fingerprint is:
16:08:27:97:21:39:b5:7b:86:e1:46:97:bf:12:3d:76 postgres@localhost</code></pre>
<p>И добавляем его в список авторизованных ключей:</p>
<pre><code>cat $HOME/.ssh/id_rsa.pub » $HOME/.ssh/authorized_keys</code></pre>
<p>Этого должно быть более чем достаточно. Проверить работоспособность соединения можно просто написав:</p>
<pre><code>ssh localhost</code></pre>
<p>Не забываем предварительно инициализировать sshd:</p>
<pre><code>/etc/init.d/sshd start</code></pre>
<p>После успешно проделаной операции скопируйте «$HOME/.ssh» на slavedb. Теперь мы должны иметь возможность без пароля заходить с мастера на слейв и со слейва на мастер через ssh.</p>
<p>Также отредактируем pg_hba.conf на мастере и слейве, разрешив им друг к другу доступ без пароля(trust) (тут добавляется роль replication):</p>
<pre><code>host  replication  all  192.168.0.20/32  trust</code></pre>
<pre><code>host  replication  all  192.168.0.10/32  trust</code></pre>
<p>Не забываем после этого перегрузить postgresql на обоих серверах.</p>
<h4 id="настройка-мастера">Настройка мастера</h4>
<p>Для начала настроим masterdb. Установим параметры в postgresql.conf для репликации:</p>
<pre><code># To enable read-only queries on a standby server, wal_level must be set to
# &quot;hot_standby&quot;. But you can choose &quot;archive&quot; if you never connect to the
# server in standby mode.
wal_level = hot_standby

# Set the maximum number of concurrent connections from the standby servers.
max_wal_senders = 5

# To prevent the primary server from removing the WAL segments required for
# the standby server before shipping them, set the minimum number of segments
# retained in the pg_xlog directory. At least wal_keep_segments should be
# larger than the number of segments generated between the beginning of
# online-backup and the startup of streaming replication. If you enable WAL
# archiving to an archive directory accessible from the standby, this may
# not be necessary.
wal_keep_segments = 32

# Enable WAL archiving on the primary to an archive directory accessible from
# the standby. If wal_keep_segments is a high enough number to retain the WAL
# segments required for the standby server, this may not be necessary.
archive_mode    = on
archive_command = &#39;cp %p /path_to/archive/%f&#39;</code></pre>
<p>Давайте по порядку:</p>
<ul>
<li><p>«wal_level = hot_standby» — сервер начнет писать в WAL логи так же как и при режиме «archive», добавляя информацию, необходимую для восстановления транзакции (можно также поставить «archive», но тогда сервер не может быть слейвом при необходимости).</p></li>
<li><p>«max_wal_senders = 5» — максимальное количество слейвов.</p></li>
<li><p>«wal_keep_segments = 32» — минимальное количество файлов c WAL сегментами в pg_xlog директории.</p></li>
<li><p>«archive_mode = on» — позволяем сохранять WAL сегменты в указанное переменной «archive_command» хранилище. В данном случае в директорию «/path_to/archive/».</p></li>
</ul>
<p>По умолчанию репликация асинхронная. В версии 9.1 добавили параметр «synchronous_standby_names», который включает синхронную репликацию. В данные параметр передается «application_name», который используется на слейвах в recovery.conf:</p>
<pre><code>restore_command = &#39;cp /tmp/%f %p&#39;               # e.g. &#39;cp /mnt/server/archivedir/%f %p&#39;
standby_mode = on
primary_conninfo = &#39;host=localhost port=59121 user=replication password=replication application_name=newcluster&#39;            # e.g. &#39;host=localhost port=5432&#39;
trigger_file = &#39;/tmp/trig_f_newcluster&#39;</code></pre>
<p>После изменения параметров перегружаем PostgreSQL сервер. Теперь перейдем к slavedb.</p>
<h4 id="настройка-слейва">Настройка слейва</h4>
<p>Для начала нам потребуется создать на slavedb точную копию masterdb. Перенесем данные с помощью «Онлайн бекапа».</p>
<p>Для начала зайдем на masterdb сервер. Выполним в консоли:</p>
<pre><code>psql -c &quot;SELECT pg_start_backup(&#39;label&#39;, true)&quot; </code></pre>
<p>Теперь нам нужно перенести данные с мастера на слейв. Выполняем на мастере:</p>
<pre><code>rsync -C -a --delete -e ssh --exclude postgresql.conf --exclude postmaster.pid \
--exclude postmaster.opts --exclude pg_log --exclude pg_xlog \
--exclude recovery.conf master_db_datadir/ slavedb_host:slave_db_datadir/ </code></pre>
<p>где</p>
<ul>
<li><p>«master_db_datadir» — директория с postgresql данными на masterdb</p></li>
<li><p>«slave_db_datadir» — директория с postgresql данными на slavedb</p></li>
<li><p>«slavedb_host» — хост slavedb(в нашем случае - 192.168.1.20)</p></li>
</ul>
<p>После копирования данных с мастера на слейв, остановим онлайн бекап. Выполняем на мастере:</p>
<pre><code>psql -c &quot;SELECT pg_stop_backup()&quot;</code></pre>
<p>Устанавливаем такие же данные в конфиге postgresql.conf, что и у мастера (чтобы при падении мастера слейв мог его заменить). Так же установим дополнительный параметр:</p>
<pre><code>hot_standby = on</code></pre>
<p>Внимание! Если на мастере поставили «wal_level = archive», тогда параметр оставляем по умолчанию (hot_standby = off).</p>
<p>Далее на slavedb в директории с данными PostgreSQL создадим файл recovery.conf с таким содержимым:</p>
<pre><code># Specifies whether to start the server as a standby. In streaming replication,
# this parameter must to be set to on.
standby_mode          = &#39;on&#39;

# Specifies a connection string which is used for the standby server to connect
# with the primary.
primary_conninfo      = &#39;host=192.168.0.10 port=5432 user=postgres&#39;

# Specifies a trigger file whose presence should cause streaming replication to
# end (i.e., failover).
trigger_file = &#39;/path_to/trigger&#39;

# Specifies a command to load archive segments from the WAL archive. If
# wal_keep_segments is a high enough number to retain the WAL segments
# required for the standby server, this may not be necessary. But
# a large workload can cause segments to be recycled before the standby
# is fully synchronized, requiring you to start again from a new base backup.
restore_command = &#39;scp masterdb_host:/path_to/archive/%f &quot;%p&quot;&#39;</code></pre>
<p>где</p>
<ul>
<li><p>«standby_mode=’on’» — указываем серверу работать в режиме слейв</p></li>
<li><p>«primary_conninfo» — настройки соединения слейва с мастером</p></li>
<li><p>«trigger_file» — указываем триггер-файл, при наличии которого будет остановлена репликация.</p></li>
<li><p>«restore_command» — команда, которой будут восстанавливаться WAL логи. В нашем случае через scp копируем с masterdb (masterdb_host - хост masterdb).</p></li>
</ul>
<p>Теперь мы можем запустить PostgreSQL на slavedb.</p>
<h4 id="тестирование-репликации">Тестирование репликации</h4>
<p>Теперь мы можем посмотреть отставание слейвов от мастера с помощью таких команд:</p>
<pre><code>$ psql -c &quot;SELECT pg_current_xlog_location()&quot; -h192.168.0.10 (masterdb)
 pg_current_xlog_location 
--------------------------
 0/2000000
(1 row)

$ psql -c &quot;select pg_last_xlog_receive_location()&quot; -h192.168.0.20 (slavedb)
 pg_last_xlog_receive_location 
-------------------------------
 0/2000000
(1 row)

$ psql -c &quot;select pg_last_xlog_replay_location()&quot; -h192.168.0.20 (slavedb)
 pg_last_xlog_replay_location 
------------------------------
 0/2000000
(1 row)</code></pre>
<p>Начиная с версии 9.1 добавили дополнительные view для просмотра состояния репликации. Теперь master знает все состояния slaves:</p>
<pre><code># SELECT * from pg_stat_replication ;
  procpid | usesysid |   usename   | application_name | client_addr | client_hostname | client_port |        backend_start         |   state   | sent_location | write_location | flush_location | replay_location | sync_priority | sync_state 
 ---------+----------+-------------+------------------+-------------+-----------------+-------------+------------------------------+-----------+---------------+----------------+----------------+-----------------+---------------+------------
    17135 |    16671 | replication | newcluster       | 127.0.0.1   |                 |       43745 | 2011-05-22 18:13:04.19283+02 | streaming | 1/30008750    | 1/30008750     | 1/30008750     | 1/30008750      |             1 | sync</code></pre>
<p>Также с версии 9.1 добавили view pg_stat_database_conflicts, с помощью которой на слейв базах можно просмотреть сколько запросов было отменено и по каким причинам:</p>
<pre><code># SELECT * from pg_stat_database_conflicts ;
  datid |  datname  | confl_tablespace | confl_lock | confl_snapshot | confl_bufferpin | confl_deadlock 
 -------+-----------+------------------+------------+----------------+-----------------+----------------
      1 | template1 |                0 |          0 |              0 |               0 |              0
  11979 | template0 |                0 |          0 |              0 |               0 |              0
  11987 | postgres  |                0 |          0 |              0 |               0 |              0
  16384 | marc      |                0 |          0 |              1 |               0 |              0</code></pre>
<p>Еще проверить работу репликации можно с помощью утилиты ps:</p>
<pre><code>$ ps -ef | grep sender
postgres  6879  6831  0 10:31 ?        00:00:00 postgres: wal sender process postgres 127.0.0.1(44663) streaming 0/2000000

[slavedb] $ ps -ef | grep receiver
postgres  6878  6872  1 10:31 ?        00:00:01 postgres: wal receiver process   streaming 0/2000000</code></pre>
<p>Теперь проверим реприкацию. Выполним на мастере:</p>
<pre><code>$psql test_db
test_db=# create table test3(id int not null primary key,name varchar(20));
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index &quot;test3_pkey&quot; for table &quot;test3&quot;
CREATE TABLE
test_db=# insert into test3(id, name) values(&#39;1&#39;, &#39;test1&#39;);
INSERT 0 1
test_db=#</code></pre>
<p>Теперь проверим на слейве:</p>
<pre><code>$psql test_db
test_db=# select * from test3;
 id | name  
----+-------
  1 | test1
(1 row)</code></pre>
<p>Как видим, таблица с данными успешно скопирована с мастера на слейв.</p>
<h3 id="общие-задачи">Общие задачи</h3>
<h4 id="переключение-на-слейв-при-падении-мастера">Переключение на слейв при падении мастера</h4>
<p>Достаточно создать триггер-файл (trigger_file) на слейве, который становится мастером.</p>
<h4 id="остановка-репликации-на-слейве">Остановка репликации на слейве</h4>
<p>Создать триггер-файл (trigger_file) на слейве. Также с версии 9.1 добавили команды pg_xlog_replay_pause() и pg_xlog_replay_resume() для остановки и возобновления репликации.</p>
<h4 id="перезапуск-репликации-после-сбоя">Перезапуск репликации после сбоя</h4>
<p>Повторяем операции из раздела «Настройка слейва». Хочется заметить, что мастер при этом не нуждается в остановке при выполнении данной задачи.</p>
<h4 id="перезапуск-репликации-после-сбоя-слейва">Перезапуск репликации после сбоя слейва</h4>
<p>Перезагрузить PostgreSQL на слейве после устранения сбоя.</p>
<h4 id="повторно-синхронизировать-репликации-на-слейве">Повторно синхронизировать репликации на слейве</h4>
<p>Это может потребоваться, например, после длительного отключения от мастера. Для этого останавливаем PostgreSQL на слейве и повторяем операции из раздела «Настройка слейва».</p>
<h2 id="slony-i">Slony-I</h2>
<h3 id="введение-5">Введение</h3>
<p>Slony это система репликации реального времени, позволяющая организовать синхронизацию нескольких серверов PostgreSQL по сети. Slony использует триггеры Postgre для привязки к событиям INSERT/ DELETE/UPDATE и хранимые процедуры для выполнения действий.</p>
<p>Система Slony с точки зрения администратора состоит из двух главных компонент: репликационного демона slony и административной консоли slonik. Администрирование системы сводится к общению со slonik-ом, демон slon только следит за собственно процессом репликации. А админ следит за тем, чтобы slon висел там, где ему положено.</p>
<h4 id="о-slonik-e">О slonik-e</h4>
<p>Все команды slonik принимает на свой stdin. До начала выполнения скрипт slonik-a проверяется на соответствие синтаксису, если обнаруживаются ошибки, скрипт не выполняется, так что можно не волноваться если slonik сообщает о syntax error, ничего страшного не произошло. И он ещё ничего не сделал. Скорее всего.</p>
<h3 id="установка-1">Установка</h3>
<p>Установка на Ubuntu производится простой командой:</p>
<pre><code>sudo aptitude install slony1-bin</code></pre>
<h3 id="sec:slonyI">Настройка</h3>
<p>Рассмотрим теперь установку на гипотетическую базу данных customers (названия узлов, кластеров и таблиц являются вымышленными).</p>
<p>Наши данные</p>
<ul>
<li><p>БД: customers</p></li>
<li><p>master_host: customers_master.com</p></li>
<li><p>slave_host_1: customers_slave.com</p></li>
<li><p>cluster name (нужно придумать): customers_rep</p></li>
</ul>
<h4 id="подготовка-master-сервера">Подготовка master-сервера</h4>
<p>Для начала нам нужно создать пользователя Postgres, под которым будет действовать Slony. По умолчанию, и отдавая должное системе, этого пользователя обычно называют slony.</p>
<pre><code>pgsql@customers_master$ createuser -a -d slony
pgsql@customers_master$ psql -d template1 -c &quot;alter \
user slony with password &#39;slony_user_password&#39;;&quot;</code></pre>
<p>Также на каждом из узлов лучше завести системного пользователя slony, чтобы запускать от его имени репликационного демона slon. В дальнейшем подразумевается, что он (и пользователь и slon) есть на каждом из узлов кластера.</p>
<h4 id="подготовка-одного-slave-сервера">Подготовка одного slave-сервера</h4>
<p>Здесь я рассматриваю, что серверы кластера соединены посредством сети Internet (как в моём случае), необходимо чтобы с каждого из ведомых серверов можно было установить соединение с PostgreSQL на мастер-хосте, и наоборот. То есть, команда:</p>
<pre><code>anyuser@customers_slave$ psql -d customers \
-h customers_master.com -U slony</code></pre>
<p>должна подключать нас к мастер-серверу (после ввода пароля, желательно). Если что-то не так, возможно требуется поковыряться в настройках firewall-a, или файле pg_hba.conf, который лежит в $PGDATA.</p>
<p>Теперь устанавливаем на slave-хост сервер PostgreSQL. Следующего обычно не требуется, сразу после установки Postgres «up and ready», но в случае каких-то ошибок можно начать «с чистого листа», выполнив следующие команды (предварительно сохранив конфигурационные файлы и остановив postmaster):</p>
<pre><code>pgsql@customers_slave$ rm -rf $PGDATA
pgsql@customers_slave$ mkdir $PGDATA
pgsql@customers_slave$ initdb -E UTF8 -D $PGDATA
pgsql@customers_slave$ createuser -a -d slony
pgsql@customers_slave$ psql -d template1 -c &quot;alter \
user slony with password &#39;slony_user_password&#39;;&quot;</code></pre>
<p>Запускаем postmaster.</p>
<p>Внимание! Обычно требуется определённый владелец для реплицируемой БД. В этом случае необходимо завести его тоже!</p>
<pre><code>pgsql@customers_slave$ createuser -a -d customers_owner
pgsql@customers_slave$ psql -d template1 -c &quot;alter \
user customers_owner with password &#39;customers_owner_password&#39;;&quot;</code></pre>
<p>Эти две команды можно запускать с customers_master, к командной строке в этом случае нужно добавить «-h customers_slave», чтобы все операции выполнялись на slave.</p>
<p>На slave, как и на master, также нужно установить Slony.</p>
<h4 id="инициализация-бд-и-plpgsql-на-slave">Инициализация БД и plpgsql на slave</h4>
<p>Следующие команды выполняются от пользователя slony. Скорее всего для выполнения каждой из них потребуется ввести пароль (slony_user_password). Итак:</p>
<pre><code>slony@customers_master$ createdb -O customers_owner \
-h customers_slave.com customers
slony@customers_master$ createlang -d customers \
-h customers_slave.com plpgsql</code></pre>
<p>Внимание! Все таблицы, которые будут добавлены в replication set должны иметь primary key. Если какая-то из таблиц не удовлетворяет этому условию, задержитесь на этом шаге и дайте каждой таблице primary key командой ALTER TABLE ADD PRIMARY KEY.</p>
<p>Если столбца который мог бы стать primary key не находится, добавьте новый столбец типа serial (ALTER TABLE ADD COLUMN), и заполните его значениями. Настоятельно НЕ рекомендую использовать «table add key» slonik-a.</p>
<p>Продолжаем. Создаём таблицы и всё остальное на slave:</p>
<pre><code>slony@customers_master$ pg_dump -s customers | \
psql -U slony -h customers_slave.com customers</code></pre>
<p>pg_dump -s сдампит только структуру нашей БД.</p>
<p>pg_dump -s customers должен пускать без пароля, а вот для psql -U slony -h customers_slave.com customers придётся набрать пароль (slony_user_pass). Важно: я подразумеваю что сейчас на мастер-хосте ещё не установлен Slony (речь не про make install), то есть в БД нет таблиц sl_, триггеров и прочего. Если есть, то возможно два варианта:</p>
<ul>
<li><p>добавляется узел в уже функционирующую систему репликации (читайте раздел 5)</p></li>
<li><p>это ошибка :-) Тогда до переноса структуры на slave выполните следующее:</p>
<pre><code>slonik «EOF
cluster name = customers_slave;
node Y admin conninfo = &#39;dbname=customers host=customers_master.com 
port=5432 user=slony password=slony_user_pass&#39;;
uninstall node (id = Y);
echo &#39;okay&#39;;
EOF</code></pre>
<p>Y — число. Любое. Важно: если это действительно ошибка, cluster name может иметь какой-то другое значение, например T1 (default). Нужно его выяснить и сделать uninstall.</p>
<p>Если структура уже перенесена (и это действительно ошибка), сделайте uninstall с обоих узлов (с master и slave).</p></li>
</ul>
<h4 id="инициализация-кластера">Инициализация кластера</h4>
<p>Если Сейчас мы имеем два сервера PgSQL которые свободно «видят» друг друга по сети, на одном из них находится мастер-база с данными, на другом — только структура.</p>
<p>На мастер-хосте запускаем такой скрипт:</p>
<pre><code>#!/bin/sh

CLUSTER=customers_rep

DBNAME1=customers
DBNAME2=customers

HOST1=customers_master.com
HOST2=customers_slave.com

PORT1=5432
PORT2=5432

SLONY_USER=slony

slonik «EOF
cluster name = $CLUSTER;
node 1 admin conninfo = &#39;dbname=$DBNAME1 host=$HOST1 port=$PORT1 
user=slony password=slony_user_password&#39;;
node 2 admin conninfo = &#39;dbname=$DBNAME2 host=$HOST2 
port=$PORT2 user=slony password=slony_user_password&#39;;
init cluster ( id = 1, comment = &#39;Customers DB 
replication cluster&#39; );

echo &#39;Create set&#39;;

create set ( id = 1, origin = 1, comment = &#39;Customers 
DB replication set&#39; );

echo &#39;Adding tables to the subscription set&#39;;

echo &#39; Adding table public.customers_sales...&#39;;
set add table ( set id = 1, origin = 1, id = 4, full qualified 
name = &#39;public.customers_sales&#39;, comment = &#39;Table public.customers_sales&#39; );
echo &#39; done&#39;;

echo &#39; Adding table public.customers_something...&#39;;
set add table ( set id = 1, origin = 1, id = 5, full qualified 
name = &#39;public.customers_something, 
comment = &#39;Table public.customers_something );
echo &#39; done&#39;;

echo &#39;done adding&#39;;
store node ( id = 2, comment = &#39;Node 2, $HOST2&#39; );
echo &#39;stored node&#39;;
store path ( server = 1, client = 2, conninfo = &#39;dbname=$DBNAME1 host=$HOST1 
port=$PORT1 user=slony password=slony_user_password&#39; );
echo &#39;stored path&#39;;
store path ( server = 2, client = 1, conninfo = &#39;dbname=$DBNAME2 host=$HOST2 
port=$PORT2 user=slony password=slony_user_password&#39; );

store listen ( origin = 1, provider = 1, receiver = 2 );
store listen ( origin = 2, provider = 2, receiver = 1 );
EOF</code></pre>
<p>Здесь мы инициализируем кластер, создаём репликационный набор, включаем в него две таблицы. Важно: нужно перечислить все таблицы, которые нужно реплицировать, id таблицы в наборе должен быть уникальным, таблицы должны иметь primary key.</p>
<p>Важно: replication set запоминается раз и навсегда. Чтобы добавить узел в схему репликации не нужно заново инициализировать set.</p>
<p>Важно: если в набор добавляется или удаляется таблица нужно переподписать все узлы. То есть сделать unsubscribe и subscribe заново.</p>
<h4 id="подписываем-slave-узел-на-replication-set">Подписываем slave-узел на replication set</h4>
<p>Скрипт:</p>
<pre><code>#!/bin/sh

CLUSTER=customers_rep

DBNAME1=customers
DBNAME2=customers

HOST1=customers_master.com
HOST2=customers_slave.com

PORT1=5432
PORT2=5432

SLONY_USER=slony

slonik «EOF
cluster name = $CLUSTER;
node 1 admin conninfo = &#39;dbname=$DBNAME1 host=$HOST1 
port=$PORT1 user=slony password=slony_user_password&#39;;
node 2 admin conninfo = &#39;dbname=$DBNAME2 host=$HOST2 
port=$PORT2 user=slony password=slony_user_password&#39;;

echo&#39;subscribing&#39;;
subscribe set ( id = 1, provider = 1, receiver = 2, forward = no);

EOF</code></pre>
<h4 id="старт-репликации">Старт репликации</h4>
<p>Теперь, на обоих узлах необходимо запустить демона репликации.</p>
<pre><code>slony@customers_master$ slon customers_rep \
&quot;dbname=customers user=slony&quot;</code></pre>
<p>и</p>
<pre><code>slony@customers_slave$ slon customers_rep \
&quot;dbname=customers user=slony&quot;</code></pre>
<p>Сейчас слоны обменяются сообщениями и начнут передачу данных. Начальное наполнение происходит с помощью COPY, slave DB на это время полностью блокируется.</p>
<p>В среднем время актуализации данных на slave-системе составляет до 10-ти секунд. slon успешно обходит проблемы со связью и подключением к БД, и вообще требует к себе достаточно мало внимания.</p>
<h3 id="общие-задачи-1">Общие задачи</h3>
<h4 id="добавление-ещё-одного-узла-в-работающую-схему-репликации">Добавление ещё одного узла в работающую схему репликации</h4>
<p>Выполнить [sec:slonyI].1 и выполнить [sec:slonyI].2.</p>
<p>Новый узел имеет id = 3. Находится на хосте customers_slave3.com, «видит» мастер-сервер по сети и мастер может подключиться к его PgSQL.</p>
<p>после дублирования структуры (п [sec:slonyI].2) делаем следующее:</p>
<pre><code>slonik «EOF
cluster name = customers_slave;
node 3 admin conninfo = &#39;dbname=customers host=customers_slave3.com 
port=5432 user=slony password=slony_user_pass&#39;;
uninstall node (id = 3);
echo &#39;okay&#39;;
EOF</code></pre>
<p>Это нужно чтобы удалить схему, триггеры и процедуры, которые были сдублированы вместе с таблицами и структурой БД.</p>
<p>Инициализировать кластер не надо. Вместо этого записываем информацию о новом узле в сети:</p>
<pre><code>#!/bin/sh

CLUSTER=customers_rep

DBNAME1=customers
DBNAME3=customers

HOST1=customers_master.com
HOST3=customers_slave3.com

PORT1=5432
PORT2=5432

SLONY_USER=slony

slonik «EOF
cluster name = $CLUSTER;
node 1 admin conninfo = &#39;dbname=$DBNAME1 host=$HOST1 
port=$PORT1 user=slony password=slony_user_pass&#39;;
node 3 admin conninfo = &#39;dbname=$DBNAME3 
host=$HOST3 port=$PORT2 user=slony password=slony_user_pass&#39;;

echo &#39;done adding&#39;;

store node ( id = 3, comment = &#39;Node 3, $HOST3&#39; );
echo &#39;sored node&#39;;
store path ( server = 1, client = 3, conninfo = &#39;dbname=$DBNAME1 
host=$HOST1 port=$PORT1 user=slony password=slony_user_pass&#39; );
echo &#39;stored path&#39;;
store path ( server = 3, client = 1, conninfo = &#39;dbname=$DBNAME3 
host=$HOST3 port=$PORT2 user=slony password=slony_user_pass&#39; );

echo &#39;again&#39;;
store listen ( origin = 1, provider = 1, receiver = 3 );
store listen ( origin = 3, provider = 3, receiver = 1 );

EOF</code></pre>
<p>Новый узел имеет id 3, потому что 2 уже есть и работает. Подписываем новый узел 3 на replication set:</p>
<pre><code>#!/bin/sh

CLUSTER=customers_rep

DBNAME1=customers
DBNAME3=customers

HOST1=customers_master.com
HOST3=customers_slave3.com

PORT1=5432
PORT2=5432

SLONY_USER=slony

slonik «EOF
cluster name = $CLUSTER;
node 1 admin conninfo = &#39;dbname=$DBNAME1 host=$HOST1 
port=$PORT1 user=slony password=slony_user_pass&#39;;
node 3 admin conninfo = &#39;dbname=$DBNAME3 host=$HOST3 
port=$PORT2 user=slony password=slony_user_pass&#39;;

echo&#39;subscribing&#39;;
subscribe set ( id = 1, provider = 1, receiver = 3, forward = no);

EOF</code></pre>
<p>Теперь запускаем slon на новом узле, так же как и на остальных. Перезапускать slon на мастере не надо.</p>
<pre><code>slony@customers_slave3$ slon customers_rep \
&quot;dbname=customers user=slony&quot;</code></pre>
<p>Репликация должна начаться как обычно.</p>
<h3 id="устранение-неисправностей">Устранение неисправностей</h3>
<h4 id="ошибка-при-добавлении-узла-в-систему-репликации">Ошибка при добавлении узла в систему репликации</h4>
<p>Периодически, при добавлении новой машины в кластер возникает следующая ошибка: на новой ноде всё начинает жужжать и работать, имеющиеся же отваливаются с примерно следующей диагностикой:</p>
<pre><code>%slon customers_rep &quot;dbname=customers user=slony_user&quot;
CONFIG main: slon version 1.0.5 starting up
CONFIG main: local node id = 3
CONFIG main: loading current cluster configuration
CONFIG storeNode: no_id=1 no_comment=&#39;CustomersDB 
replication cluster&#39;
CONFIG storeNode: no_id=2 no_comment=&#39;Node 2, 
node2.example.com&#39;
CONFIG storeNode: no_id=4 no_comment=&#39;Node 4, 
node4.example.com&#39;
CONFIG storePath: pa_server=1 pa_client=3 
pa_conninfo=&quot;dbname=customers 
host=mainhost.com port=5432 user=slony_user 
password=slony_user_pass&quot; pa_connretry=10
CONFIG storeListen: li_origin=1 li_receiver=3 
li_provider=1
CONFIG storeSet: set_id=1 set_origin=1 
set_comment=&#39;CustomersDB replication set&#39;
WARN remoteWorker_wakeup: node 1 - no worker thread
CONFIG storeSubscribe: sub_set=1 sub_provider=1 sub_forward=&#39;f&#39;
WARN remoteWorker_wakeup: node 1 - no worker thread
CONFIG enableSubscription: sub_set=1
WARN remoteWorker_wakeup: node 1 - no worker thread
CONFIG main: configuration complete - starting threads
CONFIG enableNode: no_id=1
CONFIG enableNode: no_id=2
CONFIG enableNode: no_id=4
ERROR remoteWorkerThread_1: &quot;begin transaction; set 
transaction isolation level 
serializable; lock table &quot;_customers_rep&quot;.sl_config_lock; select 
&quot;_customers_rep&quot;.enableSubscription(1, 1, 4); 
notify &quot;_customers_rep_Event&quot;; notify &quot;_customers_rep_Confirm&quot;; 
insert into &quot;_customers_rep&quot;.sl_event (ev_origin, ev_seqno, 
ev_timestamp, ev_minxid, ev_maxxid, ev_xip, 
ev_type , ev_data1, ev_data2, ev_data3, ev_data4 ) values 
(&#39;1&#39;, &#39;219440&#39;, 
&#39;2005-05-05 18:52:42.708351&#39;, &#39;52501283&#39;, &#39;52501292&#39;, 
&#39;&#39;&#39;52501283&#39;&#39;&#39;, &#39;ENABLE_SUBSCRIPTION&#39;, 
&#39;1&#39;, &#39;1&#39;, &#39;4&#39;, &#39;f&#39;); insert into &quot;_customers_rep&quot;.
sl_confirm (con_origin, con_received, 
con_seqno, con_timestamp) values (1, 3, &#39;219440&#39;, 
CURRENT_TIMESTAMP); commit transaction;&quot; 
PGRES_FATAL_ERROR ERROR: insert or update on table 
&quot;sl_subscribe&quot; violates foreign key 
constraint &quot;sl_subscribe-sl_path-ref&quot;
DETAIL: Key (sub_provider,sub_receiver)=(1,4) 
is not present in table &quot;sl_path&quot;.
INFO remoteListenThread_1: disconnecting from 
&#39;dbname=customers host=mainhost.com 
port=5432 user=slony_user password=slony_user_pass&#39;
%</code></pre>
<p>Это означает что в служебной таблице _&lt;имя кластера&gt;.sl_path;, например _customers_rep.sl_path на уже имеющихся узлах отсутствует информация о новом узле. В данном случае, id нового узла 4, пара (1,4) в sl_path отсутствует.</p>
<p>Видимо, это баг Slony. Как избежать этого и последующих ручных вмешательств пока не ясно.</p>
<p>Чтобы это устранить, нужно выполнить на каждом из имеющихся узлов приблизительно следующий запрос (добавить путь, в данном случае (1,4)):</p>
<pre><code>slony_user@masterhost$ psql -d customers -h _every_one_of_slaves -U slony
customers=# insert into _customers_rep.sl_path 
values (&#39;1&#39;,&#39;4&#39;,&#39;dbname=customers host=mainhost.com 
port=5432 user=slony_user password=slony_user_password,&#39;10&#39;);</code></pre>
<p>Если возникают затруднения, да и вообще для расширения кругозора можно посмотреть на служебные таблицы и их содержимое. Они не видны обычно и находятся в рамках пространства имён _&lt;имя кластера&gt;, например _customers_rep.</p>
<h4 id="что-делать-если-репликация-со-временем-начинает-тормозить">Что делать если репликация со временем начинает тормозить</h4>
<p>В процессе эксплуатации наблюдаю как со временем растёт нагрузка на master-сервере, в списке активных бекендов — постоянные SELECT-ы со слейвов. В pg_stat_activity видим примерно такие запросы:</p>
<pre><code>select ev_origin, ev_seqno, ev_timestamp, ev_minxid, ev_maxxid, ev_xip, 
ev_type, ev_data1, ev_data2, ev_data3, ev_data4, ev_data5, ev_data6, 
ev_data7, ev_data8 from &quot;_customers_rep&quot;.sl_event e where 
(e.ev_origin = &#39;2&#39; and e.ev_seqno &gt; &#39;336996&#39;) or 
(e.ev_origin = &#39;3&#39; and e.ev_seqno &gt; &#39;1712871&#39;) or 
(e.ev_origin = &#39;4&#39; and e.ev_seqno &gt; &#39;721285&#39;) or 
(e.ev_origin = &#39;5&#39; and e.ev_seqno &gt; &#39;807715&#39;) or 
(e.ev_origin = &#39;1&#39; and e.ev_seqno &gt; &#39;3544763&#39;) or 
(e.ev_origin = &#39;6&#39; and e.ev_seqno &gt; &#39;2529445&#39;) or 
(e.ev_origin = &#39;7&#39; and e.ev_seqno &gt; &#39;2512532&#39;) or 
(e.ev_origin = &#39;8&#39; and e.ev_seqno &gt; &#39;2500418&#39;) or 
(e.ev_origin = &#39;10&#39; and e.ev_seqno &gt; &#39;1692318&#39;) 
order by e.ev_origin, e.ev_seqno;</code></pre>
<p>Не забываем что _customers_rep — имя схемы из примера, у вас будет другое имя.</p>
<p>Таблица sl_event почему-то разрастается со временем, замедляя выполнение этих запросов до неприемлемого времени. Удаляем ненужные записи:</p>
<pre><code>delete from _customers_rep.sl_event where 
ev_timestamp&lt;NOW()-&#39;1 DAY&#39;::interval;</code></pre>
<p>Производительность должна вернуться к изначальным значениям. Возможно имеет смысл почистить таблицы _customers_rep.sl_log_ где вместо звёздочки подставляются натуральные числа, по-видимому по количеству репликационных сетов, так что _customers_rep.sl_log_1 точно должна существовать.</p>
<h2 id="sec:londiste">Londiste</h2>
<h3 id="введение-6">Введение</h3>
<p>Londiste представляет собой движок для организации репликации, написанный на языке python. Основные принципы: надежность и простота использования. Из-за этого данное решение имеет меньше функциональности, чем Slony-I. Londiste использует в качестве транспортного механизма очередь PgQ (описание этого более чем интересного проекта остается за рамками данной главы, поскольку он представляет интерес скорее для низкоуровневых программистов баз данных, чем для конечных пользователей — администраторов СУБД PostgreSQL). Отличительными особенностями решения являются:</p>
<ul>
<li><p>возможность потабличной репликации</p></li>
<li><p>начальное копирование ничего не блокирует</p></li>
<li><p>возможность двухстороннего сравнения таблиц</p></li>
<li><p>простота установки</p></li>
</ul>
<p>К недостаткам можно отнести:</p>
<ul>
<li><p>отсутствие поддержки каскадной репликации, отказоустойчивости(failover) и переключение между серверами (switchover) (все это обещают к <a href="http://skytools.projects.postgresql.org/skytools-3.0/doc/skytools3.html">3 версии реализовать</a>)</p></li>
</ul>
<h3 id="установка-2">Установка</h3>
<p>На серверах, которые мы настраиваем рассматривается ОС Linux, а именно Ubuntu Server. Автор данной книги считает, что под другие операционные системы (кроме Windows) все мало чем будет отличаться, а держать кластера PostgreSQL под ОС Windows, по меньшей мере, неразумно.</p>
<p>Поскольку Londiste — это часть Skytools, то нам нужно ставить этот пакет. На таких системах, как Debian или Ubuntu skytools можно найти в репозитории пакетов и поставить одной командой:</p>
<pre><code>sudo aptitude install skytools</code></pre>
<p>Но все же лучше скачать самую последнюю версию пакета с <a href="http://pgfoundry.org/projects/skytools">официального сайта</a>. На момент написания статьи последняя версия была 2.1.11. Итак, начнем:</p>
<pre><code>$wget http://pgfoundry.org/frs/download.php/2561/skytools-2.1.11.tar.gz
$tar zxvf skytools-2.1.11.tar.gz
$cd skytools-2.1.11/
# это для сборки deb пакета
$sudo aptitude install build-essential autoconf \ 
automake autotools-dev dh-make \ 
debhelper devscripts fakeroot xutils lintian pbuilder \
python-dev yada
# ставим пакет исходников для postgresql 8.4.x
$sudo aptitude install postgresql-server-dev-8.4
# python-psycopg нужен для работы Londiste
$sudo aptitude install python-psycopg2
# данной командой я собираю deb пакет для 
# postgresql 8.4.x (для 8.3.x например будет &quot;make deb83&quot;)
$sudo make deb84
$cd ../
# ставим skytools
$dpkg -i skytools-modules-8.4_2.1.11_i386.deb 
skytools_2.1.11_i386.deb</code></pre>
<p>Для других систем можно собрать Skytools командами</p>
<pre><code>./configure
make
make install</code></pre>
<p>Дальше проверим, что все у нас правильно установилось</p>
<pre><code>$londiste.py -V
Skytools version 2.1.11
$pgqadm.py -V
Skytools version 2.1.11</code></pre>
<p>Если у Вас похожий вывод, значит все установлено правильно и можно приступать к настройке.</p>
<h3 id="настройка-2">Настройка</h3>
<p>Обозначения:</p>
<ul>
<li><p>host1 — мастер;</p></li>
<li><p>host2 — слейв;</p></li>
</ul>
<h4 id="настройка-ticker-а">Настройка ticker-а</h4>
<p>Londiste требуется ticker для работы с мастер базой данных, который может быть запущен и на другой машине. Но, конечно, лучше его запускать на той же, где и мастер база данных. Для этого мы настраиваем специальный конфиг для ticker-а (пусть конфиг будет у нас /etc/skytools/db1-ticker.ini):</p>
<pre><code># название
job_name = db1-ticker

# мастер база данных 
db = dbname=P host=host1 

# Задержка между запусками обслуживания 
# (ротация очередей и т.п.) в секундах
maint_delay = 600

# Задержка между проверками наличия активности 
# (новых пакетов данных) в секундах
loop_delay = 0.1

# log и pid демона
logfile = /var/log/%(job_name)s.log
pidfile = /var/pid/%(job_name)s.pid</code></pre>
<p>Теперь необходимо инсталлировать служебный код (SQL) и запустить ticker как демона для базы данных. Делается это с помощью утилиты pgqadm.py следующими командами:</p>
<pre><code>pgqadm.py /etc/skytools/db1-ticker.ini install
pgqadm.py /etc/skytools/db1-ticker.ini ticker -d</code></pre>
<p>Проверим, что в логах (/var/log/skytools/db1-tickers.log) всё нормально. На данном этапе там должны быть редкие записи (раз в минуту).</p>
<p>Если нам потребуется остановить ticker, мы можем воспользоваться этой командой:</p>
<pre><code>pgqadm.py /etc/skytools/db1-ticker.ini ticker -s</code></pre>
<p>или если потребуется «убить» ticker:</p>
<pre><code>pgqadm.py /etc/skytools/db1-ticker.ini ticker -k</code></pre>
<h4 id="восстанавливаем-схему-базы">Восстанавливаем схему базы</h4>
<p>Londiste не умеет переносить изменения структуры базы данных. Поэтому на всех slave базах данных перед репликацией должна быть создана такая же структура БД, что и на мастере.</p>
<h4 id="создаём-конфигурацию-репликатора">Создаём конфигурацию репликатора</h4>
<p>Для каждой из реплицируемых баз создадим конфигурационные файлы (пусть конфиг будет у нас /etc/skytools/db1-londiste.ini):</p>
<pre><code># название
job_name = db1-londiste

# мастер база данных
provider_db = dbname=db1 port=5432 host=host1
# слейв база данных
subscriber_db = dbname=db1 host=host2

# Это будет использоваться в качестве 
# SQL-идентификатора, т.ч. не используйте
# точки и пробелы.
# ВАЖНО! Если есть живая репликация на другой слейв, 
# именуем очередь так-же
pgq_queue_name = db1-londiste-queue

# log и pid демона
logfile = /var/log/%(job_name)s.log
pidfile = /var/run/%(job_name)s.pid

# рзмер лога
log_size = 5242880
log_count = 3</code></pre>
<h4 id="устанавливаем-londiste-в-базы-на-мастере-и-слейве">Устанавливаем Londiste в базы на мастере и слейве</h4>
<p>Теперь необходимо установить служебный SQL для каждой из созданных в предыдущем пункте конфигураций.</p>
<p>Устанавливаем код на стороне мастера:</p>
<pre><code>londiste.py /etc/skytools/db1-londiste.ini provider install</code></pre>
<p>и подобным образом на стороне слейва:</p>
<pre><code>londiste.py /etc/skytools/db1-londiste.ini subscriber install</code></pre>
<p>После этого пункта на мастере будут созданы очереди для репликации.</p>
<h4 id="запускаем-процессы-londiste">Запускаем процессы Londiste</h4>
<p>Для каждой реплицируемой базы делаем:</p>
<pre><code>londiste.py /etc/skytools/db1-londiste.ini replay -d</code></pre>
<p>Таким образом запустятся слушатели очередей репликации, но, т.к. мы ещё не указывали какие таблицы хотим реплицировать, они пока будут работать в холостую.</p>
<p>Убедимся что в логах нет ошибок (/var/log/db1-londistes.log).</p>
<h4 id="добавляем-реплицируемые-таблицы">Добавляем реплицируемые таблицы</h4>
<p>Для каждой конфигурации указываем что будем реплицировать с мастера:</p>
<pre><code>londiste.py /etc/skytools/db1-londiste.ini provider add --all</code></pre>
<p>и что со слейва:</p>
<pre><code>londiste.py /etc/skytools/db1-londiste.ini subscriber add --all</code></pre>
<p>В данном примере я использую спец-параметр «–all», который означает все таблицы, но вместо него вы можете перечислить список конкретных таблиц, если не хотите реплицировать все.</p>
<h4 id="добавляем-реплицируемые-последовательности-sequence">Добавляем реплицируемые последовательности (sequence)</h4>
<p>Так же для всех конфигураций. Для мастера:</p>
<pre><code>londiste.py /etc/skytools/db1-londiste.ini provider add-seq --all</code></pre>
<p>Для слейва:</p>
<pre><code>londiste.py /etc/skytools/db1-londiste.ini subscriber add-seq --all</code></pre>
<p>Точно также как и с таблицами можно указать конкретные последовательности вместо «–all».</p>
<h4 id="проверка">Проверка</h4>
<p>Итак, всё что надо сделано. Теперь Londiste запустит так называемый bulk copy процесс, который массово (с помощью COPY) зальёт присутствующие на момент добавления таблиц данные на слейв, а затем перейдёт в состояние обычной репликации.</p>
<p>Мониторим логи на предмет ошибок:</p>
<pre><code>less /var/log/db1-londiste.log</code></pre>
<p>Если всё хорошо, смотрим состояние репликации. Данные уже синхронизированы для тех таблиц, где статус отображается как “ok”.</p>
<pre><code>londiste.py /etc/skytools/db1-londiste.ini subscriber tables

   Table State
   public.table1 ok
   public.table2 ok
   public.table3 in-copy
   public.table4 -
   public.table5 -
   public.table6 -
   ...</code></pre>
<p>Для удобства представляю следующий трюк с уведомление в почту об окончании первоначального копирования (мыло поменять на своё):</p>
<pre><code>(
while [ $(
python londiste.py /etc/skytools/db1-londiste.ini subscriber tables |
tail -n+2 | awk &#39;{print $2}&#39; | grep -v ok | wc -l) -ne 0 ];
do sleep 60; done; echo &#39;&#39; | mail -s &#39;Replication done EOM&#39; user@domain.com
) &amp;</code></pre>
<h3 id="общие-задачи-2">Общие задачи</h3>
<h4 id="добавление-всех-таблиц-мастера-слейву">Добавление всех таблиц мастера слейву</h4>
<p>Просто используя эту команду:</p>
<pre><code>londiste.py &lt;ini&gt; provider tables | xargs londiste.py &lt;ini&gt; subscriber add</code></pre>
<h4 id="проверка-состояния-слейвов">Проверка состояния слейвов</h4>
<p>Этот запрос на мастере дает некоторую информацию о каждой очереди и слейве.</p>
<pre><code>SELECT queue_name, consumer_name, lag, last_seen
  FROM pgq.get_consumer_info();</code></pre>
<p>«lag» столбец показывает отставание от мастера в синхронизации, «last_seen» — время последней запроса от слейва. Значение этого столбца не должно быть больше, чем 60 секунд для конфигурации по умолчанию.</p>
<h4 id="удаление-очереди-всех-событий-из-мастера">Удаление очереди всех событий из мастера</h4>
<p>При работе с Londiste может потребоваться удалить все ваши настройки для того, чтобы начать все заново. Для PGQ, чтобы остановить накопление данных, используйте следующие API:</p>
<pre><code>SELECT pgq.unregister_consumer(&#39;queue_name&#39;, &#39;consumer_name&#39;);</code></pre>
<p>Или воспользуйтесь pgqadm.py:</p>
<pre><code>pgqadm.py &lt;ticker.ini&gt; unregister queue_name consumer_name</code></pre>
<h4 id="добавление-столбца-в-таблицу">Добавление столбца в таблицу</h4>
<p>Добавляем в следующей последовательности:</p>
<ol>
<li><p>добавить поле на все слейвы</p></li>
<li><p>BEGIN; – на мастере</p></li>
<li><p>добавить поле на мастере</p></li>
<li><p>SELECT londiste.provider_refresh_trigger(’queue_name’, ’tablename’);</p></li>
<li><p>COMMIT;</p></li>
</ol>
<h4 id="удаление-столбца-из-таблицы">Удаление столбца из таблицы</h4>
<ol>
<li><p>BEGIN; – на мастере</p></li>
<li><p>удалить поле на мастере</p></li>
<li><p>SELECT londiste.provider_refresh_trigger(’queue_name’, ’tablename’);</p></li>
<li><p>COMMIT;</p></li>
<li><p>Проверить «lag», когда londiste пройдет момент удаления поля</p></li>
<li><p>удалить поле на всех слейвах</p></li>
</ol>
<p>Хитрость тут в том, чтобы удалить поле на слейвах только тогда, когда больше нет событий в очереди на это поле.</p>
<h3 id="устранение-неисправностей-1">Устранение неисправностей</h3>
<h4 id="londiste-пожирает-процессор-и-lag-растет">Londiste пожирает процессор и lag растет</h4>
<p>Это происходит, например, если во время сбоя админ забыл перезапустить ticker. Или когда вы сделали большой UPDATE или DELETE в одной транзакции, но теперь что бы реализовать каждое событие в этом запросе создаются транзакции на слейвах …</p>
<p>Следующий запрос позволяет подсчитать, сколько событий пришло в pgq.subscription в колонках sub_last_tick и sub_next_tick.</p>
<pre><code>SELECT count(*)
  FROM pgq.event_1,
    (SELECT tick_snapshot
      FROM pgq.tick
      WHERE tick_id BETWEEN 5715138 AND 5715139
    ) as t(snapshots)
WHERE txid_visible_in_snapshot(ev_txid, snapshots);</code></pre>
<p>В нашем случае, это было более чем 5 миллионов и 400 тысяч событий. Многовато. Чем больше событий с базы данных требуется обработать Londiste, тем больше ему требуется памяти для этого. Мы можем сообщить Londiste не загружать все события сразу. Достаточно добавить в INI конфиг ticker-а следующую настройку:</p>
<pre><code>pgq_lazy_fetch = 500</code></pre>
<p>Теперь Londiste будет брать максимум 500 событий в один пакет запросов. Остальные попадут в следующие пакеты запросов.</p>
<h2 id="bucardo">Bucardo</h2>
<h3 id="введение-7">Введение</h3>
<p>Bucardo — асинхронная master-master или master-slave репликация PostgreSQL, которая написана на Perl. Система очень гибкая, поддерживает несколько видов синхронизации и обработки конфликтов.</p>
<h3 id="установка-3">Установка</h3>
<p>Установку будем проводить на Ubuntu Server. Сначала нам нужно установить DBIx::Safe Perl модуль.</p>
<pre><code>sudo aptitude install libdbix-safe-perl</code></pre>
<p>Для других систем можно поставить из исходников<a href="#fn13" class="footnoteRef" id="fnref13"><sup>13</sup></a>:</p>
<pre><code>tar xvfz DBIx-Safe-1.2.5.tar.gz
cd DBIx-Safe-1.2.5
perl Makefile.PL
make &amp;&amp; make test &amp;&amp; sudo make install</code></pre>
<p>Теперь ставим сам Bucardo. Скачиваем<a href="#fn14" class="footnoteRef" id="fnref14"><sup>14</sup></a> его и инсталлируем:</p>
<pre><code>tar xvfz Bucardo-4.4.0.tar.gz
cd Bucardo-4.4.0
perl Makefile.PL
make
sudo make install</code></pre>
<p>Для работы Bucardo потребуется установить поддержку pl/perlu языка PostgreSQL.</p>
<pre><code>sudo aptitude install postgresql-plperl-8.4</code></pre>
<p>Можем приступать к настройке.</p>
<h3 id="настройка-3">Настройка</h3>
<h4 id="инициализация-bucardo">Инициализация Bucardo</h4>
<p>Запускаем установку командой:</p>
<pre><code>bucardo_ctl install</code></pre>
<p>Bucardo покажет настройки подключения к PostgreSQL, которые можно будет изменить:</p>
<pre><code>This will install the bucardo database into an existing Postgres cluster.
Postgres must have been compiled with Perl support,
and you must connect as a superuser

We will create a new superuser named &#39;bucardo&#39;,
and make it the owner of a new database named &#39;bucardo&#39;

Current connection settings:
1. Host:          &lt;none&gt;
2. Port:          5432
3. User:          postgres
4. Database:      postgres
5. PID directory: /var/run/bucardo</code></pre>
<p>Когда вы измените требуемые настройки и подтвердите установку, Bucardo создаст пользователя bucardo и базу данных bucardo. Данный пользователь должен иметь право логиниться через Unix socket, поэтому лучше заранее дать ему такие права в pg_hda.conf.</p>
<h4 id="настройка-баз-данных">Настройка баз данных</h4>
<p>Теперь нам нужно настроить базы данных, с которыми будет работать Bucardo. Пусть у нас будет master_db и slave_db. Сначала настроим мастер:</p>
<pre><code>bucardo_ctl add db master_db name=master
bucardo_ctl add all tables herd=all_tables
bucardo_ctl add all sequences herd=all_tables</code></pre>
<p>Первой командой мы указали базу данных и дали ей имя master (для того, что в реальной жизни master_db и slave_db имеют одинаковое название и их нужно Bucardo отличать). Второй и третьей командой мы указали реплицировать все таблицы и последовательности, объеденив их в группу all_tables.</p>
<p>Дальше добавляем slave_db:</p>
<pre><code>bucardo_ctl add db slave_db name=replica port=6543 host=slave_host</code></pre>
<p>Мы назвали replica базу данных в Bucardo.</p>
<h4 id="настройка-синхронизации">Настройка синхронизации</h4>
<p>Теперь нам нужно настроить синхронизацию между этими базами данных. Делается это командой (master-slave):</p>
<pre><code>bucardo_ctl add sync delta type=pushdelta source=all_tables targetdb=replica</code></pre>
<p>Данной командой мы установим Bucardo триггеры в PostgreSQL. А теперь по параметрам:</p>
<ul>
<li><p><strong>type</strong></p>
<p>Это тип синхронизации. Существует 3 типа:</p>
<ul>
<li><p><strong>Fullcopy</strong>. Полное копирование.</p></li>
<li><p><strong>Pushdelta</strong>. Master-slave репликация.</p></li>
<li><p><strong>Swap</strong>. Master-master репликация. Для работы в таком режиме потребуется указать как Bucardo должен решать конфликты синхронизации. Для этого в таблице «goat» (в которой находятся таблицы и последовательности) нужно в «standard_conflict» поле поставить значение (это значение может быть разным для разных таблиц и последовательностей):</p>
<ul>
<li><p>source — при конфликте мы копируем данные с source (master_db в нашем случае).</p></li>
<li><p>target — при конфликте мы копируем данные с target (slave_db в нашем случае).</p></li>
<li><p>skip — конфликт мы просто не реплицируем. Не рекомендуется.</p></li>
<li><p>random — каждая БД имеет одинаковый шанс, что её изменение будет взято для решение конфликта.</p></li>
<li><p>latest — запись, которая была последней изменена решает конфликт.</p></li>
<li><p>abort — синхронизация прерывается.</p></li>
</ul></li>
</ul></li>
<li><p><strong>source</strong></p>
<p>Источник синхронизации.</p></li>
<li><p><strong>targetdb</strong></p>
<p>БД, в которум производим репликацию.</p></li>
</ul>
<p>Для master-master:</p>
<pre><code>bucardo_ctl add sync delta type=swap source=all_tables targetdb=replica</code></pre>
<h4 id="запускостановка-репликации">Запуск/Остановка репликации</h4>
<p>Запуск репликации:</p>
<pre><code>bucardo_ctl start</code></pre>
<p>Остановка репликации:</p>
<pre><code>bucardo_ctl stop</code></pre>
<h3 id="общие-задачи-3">Общие задачи</h3>
<h4 id="просмотр-значений-конфигурации">Просмотр значений конфигурации</h4>
<p>Просто используя эту команду:</p>
<pre><code>bucardo_ctl show all</code></pre>
<h4 id="изменения-значений-конфигурации">Изменения значений конфигурации</h4>
<pre><code>bucardo_ctl set name=value</code></pre>
<p>Например:</p>
<pre><code>bucardo_ctl set syslog_facility=LOG_LOCAL3</code></pre>
<h4 id="перегрузка-конфигурации">Перегрузка конфигурации</h4>
<pre><code>bucardo_ctl reload_config</code></pre>
<p>Более полный список команд — <a href="http://bucardo.org/wiki/Bucardo_ctl">bucardo.org/wiki/Bucardo_ctl</a></p>
<h2 id="rubyrep">RubyRep</h2>
<h3 id="введение-8">Введение</h3>
<p>RubyRep представляет собой движок для организации асинхронной репликации, написанный на языке ruby. Основные принципы: простота использования и не зависит от БД. Поддерживает как master-master, так и master-slave репликацию, может работать с PostgreSQL и MySQL. Отличительными особенностями решения являются:</p>
<ul>
<li><p>возможность двухстороннего сравнения и синхронизации баз данных</p></li>
<li><p>простота установки</p></li>
</ul>
<p>К недостаткам можно отнести:</p>
<ul>
<li><p>работа только с двумя базами данных для MySQL</p></li>
<li><p>медленная работа синхронизации</p></li>
<li><p>при больших объемах данных «ест» процессор и память</p></li>
</ul>
<h3 id="установка-4">Установка</h3>
<p>RubyRep поддерживает два типа установки: через стандартный Ruby или JRuby. Рекомендую ставить JRuby вариант — производительность будет выше.</p>
<p><strong>Установка JRuby версии</strong></p>
<p>Предварительно должна быть установлена Java (версия 1.6).</p>
<ol>
<li><p>Загрузите последнюю версию JRuby rubyrep c Rubyforge.</p></li>
<li><p>Распакуйте</p></li>
<li><p>Готово</p></li>
</ol>
<p><strong>Установка стандартной Ruby версии</strong></p>
<ol>
<li><p>Установить Ruby, Rubygems.</p></li>
<li><p>Установить драйвера базы данных.</p>
<p>Для Mysql:</p>
<pre><code>sudo gem install mysql</code></pre>
<p>Для PostgreSQL:</p>
<pre><code>sudo gem install postgres</code></pre></li>
<li><p>Устанавливаем rubyrep:</p>
<pre><code>sudo gem install rubyrep</code></pre></li>
</ol>
<h3 id="настройка-4">Настройка</h3>
<h4 id="создание-файла-конфигурации">Создание файла конфигурации</h4>
<p>Выполним команду:</p>
<pre><code>rubyrep generate myrubyrep.conf</code></pre>
<p>Команда generate создала пример конфигурации в файл myrubyrep.conf:</p>
<pre><code>RR::Initializer::run do |config|
config.left = {
:adapter  =&gt; &#39;postgresql&#39;, # or &#39;mysql&#39;
:database =&gt; &#39;SCOTT&#39;,
:username =&gt; &#39;scott&#39;,
:password =&gt; &#39;tiger&#39;,
:host     =&gt; &#39;172.16.1.1&#39;
}
 
config.right = {
:adapter  =&gt; &#39;postgresql&#39;,
:database =&gt; &#39;SCOTT&#39;,
:username =&gt; &#39;scott&#39;,
:password =&gt; &#39;tiger&#39;,
:host     =&gt; &#39;172.16.1.2&#39;
}
 
config.include_tables &#39;dept&#39;
config.include_tables /^e/ # regexp matches all tables starting with e
# config.include_tables /./ # regexp matches all tables
end</code></pre>
<p>В настройках просто разобраться. Базы данных делятся на «left» и «right». Через config.include_tables мы указываем какие таблицы включать в репликацию (поддерживает RegEx).</p>
<h4 id="сканирование-баз-данных">Сканирование баз данных</h4>
<p>Сканирование баз данных для поиска различий:</p>
<pre><code>rubyrep scan -c myrubyrep.conf</code></pre>
<p>Пример вывода:</p>
<pre><code>dept 100% .........................   0
emp 100% .........................   1</code></pre>
<p>Таблица dept полностью синхронизирована, а emp — имеет одну не синхронизированую запись.</p>
<h4 id="синхронизация-баз-данных">Синхронизация баз данных</h4>
<p>Выполним команду:</p>
<pre><code>rubyrep sync -c myrubyrep.conf</code></pre>
<p>Также можно указать только какие таблицы в базах данных синхронизировать:</p>
<pre><code>rubyrep sync -c myrubyrep.conf dept /^e/</code></pre>
<p>Настройки политики синхронизации позволяют указывать как решать конфликты синхронизации. Более подробно можно почитать в <a href="http://www.rubyrep.org/configuration.html">документации</a>.</p>
<h4 id="репликация-1">Репликация</h4>
<p>Для запуска репликации достаточно выполнить:</p>
<pre><code>rubyrep replicate -c myrubyrep.conf</code></pre>
<p>Данная команда установить репликацию (если она не была установлена) на базы данных и запустит её. Чтобы остановить репликацию, достаточно просто убить процесс. Даже если репликация остановлена, все изменения будут обработаны триггерами rubyrep. После перезагрузки, все изменения будут автоматически восстановлены.</p>
<p>Для удаления репликации достаточно выполнить:</p>
<pre><code>rubyrep uninstall -c myrubyrep.conf</code></pre>
<h3 id="устранение-неисправностей-2">Устранение неисправностей</h3>
<h4 id="ошибка-при-запуске-репликации">Ошибка при запуске репликации</h4>
<p>При запуске rubyrep через Ruby может возникнуть подобная ошибка:</p>
<pre><code>$rubyrep replicate -c myrubyrep.conf 
Verifying RubyRep tables
Checking for and removing rubyrep triggers from unconfigured tables
Verifying rubyrep triggers of configured tables
Starting replication
Exception caught: Thread#join: deadlock 0xb76ee1ac - mutual join(0xb758cfac)</code></pre>
<p>Это проблема с запусками потоков в Ruby. Решается двумя способами:</p>
<ol>
<li><p>Запускать rubyrep через JRuby (тут с потоками не будет проблем)</p></li>
<li><p>Пофиксить rubyrep патчем:</p>
<pre><code>--- /Library/Ruby/Gems/1.8/gems/rubyrep-1.1.2/lib/rubyrep/
replication_runner.rb 2010-07-16 15:17:16.000000000 -0400
+++ ./replication_runner.rb 2010-07-16 17:38:03.000000000 -0400
@@ -2,6 +2,12 @@
 
 require &#39;optparse&#39;
 require &#39;thread&#39;
+require &#39;monitor&#39;
+
+class Monitor
+ alias lock mon_enter
+ alias unlock mon_exit
+end
 
 module RR
   # This class implements the functionality of the &#39;replicate&#39; command.
@@ -94,7 +100,7 @@
     # Initializes the waiter thread used for replication pauses 
     # and processing
     # the process TERM signal.
     def init_waiter
- @termination_mutex = Mutex.new
+ @termination_mutex = Monitor.new
       @termination_mutex.lock
       @waiter_thread ||= Thread.new {@termination_mutex.lock; 
         self.termination_requested = true}
       %w(TERM INT).each do |signal|</code></pre></li>
</ol>
<h2 id="заключение-2">Заключение</h2>
<p>Репликация — одна из важнейших частей крупных приложений, которые работают на PostgreSQL. Она помогает распределять нагрузку на базу данных, делать фоновый бэкап одной из копий без нагрузки на центральный сервер, создавать отдельный сервер для логирования и м.д.</p>
<p>В главе было рассмотрено несколько видов репликации PostgreSQL. Нельзя четко сказать какая лучше всех. Потоковая репликация — один из самых лучших вариантов для поддержки идентичных кластеров баз данных, но доступна только с 9.0 версии PostgreSQL. Slony-I — громоздкая и сложная в настройке система, но имеющая в своем арсенале множество функций, таких как поддержка каскадной репликации, отказоустойчивости (failover) и переключение между серверами (switchover). В тоже время Londiste не обладает подобным функционалом, но компактный и прост в установке. Bucardo — система которая может быть или master-master, или master-slave репликацией, но не может обработать огромные обьекты, нет отказоустойчивости (failover) и переключения между серверами (switchover). RubyRep, как для master-master репликации, очень просто в установке и настройке, но за это ему приходится расплачиваться скоростью работы — самый медленный из всех (синхронизация больших объемов данных между таблицами).</p>
<h1 id="шардинг">Шардинг</h1>
<h2 id="введение-9">Введение</h2>
<p>Шардинг — разделение данных на уровне ресурсов. Концепция шардинга заключается в логическом разделении данных по различным ресурсам исходя из требований к нагрузке.</p>
<p>Рассмотрим пример. Пусть у нас есть приложение с регистрацией пользователей, которое позволяет писать друг другу личные сообщения. Допустим оно очень популярно и много людей им пользуются ежедневно. Естественно, что таблица с личными сообщениями будет намного больше всех остальных таблиц в базе (скажем, будет занимать 90% всех ресурсов). Зная это, мы можем подготовить для этой (только одной!) таблицы выделенный сервер помощнее, а остальные оставить на другом (послабее). Теперь мы можем идеально подстроить сервер для работы с одной специфической таблицей, постараться уместить ее в память, возможно, дополнительно партиционировать ее и т.д. Такое распределение называется вертикальным шардингом.</p>
<p>Что делать, если наша таблица с сообщениями стала настолько большой, что даже выделенный сервер под нее одну уже не спасает. Необходимо делать горизонтальный шардинг — т.е. разделение одной таблицы по разным ресурсам. Как это выглядит на практике? Все просто. На разных серверах у нас будет таблица с одинаковой структурой, но разными данными. Для нашего случая с сообщениями, мы можем хранить первые 10 миллионов сообщений на одном сервере, вторые 10 - на втором и т.д. Т.е. необходимо иметь критерий шардинга — какой-то параметр, который позволит определять, на каком именно сервере лежат те или иные данные.</p>
<p>Обычно, в качестве параметра шардинга выбирают ID пользователя (user_id) — это позволяет делить данные по серверам равномерно и просто. Т.о. при получении личных сообщений пользователей алгоритм работы будет такой:</p>
<ul>
<li><p>Определить, на каком сервере БД лежат сообщения пользователя исходя из user_id</p></li>
<li><p>Инициализировать соединение с этим сервером</p></li>
<li><p>Выбрать сообщения</p></li>
</ul>
<p>Задачу определения конкретного сервера можно решать двумя путями:</p>
<ul>
<li><p>Хранить в одном месте хеш-таблицу с соответствиями «пользователь=сервер». Тогда, при определении сервера, нужно будет выбрать сервер из этой таблицы. В этом случае узкое место — это большая таблица соответствия, которую нужно хранить в одном месте. Для таких целей очень хорошо подходят базы данных «ключ=значение»</p></li>
<li><p>Определять имя сервера с помощью числового (буквенного) преобразования. Например, можно вычислять номер сервера, как остаток от деления на определенное число (количество серверов, между которыми Вы делите таблицу). В этом случае узкое место — это проблема добавления новых серверов — Вам придется делать перераспределение данных между новым количеством серверов.</p></li>
</ul>
<p>Для шардинга не существует решения на уровне известных платформ, т.к. это весьма специфическая для отдельно взятого приложения задача.</p>
<p>Естественно, делая горизонтальный шардинг, Вы ограничиваете себя в возможности выборок, которые требуют пересмотра всей таблицы (например, последние посты в блогах людей будет достать невозможно, если таблица постов шардится). Такие задачи придется решать другими подходами. Например, для описанного примера, можно при появлении нового поста, заносить его ID в общий стек, размером в 100 элементом.</p>
<p>Горизонтальный шардинг имеет одно явное преимущество — он бесконечно масштабируем. Для создания шардинга PostgreSQL существует несколько решений:</p>
<ul>
<li><p><a href="http://postgres-xc.sourceforge.net/">Postgres-XC</a></p></li>
<li><p><a href="http://plproxy.projects.postgresql.org/doc/tutorial.html">PL/Proxy</a></p></li>
<li><p><a href="http://db.cs.yale.edu/hadoopdb/hadoopdb.html">HadoopDB (Shared-nothing clustering)</a></p></li>
<li><p><a href="http://www.greenplum.com/products/greenplum-database">Greenplum Database</a></p></li>
</ul>
<h2 id="sec:plproxy">PL/Proxy</h2>
<p>PL/Proxy представляет собой прокси-язык для удаленного вызова процедур и партицирования данных между разными базами. Основная идея его использования заключается в том, что появляется возможность вызывать функции, расположенные в удаленных базах, а также свободно работать с кластером баз данных (например, вызвать функцию на всех узлах кластера, или на случайном узле, или на каком-то одном определенном).</p>
<p>Чем PL/Proxy может быть полезен? Он существенно упрощает горизонтальное масштабирование системы. Становится удобным разделять таблицу с пользователями, например, по первой латинской букве имени — на 26 узлов. При этом приложение, которое работает непосредственно с прокси-базой, ничего не будет замечать: запрос на авторизацию, например, сам будет направлен прокси-сервером на нужный узел. То есть администратор баз данных может проводить масштабирование системы практически независимо от разработчиков приложения.</p>
<p>PL/Proxy позволяет полностью решить проблемы масштабирования OLTP систем. В систему легко вводится резервирование с failover-ом не только по узлам, но и по самим прокси-серверам, каждый из которых работает со всеми узлами.</p>
<p>Недостатки и ограничения:</p>
<ul>
<li><p>все запросы и вызовы функций вызываются в autocommit-режиме на удаленных серверах</p></li>
<li><p>в теле функции разрешен только один SELECT; при необходимости нужно писать отдельную процедуру</p></li>
<li><p>при каждом вызове прокси-сервер стартует новое соединение к бакенд-серверу; в высоконагруженных системах целесообразно использовать менеджер для кеширования соединений к бакенд-серверам, для этой цели идеально подходит PgBouncer</p></li>
<li><p>изменение конфигурации кластера (количества партиций, например) требует перезапуска прокси-сервера</p></li>
</ul>
<h3 id="установка-5">Установка</h3>
<ol>
<li><p>Скачать PL/Proxy<a href="#fn15" class="footnoteRef" id="fnref15"><sup>15</sup></a> и распаковать.</p></li>
<li><p>Собрать PL/Proxy командами make и make install.</p></li>
</ol>
<p>Так же можно установить PL/Proxy из репозитория пакетов. Например в Ubuntu Server достаточно выполнить команду для PostgreSQL 8.4:</p>
<pre><code>sudo aptitude install postgresql-8.4-plproxy</code></pre>
<h3 id="настройка-5">Настройка</h3>
<p>Для примера настройки используется 3 сервера PostgreSQL. 2 сервера пусть будут node1 и node2, а главный, что будет проксировать запросы на два других — proxy. Для корректной работы pl/proxy рекомендуется использовать количество нод равное степеням двойки. База данных будет называтся plproxytest, а таблица в ней — users. Начнем!</p>
<p>Для начала настроим node1 и node2. Команды написанные ниже нужно выполнять на каждой ноде.</p>
<p>Создадим базу данных plproxytest(если её ещё нет):</p>
<pre><code>CREATE DATABASE plproxytest
     WITH OWNER = postgres
       ENCODING = &#39;UTF8&#39;;</code></pre>
<p>Добавляем табличку users:</p>
<pre><code>CREATE TABLE public.users
  (
   username character varying(255),
   email character varying(255)
  )
  WITH (OIDS=FALSE);
ALTER TABLE public.users OWNER TO postgres;</code></pre>
<p>Теперь создадим функцию для добавления данных в таблицу users:</p>
<pre><code>CREATE OR REPLACE FUNCTION public.insert_user(i_username text, 
i_emailaddress   text)
RETURNS integer AS
$BODY$
INSERT INTO public.users (username, email) VALUES ($1,$2);
    SELECT 1;
$BODY$
  LANGUAGE &#39;sql&#39; VOLATILE;
ALTER FUNCTION public.insert_user(text, text) OWNER TO postgres;</code></pre>
<p>С настройкой нодов закончено. Приступим к серверу proxy.</p>
<p>Как и на всех нодах, на главном сервере (proxy) должна присутствовать база данных:</p>
<pre><code>CREATE DATABASE plproxytest
     WITH OWNER = postgres
       ENCODING = &#39;UTF8&#39;;</code></pre>
<p>Теперь надо указать серверу что эта база данных управляется с помощью pl/proxy:</p>
<pre><code>CREATE OR REPLACE FUNCTION public.plproxy_call_handler()
  RETURNS language_handler AS
&#39;$libdir/plproxy&#39;, &#39;plproxy_call_handler&#39;
  LANGUAGE &#39;c&#39; VOLATILE
COST 1;
ALTER FUNCTION public.plproxy_call_handler() 
OWNER TO postgres;
-- language
CREATE LANGUAGE plproxy HANDLER plproxy_call_handler;
CREATE LANGUAGE plpgsql;</code></pre>
<p>Также, для того что бы сервер знал где и какие ноды у него есть, надо создать 3 сервисные функции, которые pl/proxy будет использовать в своей работе. Первая функция — конфиг для кластера баз данных. Тут указываются параметры через key-value:</p>
<pre><code>CREATE OR REPLACE FUNCTION public.get_cluster_config
(IN cluster_name text,   OUT &quot;key&quot; text, OUT val text)
  RETURNS SETOF record AS
$BODY$
BEGIN
  -- lets use same config for all clusters
  key := &#39;connection_lifetime&#39;;
  val := 30*60; -- 30m
  RETURN NEXT;
  RETURN;
END;
$BODY$
  LANGUAGE &#39;plpgsql&#39; VOLATILE
  COST 100
  ROWS 1000;
ALTER FUNCTION public.get_cluster_config(text) 
OWNER TO postgres;  </code></pre>
<p>Вторая важная функция, код которой надо будет подправить. В ней надо будет указать DSN нод:</p>
<pre><code>CREATE OR REPLACE FUNCTION 
public.get_cluster_partitions(cluster_name text)
  RETURNS SETOF text AS
$BODY$
BEGIN
  IF cluster_name = &#39;usercluster&#39; THEN
    RETURN NEXT &#39;dbname=plproxytest host=node1 user=postgres&#39;;
    RETURN NEXT &#39;dbname=plproxytest host=node2 user=postgres&#39;;
    RETURN;
  END IF;
  RAISE EXCEPTION &#39;Unknown cluster&#39;;
END;
$BODY$
  LANGUAGE &#39;plpgsql&#39; VOLATILE
  COST 100
  ROWS 1000;
ALTER FUNCTION public.get_cluster_partitions(text) 
OWNER TO postgres;</code></pre>
<p>И последняя:</p>
<pre><code>CREATE OR REPLACE FUNCTION 
public.get_cluster_version(cluster_name text)
  RETURNS integer AS
$BODY$
BEGIN
  IF cluster_name = &#39;usercluster&#39; THEN
    RETURN 1;
  END IF;
  RAISE EXCEPTION &#39;Unknown cluster&#39;;
END;
$BODY$
  LANGUAGE &#39;plpgsql&#39; VOLATILE
  COST 100;
ALTER FUNCTION public.get_cluster_version(text) 
OWNER TO postgres;</code></pre>
<p>Ну и собственно самая главная функция, которая будет вызываться уже непосредственно в приложении:</p>
<pre><code>CREATE OR REPLACE FUNCTION 
public.insert_user(i_username text, i_emailaddress text)
  RETURNS integer AS
$BODY$
  CLUSTER &#39;usercluster&#39;;
  RUN ON hashtext(i_username);
$BODY$
  LANGUAGE &#39;plproxy&#39; VOLATILE
  COST 100;
ALTER FUNCTION public.insert_user(text, text) 
OWNER TO postgres;</code></pre>
<p>Все готово. Подключаемся к серверу proxy и заносим данные в базу:</p>
<pre><code>SELECT insert_user(&#39;Sven&#39;,&#39;sven@somewhere.com&#39;);
SELECT insert_user(&#39;Marko&#39;, &#39;marko@somewhere.com&#39;);
SELECT insert_user(&#39;Steve&#39;,&#39;steve@somewhere.com&#39;);</code></pre>
<p>Пробуем извлечь данные. Для этого напишем новую серверную функцию:</p>
<pre><code>CREATE OR REPLACE FUNCTION 
public.get_user_email(i_username text)
 RETURNS SETOF text AS
$BODY$
 CLUSTER &#39;usercluster&#39;;
 RUN ON hashtext(i_username) ;
 SELECT email FROM public.users 
 WHERE username = i_username;
$BODY$
 LANGUAGE &#39;plproxy&#39; VOLATILE
 COST 100
 ROWS 1000;
ALTER FUNCTION public.get_user_email(text) 
OWNER TO postgres;</code></pre>
<p>И попробуем её вызвать:</p>
<pre><code>select plproxy.get_user_email(&#39;Steve&#39;);</code></pre>
<p>Если потом подключиться к каждой ноде отдельно, то можно четко увидеть, что данные users разбросаны по таблицам каждой ноды.</p>
<h3 id="все-ли-так-просто">Все ли так просто?</h3>
<p>Как видно на тестовом примере ничего сложного в работе с pl/proxy нет. Но, я думаю все кто смог дочитать до этой строчки уже поняли что в реальной жизни все не так просто. Представьте что у вас 16 нод. Это же надо как-то синхронизировать код функций. А что если ошибка закрадётся — как её оперативно исправлять?</p>
<p>Этот вопрос был задан и на конференции Highload++ 2008, на что Аско Ойя ответил что соответствующие средства уже реализованы внутри самого Skype, но ещё не достаточно готовы для того что бы отдавать их на суд сообществу opensource.</p>
<p>Второй проблема, которая не дай бог коснётся вас при разработке такого рода системы, это проблема перераспределения данных в тот момент когда нам захочется добавить ещё нод в кластер. Планировать эту масштабную операцию придётся очень тщательно, подготовив все сервера заранее, занеся данные и потом в один момент подменив код функции get_cluster_partitions.</p>
<h2 id="sec:postgres-xc">Postgres-XC</h2>
<p>Postgres-XC – система для создания мульти-мастер кластеров, работающих в синхронном режиме – все узлы всегда содержат актуальные данные. Postgres-XC поддерживает опции для увеличения масштабирования кластера как при преобладании операций записи, так и при основной нагрузке на чтение данных: поддерживается выполнение транзакций с распараллеливанием на несколько узлов, за целостностью транзакций в пределах всего кластера отвечает специальный узел GTM (Global Transaction Manager).</p>
<p>Измерение производительности показало, что КПД кластера Postgres-XC составляет примерно 64%, т.е. кластер из 10 серверов позволяет добиться увеличения производительности системы в целом в 6.4 раза, относительно производительности одного сервера (цифры приблизительные).</p>
<p>Система не использует в своей работе триггеры и представляет собой набор дополнений и патчей к PostgreSQL, дающих возможность в прозрачном режиме обеспечить работу в кластере стандартных приложений, без их дополнительной модификации и адаптации (полная совместимость с PostgreSQL API). Кластер состоит из одного управляющего узла (GTM), предоставляющего информацию о состоянии транзакций, и произвольного набора рабочих узлов, каждый из которых в свою очередь состоит из координатора и обработчика данных (обычно эти элементы реализуются на одном сервере, но могут быть и разделены).</p>
<p>Хоть Postgres-XC и выглядит похожим на MultiMaster, но он им не является. Все сервера кластера должны быть соединены сетью с минимальными задержками, никакое географически-распределенное решение с разумной производительностью построить на нем невозможно (это важный момент).</p>
<h3 id="архитектура">Архитектура</h3>
<p>[fig:postgres-xc1]</p>
<p>Рис. [fig:postgres-xc1] показывает архитектуру Postgres-XC с тремя её основными компонентами:</p>
<ol>
<li><p>Глобальный менеджер транзакций (GTM) — собирает и обрабатывает информацию о транзакциях в Postgres-XC, решает вопросы глобального идентификатора транзакции по операциям (для поддержания согласованного представления базы данных на всех узлах). Он обеспечивает поддержку других глобальных данных, таких как последовательности и временные метки. Он хранит данные пользователя, за исключением управляющей информации.</p></li>
<li><p>Координаторы (coordinators) — обеспечивают точку подключения для клиента (приложения). Они несут ответственность за разбор и выполнение запросов от клиентов и возвращение результатов (при необходимости). Они не хранят пользовательские данные, а собирают их из обработчиков данных (datanodes) с помощью запросов SQL через PostgreSQL интерфейс. Координаторы также обрабатывают данные, если требуется, и даже управляют двухфазной фиксацией. Координаторы используются также для разбора запросов, составления планов запросов, поиска данных и т.д.</p></li>
<li><p>Обработчики данных (datanodes) — обеспечивают сохранение пользовательских данных. Datanodes выполняют запросы от координаторов и возвращают им полученный результат.</p></li>
</ol>
<h3 id="установка-6">Установка</h3>
<p>Установить Postgres-XC можно из <a href="http://postgres-xc.sourceforge.net/docs/1_0/install-short.html">исходников</a> или же из пакетов системы. Например в Ubuntu 12.10 можно установить postgres-xc так:</p>
<pre><code>sudo apt-get install postgres-xc postgres-xc-client postgres-xc-contrib postgres-xc-server-dev</code></pre>
<p>По умолчанию он создаст один координатор и два обработчика данных.</p>
<h3 id="распределение-данных-и-масштабируемость">Распределение данных и масштабируемость</h3>
<p>Postgres-XC предусматривает два способа хранения данных в таблицах:</p>
<p>[fig:postgres-xc2]</p>
<p>[fig:postgres-xc3]</p>
<ol>
<li><p>Распределенные таблицы (distributed tables, рис. [fig:postgres-xc2]): данные по таблице распределяются на указанный набор обработчиков данных с использованием указанной стратегии (hash, round-robin, modulo). Каждая запись в таблице находится только на одном обработчике данных. Параллельно могут быть записаны или прочитаны данные с различных обработчиков данных. За счет этого значительно улучшена производительность на запись и чтение.</p></li>
<li><p>Реплицированные таблицы (replicated tables, рис. [fig:postgres-xc3]): данные по таблице реплицируется (клонируются) на указанный набор обработчиков данных. Каждая запись в таблице находится на всех обработчиках данных (которые были указаны) и любые изменения дублируются на все обработчики данных. Так как все данные доступны на любом обработчике данных, координатор может собрать все данные из одного узла, что позволяет направить различные запросы на различные обработчики данных. Таким образом создается балансировка нагрузки и увеличения пропускной способности на чтение.</p></li>
</ol>
<h3 id="таблицы-и-запросы-к-ним">Таблицы и запросы к ним</h3>
<p>После установки работа с Postgres-XC ведется как с обыкновенным PostgreSQL. Подключаться для работы с данными нужно только к координаторам (по умолчанию координатор работает на порту 5432). Для начала создадим распределенные таблицы.</p>
<pre><code>CREATE TABLE 
users_with_hash (id SERIAL, type INT, ...) 
DISTRIBUTE by HASH(id) TO NODE dn1, dn2;

CREATE TABLE 
users_with_modulo (id SERIAL, type INT, ...) 
DISTRIBUTE by MODULO(id) TO NODE dn1, dn2;

CREATE TABLE 
users_with_rrobin (id SERIAL, type INT, ...) 
DISTRIBUTE by ROUND ROBIN TO NODE dn1, dn2;</code></pre>
<p>На листинге [lst:postgres-xc2] создано 3 распределенные таблицы:</p>
<ol>
<li><p>Таблица «users_with_hash» распределяется по хешу значения из указанного поля в таблице (тут указано поле id) по обработчикам данных. Вот как распределились первые 15 значений:</p>
<pre><code># координатор
$ psql
# SELECT id, type from users_with_hash ORDER BY id;
 id   | type  
-------+-------
     1 |   946
     2 |   153
     3 |   484
     4 |   422
     5 |   785
     6 |   906
     7 |   973
     8 |   699
     9 |   434
    10 |   986
    11 |   135
    12 |  1012
    13 |   395
    14 |   667
    15 |   324

# первый обработчик данных
$ psql -p15432
# SELECT id, type from users_with_hash ORDER BY id;
  id  | type  
------+-------
    1 |   946
    2 |   153
    5 |   785
    6 |   906
    8 |   699
    9 |   434
   12 |  1012
   13 |   395
   15 |   324

# второй обработчик данных
$ psql -p15433 
# SELECT id, type from users_with_hash ORDER BY id;
 id   | type  
-------+-------
     3 |   484
     4 |   422
     7 |   973
    10 |   986
    11 |   135
    14 |   667</code></pre></li>
<li><p>Таблица «users_with_modulo» распределяется по модулю значения из указанного поля в таблице (тут указано поле id) по обработчикам данных. Вот как распределились первые 15 значений:</p>
<pre><code># координатор
$ psql
# SELECT id, type from users_with_modulo ORDER BY id;
 id   | type  
-------+-------
     1 |   883
     2 |   719
     3 |    29
     4 |   638
     5 |   363
     6 |   946
     7 |   440
     8 |   331
     9 |   884
    10 |   199
    11 |    78
    12 |   791
    13 |   345
    14 |   476
    15 |   860

# первый обработчик данных
$ psql -p15432
# SELECT id, type from users_with_modulo ORDER BY id;
  id   | type  
-------+-------
     2 |   719
     4 |   638
     6 |   946
     8 |   331
    10 |   199
    12 |   791
    14 |   476

# второй обработчик данных
$ psql -p15433 
# SELECT id, type from users_with_modulo ORDER BY id;
  id  | type  
------+-------
    1 |   883
    3 |    29
    5 |   363
    7 |   440
    9 |   884
   11 |    78
   13 |   345
   15 |   860</code></pre></li>
<li><p>Таблица «users_with_rrobin» распределяется циклическим способом(round-robin) по обработчикам данных. Вот как распределились первые 15 значений:</p>
<pre><code># координатор
$ psql
# SELECT id, type from users_with_rrobin ORDER BY id;
 id   | type  
-------+-------
     1 |   890
     2 |   198
     3 |   815
     4 |   446
     5 |    61
     6 |   337
     7 |   948
     8 |   446
     9 |   796
    10 |   422
    11 |   242
    12 |   795
    13 |   314
    14 |   240
    15 |   733

# первый обработчик данных
$ psql -p15432
# SELECT id, type from users_with_rrobin ORDER BY id;
  id   | type  
-------+-------
     2 |   198
     4 |   446
     6 |   337
     8 |   446
    10 |   422
    12 |   795
    14 |   240

# второй обработчик данных
$ psql -p15433 
# SELECT id, type from users_with_rrobin ORDER BY id;
  id  | type  
------+-------
    1 |   890
    3 |   815
    5 |    61
    7 |   948
    9 |   796
   11 |   242
   13 |   314
   15 |   733</code></pre></li>
</ol>
<p>Теперь создадим реплицированную таблицу:</p>
<pre><code>CREATE TABLE 
users_replicated (id SERIAL, type INT, ...) 
DISTRIBUTE by REPLICATION TO NODE dn1, dn2;</code></pre>
<p>Естественно данные идентичны на всех обработчиках данных:</p>
<pre><code># SELECT id, type from users_replicated  ORDER BY id;
  id   | type  
-------+-------
     1 |    75
     2 |   262
     3 |   458
     4 |   779
     5 |   357
     6 |    51
     7 |   249
     8 |   444
     9 |   890
    10 |   810
    11 |   809
    12 |   166
    13 |   605
    14 |   401
    15 |    58</code></pre>
<p>Рассмотрим как выполняются запросы для таблиц. Выберем все записи из распределенной таблицы:</p>
<pre><code># EXPLAIN VERBOSE SELECT * from users_with_modulo ORDER BY id;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Sort  (cost=49.83..52.33 rows=1000 width=8)
   Output: id, type
   Sort Key: users_with_modulo.id
   -&gt;  Result  (cost=0.00..0.00 rows=1000 width=8)
         Output: id, type
         -&gt;  Data Node Scan on users_with_modulo  (cost=0.00..0.00 rows=1000 width=8)
               Output: id, type
               Node/s: dn1, dn2
               Remote query: SELECT id, type FROM ONLY users_with_modulo WHERE true
(9 rows)</code></pre>
<p>Как видно на листинге [lst:postgres-xc6] координатор собирает данные из обработчиков данных, а потом собирает их вместе.</p>
<p>Подсчет суммы с группировкой по полю из распределенной таблицы:</p>
<pre><code># EXPLAIN VERBOSE SELECT sum(id) from users_with_modulo GROUP BY type;
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 HashAggregate  (cost=5.00..5.01 rows=1 width=8)
   Output: pg_catalog.sum((sum(users_with_modulo.id))), users_with_modulo.type
   -&gt;  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (sum(users_with_modulo.id)), users_with_modulo.type
         -&gt;  Data Node Scan on &quot;__REMOTE_GROUP_QUERY__&quot;  (cost=0.00..0.00 rows=1000 width=8)
               Output: sum(users_with_modulo.id), users_with_modulo.type
               Node/s: dn1, dn2
               Remote query: SELECT sum(group_1.id), group_1.type  FROM (SELECT id, type FROM ONLY users_with_modulo WHERE true) group_1 GROUP BY 2  
(8 rows)</code></pre>
<p>JOIN между и с участием реплицированных таблиц, а также JOIN между распределенными по одному и тому же полю в таблицах будет выполняются на обработчиках данных. Но JOIN с участием распределенных таблиц по другим ключам будут выполнены на координаторе и скорее всего это будет медленно (листинг [lst:postgres-xc8]).</p>
<pre><code># EXPLAIN VERBOSE SELECT * from users_with_modulo, users_with_hash WHERE users_with_modulo.id = users_with_hash.id;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Nested Loop  (cost=0.00..0.01 rows=1 width=16)
   Output: users_with_modulo.id, users_with_modulo.type, users_with_hash.id, users_with_hash.type
   Join Filter: (users_with_modulo.id = users_with_hash.id)
   -&gt;  Data Node Scan on users_with_modulo  (cost=0.00..0.00 rows=1000 width=8)
         Output: users_with_modulo.id, users_with_modulo.type
         Node/s: dn1, dn2
         Remote query: SELECT id, type FROM ONLY users_with_modulo WHERE true
   -&gt;  Data Node Scan on users_with_hash  (cost=0.00..0.00 rows=1000 width=8)
         Output: users_with_hash.id, users_with_hash.type
         Node/s: dn1, dn2
         Remote query: SELECT id, type FROM ONLY users_with_hash WHERE true
(11 rows)</code></pre>
<p>Пример выборки данных из реплицированной таблицы:</p>
<pre><code># EXPLAIN VERBOSE SELECT * from users_replicated;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Data Node Scan on &quot;__REMOTE_FQS_QUERY__&quot;  (cost=0.00..0.00 rows=0 width=0)
   Output: users_replicated.id, users_replicated.type
   Node/s: dn1
   Remote query: SELECT id, type FROM users_replicated
(4 rows)</code></pre>
<p>Как видно из запроса для выборки данных используется один обработчик данных, а не все (что и логично).</p>
<h3 id="высокая-доступность-ha">Высокая доступность (HA)</h3>
<p>По архитектуре у Postgres-XC всегда есть согласованность данных. По теореме CAP<a href="#fn16" class="footnoteRef" id="fnref16"><sup>16</sup></a> в такой системе тяжело обеспечить высокую доступность. Для достижения высокой доступности в распределенных системах требуется избыточность данных, резервные копии и автоматическое восстановление. В Postgres-XC избыточность данных может быть достигнута с помощью PostgreSQL потоковой (streaming) репликации с hot-standby для обработчиков данных. Каждый координатор способен записывать и читать данные независимо от другого, поэтому координаторы способны заменять друг друга. Поскольку GTM отдельный процесс и может стать точкой отказа, лучше создать GTM-standby как резервную копию. Ну а вот для автоматического восстановления придется использовать сторонние утилиты.</p>
<h3 id="ограничения">Ограничения</h3>
<ol>
<li><p>Postgres-XC базируется на PostgreSQL 9.1 (9.2 в разработке)</p></li>
<li><p>Нет системы репартиционирования при добавлении или удалении нод (в разработке)</p></li>
<li><p>Нет глобальных UNIQUE на распределенных таблицах</p></li>
<li><p>Не поддерживаются foreign keys между нодами поскольку такой ключ должен вести на данные расположенные на том же обработчике данных</p></li>
<li><p>Не поддерживаются курсоры (в разработке)</p></li>
<li><p>Не поддерживается INSERT …RETURNING (в разработке)</p></li>
<li><p>Невозможно удаление и добавление нод в кластер без полной реинициализации кластера (в разработке)</p></li>
</ol>
<h3 id="заключение-3">Заключение</h3>
<p>Postgres-XC очень перспективное решение для создание кластера на основе PostgreSQL. И хоть это решение имеет ряд недостатков, нестабильно (очень часты случаи падения координаторов при тяжелых запросах) и еще очень молодое, со временем это решение может стать стандартом для масштабирования систем на PostgreSQL.</p>
<h2 id="hadoopdb">HadoopDB</h2>
<p>Hadoop представляет собой платформу для построения приложений, способных обрабатывать огромные объемы данных. Система основывается на распределенном подходе к вычислениям и хранению информации, основными ее особенностями являются:</p>
<ul>
<li><p><strong>Масштабируемость:</strong> с помощью Hadoop возможно надежное хранение и обработка огромных объемов данных, которые могут измеряться петабайтами;</p></li>
<li><p><strong>Экономичность:</strong> информация и вычисления распределяются по кластеру, построенному на самом обыкновенном оборудовании. Такой кластер может состоять из тысяч узлов;</p></li>
<li><p><strong>Эффективность:</strong> распределение данных позволяет выполнять их обработку параллельно на множестве компьютеров, что существенно ускоряет этот процесс;</p></li>
<li><p><strong>Надежность:</strong> при хранении данных возможно предоставление избыточности, благодаря хранению нескольких копий. Такой подход позволяет гарантировать отсутствие потерь информации в случае сбоев в работе системы;</p></li>
<li><p><strong>Кроссплатформенность:</strong> так как основным языком программирования, используемым в этой системе является Java, развернуть ее можно на базе любой операционной системы, имеющей JVM.</p></li>
</ul>
<p><strong>HDFS</strong></p>
<p>В основе всей системы лежит распределенная файловая система под незамысловатым названием Hadoop Distributed File System. Представляет она собой вполне стандартную распределенную файловую систему, но все же она обладает рядом особенностей:</p>
<ul>
<li><p>Устойчивость к сбоям, разработчики рассматривали сбои в оборудовании скорее как норму, чем как исключение;</p></li>
<li><p>Приспособленность к развертке на самом обыкновенном ненадежном оборудовании;</p></li>
<li><p>Предоставление высокоскоростного потокового доступа ко всем данным;</p></li>
<li><p>Настроена для работы с большими файлами и наборами файлов;</p></li>
<li><p>Простая модель работы с данными: один раз записали — много раз прочли;</p></li>
<li><p>Следование принципу: переместить вычисления проще, чем переместить данные;</p></li>
</ul>
<p><strong>Архитектура HDFS</strong></p>
<p>[fig:hdfsarchitecture]</p>
<ul>
<li><p><strong>Namenode</strong></p>
<p>Этот компонент системы осуществляет всю работу с метаданными. Он должен быть запущен только на одном компьютере в кластере. Именно он управляет размещением информации и доступом ко всем данным, расположенным на ресурсах кластера. Сами данные проходят с остальных машин кластера к клиенту мимо него.</p></li>
<li><p><strong>Datanode</strong></p>
<p>На всех остальных компьютерах системы работает именно этот компонент. Он располагает сами блоки данных в локальной файловой системе для последующей передачи или обработки их по запросу клиента. Группы узлов данных принято называть Rack, они используются, например, в схемах репликации данных.</p></li>
<li><p><strong>Клиент</strong></p>
<p>Просто приложение или пользователь, работающий с файловой системой. В его роли может выступать практически что угодно.</p></li>
</ul>
<p>Пространство имен HDFS имеет классическую иерархическую структуру: пользователи и приложения имеют возможность создавать директории и файлы. Файлы хранятся в виде блоков данных произвольной (но одинаковой, за исключением последнего; по умолчанию 64 mb) длины, размещенных на Datanode’ах. Для обеспечения отказоустойчивости блоки хранятся в нескольких экземплярах на разных узлах, имеется возможность настройки количества копий и алгоритма их распределения по системе. Удаление файлов происходит не сразу, а через какое-то время после соответствующего запроса, так как после получения запроса файл перемещается в директорию /trash и хранится там определенный период времени на случай если пользователь или приложение передумают о своем решении. В этом случае информацию можно будет восстановить, в противном случае — физически удалить.</p>
<p>Для обнаружения возникновения каких-либо неисправностей, Datanode периодически отправляют Namenode’у сигналы о своей работоспособности. При прекращении получения таких сигналов от одного из узлов Namenode помечает его как «мертвый», и прекращает какое-либо с ним взаимодействие до возвращения его работоспособности. Данные, хранившиеся на «умершем» узле реплицируются дополнительный раз из оставшихся «в живых» копий и система продолжает свое функционирование как ни в чем не бывало.</p>
<p>Все коммуникации между компонентами файловой системы проходят по специальным протоколам, основывающимся на стандартном TCP/IP. Клиенты работают с Namenode с помощью так называемого ClientProtocol, а передача данных происходит по DatanodeProtocol, оба они обернуты в Remote Procedure Call (RPC).</p>
<p>Система предоставляет несколько интерфейсов, среди которых командная оболочка DFSShell, набор ПО для администрирования DFSAdmin, а также простой, но эффективный веб-интерфейс. Помимо этого существуют несколько API для языков программирования: Java API, C pipeline, WebDAV и так далее.</p>
<p><strong>MapReduce</strong></p>
<p>Помимо файловой системы, Hadoop включает в себя framework для проведения масштабных вычислений, обрабатывающих огромные объемы данных. Каждое такое вычисление называется Job (задание) и состоит оно, как видно из названия, из двух этапов:</p>
<ul>
<li><p><strong>Map</strong></p>
<p>Целью этого этапа является представление произвольных данных (на практике чаще всего просто пары ключ-значение) в виде промежуточных пар ключ-значение. Результаты сортируются и групируются по ключу и передаются на следующий этап.</p></li>
<li><p><strong>Reduce</strong></p>
<p>Полученные после map значения используются для финального вычисления требуемых данных. Практические любые данные могут быть получены таким образом, все зависит от требований и функционала приложения.</p></li>
</ul>
<p>Задания выполняются, подобно файловой системе, на всех машинах в кластере (чаще всего одних и тех же). Одна из них выполняет роль управления работой остальных — JobTracker, остальные же ее бесприкословно слушаются — TaskTracker. В задачи JobTracker’а входит составление расписания выполняемых работ, наблюдение за ходом выполнения, и перераспределение в случае возникновения сбоев.</p>
<p>В общем случае каждое приложение, работающее с этим framework’ом, предоставляет методы для осуществления этапов map и reduce, а также указывает расположения входных и выходных данных. После получения этих данных JobTracker распределяет задание между остальными машинами и предоставляет клиенту полную информацию о ходе работ.</p>
<p>Помимо основных вычислений могут выполняться вспомогательные процессы, такие как составление отчетов о ходе работы, кэширование, сортировка и так далее.</p>
<p><strong>HBase</strong></p>
<p>В рамках Hadoop доступна еще и система хранения данных, которую правда сложно назвать СУБД в традиционном смысле этого слова. Чаще проводят аналогии с проприетарной системой этого же плана от Google — BigTable.</p>
<p>HBase представляет собой распределенную систему хранения больших объемов данных. Подобно реляционным СУБД данные хранятся в виде таблиц, состоящих из строк и столбцов. И даже для доступа к ним предоставляется язык запросов HQL (как ни странно — Hadoop Query Language), отдаленно напоминающий более распространенный SQL. Помимо этого предоставляется итерирующий интерфейс для сканирования наборов строк.</p>
<p>Одной из основных особенностей хранения данных в HBase является возможность наличия нескольких значений, соответствующих одной комбинации таблица-строка-столбец, для их различения используется информация о времени добавления записи. На концептуальном уровне таблицы обычно представляют как набор строк, но физически же они хранятся по столбцам. Это достаточно важный факт, который стоит учитывать при разработки схемы хранения данных. Пустые ячейки не отображаются каким-либо образом физически в хранимых данных, они просто отсутствуют. Существуют конечно и другие нюансы, но я постарался упомянуть лишь основные.</p>
<p>HQL очень прост по своей сути, если Вы уже знаете SQL, то для изучения его Вам понадобится лишь просмотреть по диагонали коротенький вывод команды «help;», занимающий всего пару экранов в консоли. Все те же SELECT, INSERT, UPDATE, DROP и так далее, лишь со слегка измененным синтаксисом.</p>
<p>Помимо обычно командной оболочки HBase Shell, для работы с HBase также предоставлено несколько API для различных языков программирования: Java, Jython, REST и Thrift.</p>
<p><strong>HadoopDB</strong></p>
<p>В проекте HadoopDB специалисты из университетов Yale и Brown предпринимают попытку создать гибридную систему управления данными, сочетающую преимущества технологий и MapReduce, и параллельных СУБД. В их подходе MapReduce обеспечивает коммуникационную инфраструктуру, объединяющую произвольное число узлов, в которых выполняются экземпляры традиционной СУБД. Запросы формулируются на языке SQL, транслируются в среду MapReduce, и значительная часть работы передается в экземпляры СУБД. Наличие MapReduce обеспечивается масштабируемость и отказоустойчивость, а использование в узлах кластера СУБД позволяет добиться высокой производительности.</p>
<h3 id="установка-и-настройка">Установка и настройка</h3>
<p>Вся настройка ведется в операционной системе Ubuntu Server.</p>
<h4 id="установка-hadoop">Установка Hadoop</h4>
<p>Перед тем, как приступить собственно говоря к установке Hadoop, необходимо выполнить два элементарных действия, необходимых для правильного функционирования системы:</p>
<ul>
<li><p>открыть доступ одному из пользователей по ssh к этому же компьютеру без пароля, можно например создать отдельного пользователя для этого [hadoop]:</p>
<pre><code>$sudo groupadd hadoop
$sudo useradd -m -g hadoop -d /home/hadoop -s /bin/bash \
-c &quot;Hadoop software owner&quot; hadoop</code></pre>
<p>Далее действия выполняем от его имени:</p>
<pre><code>su hadoop</code></pre>
<p>Генерим RSA-ключ для обеспечения аутентификации в условиях отсутствия возможности использовать пароль:</p>
<pre><code>hadoop@localhost ~ $ ssh-keygen -t rsa -P &quot;&quot;
Generating public/private rsa key pair.
Enter file in which to save the key (/home/hadoop/.ssh/id_rsa):
Your identification has been saved in /home/hadoop/.ssh/id_rsa.
Your public key has been saved in /home/hadoop/.ssh/id_rsa.pub.
The key fingerprint is:
7b:5c:cf:79:6b:93:d6:d6:8d:41:e3:a6:9d:04:f9:85 hadoop@localhost</code></pre>
<p>И добавляем его в список авторизованных ключей:</p>
<pre><code>cat $HOME/.ssh/id_rsa.pub » $HOME/.ssh/authorized_keys</code></pre>
<p>Этого должно быть более чем достаточно. Проверить работоспособность соединения можно просто написав:</p>
<pre><code>ssh localhost</code></pre>
<p>Не забываем предварительно инициализировать sshd:</p>
<pre><code>/etc/init.d/sshd start</code></pre></li>
<li><p>Помимо этого необходимо убедиться в наличии установленной JVM версии 1.5.0 или выше.</p>
<pre><code>sudo aptitude install openjdk-6-jdk</code></pre></li>
</ul>
<p>Дальше скачиваем и устанавливаем Hadoop:</p>
<pre><code>cd /opt
sudo wget http://www.gtlib.gatech.edu/pub/apache/hadoop
/core/hadoop-0.20.2/hadoop-0.20.2.tar.gz
sudo tar zxvf hadoop-0.20.2.tar.gz
sudo ln -s /opt/hadoop-0.20.2 /opt/hadoop
sudo chown -R hadoop:hadoop /opt/hadoop /opt/hadoop-0.20.2
sudo mkdir -p /opt/hadoop-data/tmp-base
sudo chown -R hadoop:hadoop /opt/hadoop-data/</code></pre>
<p>Далее переходим в /opt/hadoop/conf/hadoop-env.sh и добавляем в начало файла:</p>
<pre><code>export JAVA_HOME=/usr/lib/jvm/java-6-openjdk
export HADOOP_HOME=/opt/hadoop
export HADOOP_CONF=$HADOOP_HOME/conf
export HADOOP_PATH=$HADOOP_HOME/bin
export HIVE_HOME=/opt/hive
export HIVE_PATH=$HIVE_HOME/bin

export PATH=$HIVE_PATH:$HADOOP_PATH:$PATH</code></pre>
<p>Далее добавим в /opt/hadoop/conf/hadoop-site.xml:</p>
<pre><code>&lt;configuration&gt;
&lt;property&gt;
  &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;
  &lt;value&gt;/opt/hadoop-data/tmp-base&lt;/value&gt;
  &lt;description&gt;A base for other temporary directories&lt;/description&gt;
&lt;/property&gt;

&lt;property&gt;
  &lt;name&gt;fs.default.name&lt;/name&gt;
  &lt;value&gt;localhost:54311&lt;/value&gt;
  &lt;description&gt;
    The name of the default file system.
  &lt;/description&gt;
&lt;/property&gt;

&lt;property&gt;
  &lt;name&gt;hadoopdb.config.file&lt;/name&gt;
  &lt;value&gt;HadoopDB.xml&lt;/value&gt;
  &lt;description&gt;The name of the HadoopDB 
  cluster configuration file&lt;/description&gt;
&lt;/property&gt;
&lt;/configuration&gt;</code></pre>
<p>В /opt/hadoop/conf/mapred-site.xml:</p>
<pre><code>&lt;configuration&gt;
&lt;property&gt;
  &lt;name&gt;mapred.job.tracker&lt;/name&gt;
  &lt;value&gt;localhost:54310&lt;/value&gt;
  &lt;description&gt;
    The host and port that the 
    MapReduce job tracker runs at.
  &lt;/description&gt;
&lt;/property&gt;
&lt;/configuration&gt;</code></pre>
<p>В /opt/hadoop/conf/hdfs-site.xml:</p>
<pre><code>&lt;configuration&gt;
&lt;property&gt;
  &lt;name&gt;dfs.replication&lt;/name&gt;
  &lt;value&gt;1&lt;/value&gt;
  &lt;description&gt;
    Default block replication.
  &lt;/description&gt;
&lt;/property&gt;
&lt;/configuration&gt;</code></pre>
<p>Теперь необходимо отформатировать Namenode:</p>
<pre><code>$ hadoop namenode -format
10/05/07 14:24:12 INFO namenode.NameNode: STARTUP_MSG: 
/************************************************************
STARTUP_MSG: Starting NameNode
STARTUP_MSG:   host = hadoop1/127.0.1.1
STARTUP_MSG:   args = [-format]
STARTUP_MSG:   version = 0.20.2
STARTUP_MSG:   build = https://svn.apache.org/repos
/asf/hadoop/common/branches/branch-0.20 -r
911707; compiled by &#39;chrisdo&#39; on Fri Feb 19 08:07:34 UTC 2010
************************************************************/
10/05/07 14:24:12 INFO namenode.FSNamesystem: 
fsOwner=hadoop,hadoop
10/05/07 14:24:12 INFO namenode.FSNamesystem: 
supergroup=supergroup
10/05/07 14:24:12 INFO namenode.FSNamesystem: 
isPermissionEnabled=true
10/05/07 14:24:12 INFO common.Storage: 
Image file of size 96 saved in 0 seconds.
10/05/07 14:24:12 INFO common.Storage: 
Storage directory /opt/hadoop-data/tmp-base/dfs/name has been
successfully formatted.
10/05/07 14:24:12 INFO namenode.NameNode: 
SHUTDOWN_MSG: 
/************************************************************
SHUTDOWN_MSG: Shutting down NameNode at hadoop1/127.0.1.1
************************************************************/</code></pre>
<p>Готово. Теперь мы можем запустить Hadoop:</p>
<pre><code>$ start-all.sh
starting namenode, logging to /opt/hadoop/bin/..
/logs/hadoop-hadoop-namenode-hadoop1.out
localhost: starting datanode, logging to 
/opt/hadoop/bin/../logs/hadoop-hadoop-datanode-hadoop1.out
localhost: starting secondarynamenode, logging to
/opt/hadoop/bin/../logs/hadoop-hadoop-secondarynamenode-hadoop1.out
starting jobtracker, logging to 
/opt/hadoop/bin/../logs/hadoop-hadoop-jobtracker-hadoop1.out
localhost: starting tasktracker, logging to
/opt/hadoop/bin/../logs/hadoop-hadoop-tasktracker-hadoop1.out</code></pre>
<p>Остановка Hadoop производится скриптом stop-all.sh.</p>
<h4 id="установка-hadoopdb-и-hive">Установка HadoopDB и Hive</h4>
<p>Теперь скачаем HaddopDB<a href="#fn17" class="footnoteRef" id="fnref17"><sup>17</sup></a> и распакуем hadoopdb.jar в $HADOOP_HOME/lib:</p>
<pre><code>$cp hadoopdb.jar $HADOOP_HOME/lib</code></pre>
<p>Также нам потребуется PostgreSQL JDBC библиотека. Скачайте её<a href="#fn18" class="footnoteRef" id="fnref18"><sup>18</sup></a> и распакуйте в директорию $HADOOP_HOME/lib.</p>
<p>Hive используется HadoopDB как SQL интерфейс. Подготовим директорию в HDFS для Hive:</p>
<pre><code>hadoop fs -mkdir /tmp
hadoop fs -mkdir /user/hive/warehouse
hadoop fs -chmod g+w /tmp
hadoop fs -chmod g+w /user/hive/warehouse</code></pre>
<p>В архиве HadoopDB также есть архив SMS_dist. Распакуем его:</p>
<pre><code>tar zxvf SMS_dist.tar.gz
sudo mv dist /opt/hive
sudo chown -R hadoop:hadoop hive</code></pre>
<p>Поскольку мы успешно запустили Hadoop, то и проблем с запуском Hive не должно быть:</p>
<pre><code>$ hive
Hive history file=/tmp/hadoop/
hive_job_log_hadoop_201005081717_1990651345.txt
hive&gt; 

hive&gt; quit;</code></pre>
<h4 id="тестирование-1">Тестирование</h4>
<p>Теперь проведем тестирование. Для этого скачаем бенчмарк:</p>
<pre><code>svn co http://graffiti.cs.brown.edu/svn/benchmarks/
cd benchmarks/datagen/teragen</code></pre>
<p>Изменим скрипт benchmarks/datagen/teragen/teragen.pl к виду:</p>
<pre><code>use strict;
use warnings;

my $CUR_HOSTNAME = `hostname -s`;
chomp($CUR_HOSTNAME);

my $NUM_OF_RECORDS_1TB    = 10000000000;
my $NUM_OF_RECORDS_535MB  = 100;
my $BASE_OUTPUT_DIR   = &quot;/data&quot;;
my $PATTERN_STRING    = &quot;XYZ&quot;;
my $PATTERN_FREQUENCY = 108299;
my $TERAGEN_JAR       = &quot;teragen.jar&quot;;
my $HADOOP_COMMAND    = $ENV{&#39;HADOOP_HOME&#39;}.&quot;/bin/hadoop&quot;;

my %files = ( &quot;535MB&quot; =&gt; 1,
);
system(&quot;$HADOOP_COMMAND fs -rmr $BASE_OUTPUT_DIR&quot;);
foreach my $target (keys %files) {
my $output_dir = $BASE_OUTPUT_DIR.&quot;/SortGrep$target&quot;;
my $num_of_maps = $files{$target};
my $num_of_records = ($target eq &quot;535MB&quot; ? 
$NUM_OF_RECORDS_535MB : $NUM_OF_RECORDS_1TB);
print &quot;Generating $num_of_maps files in &#39;$output_dir&#39;\n&quot;;

##
## EXEC: hadoop jar teragen.jar 10000000000 
## /data/SortGrep/ XYZ 108299 100
##
my @args = ( $num_of_records,
	    $output_dir,
	    $PATTERN_STRING,
	    $PATTERN_FREQUENCY,
	    $num_of_maps );
my $cmd = &quot;$HADOOP_COMMAND jar $TERAGEN_JAR &quot;.join(&quot; &quot;, @args);
print &quot;$cmd\n&quot;;
system($cmd) == 0 || die(&quot;ERROR: $!&quot;);
} # FOR
exit(0);</code></pre>
<p>При запуске данного Perl скрипта сгенерится данные, которые будут сохранены на HDFS. Поскольку мы настроили систему как единственный кластер, то все данные будут загружены на один HDFS. При работе с большим количеством кластеров данные были бы распределены по кластерам. Создадим базу данных, таблицу и загрузим данные, которые мы сохранили на HDFS, в нее:</p>
<pre><code>$hadoop fs -get /data/SortGrep535MB/part-00000 my_file
$psql
psql&gt; CREATE DATABASE grep0;
psql&gt; USE grep0;
psql&gt; CREATE TABLE grep (
    -&gt;   key1 character varying(255),
    -&gt;   field character varying(255)
    -&gt; );
COPY grep FROM &#39;my_file&#39; WITH DELIMITER &#39;|&#39;;</code></pre>
<p>Теперь настроим HadoopDB. В архиве HadoopDB можно найти пример файла Catalog.properties. Распакуйте его и настройте:</p>
<pre><code>#Properties for Catalog Generation
##################################
nodes_file=machines.txt
relations_unchunked=grep, EntireRankings
relations_chunked=Rankings, UserVisits
catalog_file=HadoopDB.xml
##
#DB Connection Parameters
##
port=5432
username=postgres
password=password
driver=com.postgresql.Driver
url_prefix=jdbc\:postgresql\://
##
#Chunking properties
##
chunks_per_node=0
unchunked_db_prefix=grep
chunked_db_prefix=cdb
##
#Replication Properties
##
dump_script_prefix=/root/dump_
replication_script_prefix=/root/load_replica_
dump_file_u_prefix=/mnt/dump_udb
dump_file_c_prefix=/mnt/dump_cdb
##
#Cluster Connection
##
ssh_key=id_rsa</code></pre>
<p>Создайте файл machines.txt и добавьте туда строчку «localhost» (без кавычек). Тепер создадим конфиг HadoopDB и скопируем его в HDFS:</p>
<pre><code>java -cp $HADOOP_HOME/lib/hadoopdb.jar \
&gt; edu.yale.cs.hadoopdb.catalog.SimpleCatalogGenerator \
&gt; Catalog.properties
hadoop dfs -put HadoopDB.xml HadoopDB.xml</code></pre>
<p>Также возможно создать конфиг для создания репликации командой:</p>
<pre><code>java -cp hadoopdb.jar edu.yale.cs.hadoopdb.catalog.SimpleRandomReplicationFactorTwo Catalog.properties</code></pre>
<p>Инструмент генерирует новый файл HadoopDB.xml, в котором случайные порции данных реплицируются на все узлы. После этого не забываем обновить конфиг на HDFS:</p>
<pre><code>hadoop dfs -rmr HadoopDB.xml
hadoop dfs -put HadoopDB.xml HadoopDB.xml</code></pre>
<p>и поставить «true» для «hadoopdb.config.replication» в HADOOP_HOME/conf/hadoop-site.xml.</p>
<p>Теперь мы готовы проверить работу HadoopDB. Теперь можем протестировать поиск по данным, загруженым ранее в БД и HDFS:</p>
<pre><code>java -cp $CLASSPATH:hadoopdb.jar \
&gt; edu.yale.cs.hadoopdb.benchmark.GrepTaskDB \
&gt; -pattern %wo% -output padraig -hadoop.config.file HadoopDB.xml</code></pre>
<p>Приблизительный результат:</p>
<pre><code>$java -cp $CLASSPATH:hadoopdb.jar edu.yale.cs.hadoopdb.benchmark.GrepTaskDB \
&gt; -pattern %wo% -output padraig -hadoop.config.file HadoopDB.xml
14.08.2010 19:08:48 edu.yale.cs.hadoopdb.exec.DBJobBase initConf
INFO: SELECT key1, field FROM grep WHERE field LIKE &#39;%%wo%%&#39;;
14.08.2010 19:08:48 org.apache.hadoop.metrics.jvm.JvmMetrics init
INFO: Initializing JVM Metrics with processName=JobTracker, sessionId=
14.08.2010 19:08:48 org.apache.hadoop.mapred.JobClient configureCommandLineOptions
WARNING: Use GenericOptionsParser for parsing the arguments. 
Applications should implement Tool for the same.
14.08.2010 19:08:48 org.apache.hadoop.mapred.JobClient monitorAndPrintJob
INFO: Running job: job_local_0001
14.08.2010 19:08:48 edu.yale.cs.hadoopdb.connector.AbstractDBRecordReader getConnection
INFO: Data locality failed for leo-pgsql
14.08.2010 19:08:48 edu.yale.cs.hadoopdb.connector.AbstractDBRecordReader getConnection
INFO: Task from leo-pgsql is connecting to chunk 0 on host localhost with 
db url jdbc:postgresql://localhost:5434/grep0
14.08.2010 19:08:48 org.apache.hadoop.mapred.MapTask runOldMapper
INFO: numReduceTasks: 0
14.08.2010 19:08:48 edu.yale.cs.hadoopdb.connector.AbstractDBRecordReader close
INFO: DB times (ms): connection = 104, query execution = 20, row retrieval  = 79
14.08.2010 19:08:48 edu.yale.cs.hadoopdb.connector.AbstractDBRecordReader close
INFO: Rows retrieved = 3
14.08.2010 19:08:48 org.apache.hadoop.mapred.Task done
INFO: Task:attempt_local_0001_m_000000_0 is done. And is in the process of commiting
14.08.2010 19:08:48 org.apache.hadoop.mapred.LocalJobRunner$Job statusUpdate
INFO: 
14.08.2010 19:08:48 org.apache.hadoop.mapred.Task commit
INFO: Task attempt_local_0001_m_000000_0 is allowed to commit now
14.08.2010 19:08:48 org.apache.hadoop.mapred.FileOutputCommitter commitTask
INFO: Saved output of task &#39;attempt_local_0001_m_000000_0&#39; to file:/home/leo/padraig
14.08.2010 19:08:48 org.apache.hadoop.mapred.LocalJobRunner$Job statusUpdate
INFO: 
14.08.2010 19:08:48 org.apache.hadoop.mapred.Task sendDone
INFO: Task &#39;attempt_local_0001_m_000000_0&#39; done.
14.08.2010 19:08:49 org.apache.hadoop.mapred.JobClient monitorAndPrintJob
INFO:  map 100% reduce 0%
14.08.2010 19:08:49 org.apache.hadoop.mapred.JobClient monitorAndPrintJob
INFO: Job complete: job_local_0001
14.08.2010 19:08:49 org.apache.hadoop.mapred.Counters log
INFO: Counters: 6
14.08.2010 19:08:49 org.apache.hadoop.mapred.Counters log
INFO:   FileSystemCounters
14.08.2010 19:08:49 org.apache.hadoop.mapred.Counters log
INFO:     FILE_BYTES_READ=141370
14.08.2010 19:08:49 org.apache.hadoop.mapred.Counters log
INFO:     FILE_BYTES_WRITTEN=153336
14.08.2010 19:08:49 org.apache.hadoop.mapred.Counters log
INFO:   Map-Reduce Framework
14.08.2010 19:08:49 org.apache.hadoop.mapred.Counters log
INFO:     Map input records=3
14.08.2010 19:08:49 org.apache.hadoop.mapred.Counters log
INFO:     Spilled Records=0
14.08.2010 19:08:49 org.apache.hadoop.mapred.Counters log
INFO:     Map input bytes=3
14.08.2010 19:08:49 org.apache.hadoop.mapred.Counters log
INFO:     Map output records=3
14.08.2010 19:08:49 edu.yale.cs.hadoopdb.exec.DBJobBase run
INFO: 
JOB TIME : 1828 ms.</code></pre>
<p>Результат сохранен в HDFS, в папке padraig:</p>
<pre><code>$ cd padraig
$ cat part-00000
some data</code></pre>
<p>Проверим данные в PostgreSQL:</p>
<pre><code>psql&gt; select * from grep where field like &#39;%wo%&#39;;
+--------------------------------+-------------------+
| key1                           | field
|
+--------------------------------+-------------------+
some data

1 rows in set (0.00 sec)

psql&gt;</code></pre>
<p>Значения совадают. Все работает как требуется.</p>
<p>Проведем еще один тест. Добавим данные в PostgreSQL:</p>
<pre><code>psql&gt; INSERT into grep(key1, field) VALUES(&#39;I am live!&#39;, &#39;Maybe&#39;);
psql&gt; INSERT into grep(key1, field) VALUES(&#39;I am live!&#39;, &#39;Maybewqe&#39;);
psql&gt; INSERT into grep(key1, field) VALUES(&#39;I am live!&#39;, &#39;Maybewqesad&#39;);
psql&gt; INSERT into grep(key1, field) VALUES(&#39;:)&#39;, &#39;May cool string!&#39;);</code></pre>
<p>Теперь проверим через HadoopDB:</p>
<pre><code>$ java -cp $CLASSPATH:hadoopdb.jar edu.yale.cs.hadoopdb.benchmark.GrepTaskDB -pattern %May% -output padraig -hadoopdb.config.file /opt/hadoop/conf/HadoopDB.xml
padraig
01.11.2010 23:14:45 edu.yale.cs.hadoopdb.exec.DBJobBase initConf
INFO: SELECT key1, field FROM grep WHERE field LIKE &#39;%%May%%&#39;;
01.11.2010 23:14:46 org.apache.hadoop.metrics.jvm.JvmMetrics init
INFO: Initializing JVM Metrics with processName=JobTracker, sessionId=
01.11.2010 23:14:46 org.apache.hadoop.mapred.JobClient configureCommandLineOptions
WARNING: Use GenericOptionsParser for parsing the arguments. Applications should implement Tool for the same.
01.11.2010 23:14:46 org.apache.hadoop.mapred.JobClient monitorAndPrintJob
INFO: Running job: job_local_0001
01.11.2010 23:14:46 edu.yale.cs.hadoopdb.connector.AbstractDBRecordReader getConnection
INFO: Data locality failed for leo-pgsql
01.11.2010 23:14:46 edu.yale.cs.hadoopdb.connector.AbstractDBRecordReader getConnection
INFO: Task from leo-pgsql is connecting to chunk 0 on host localhost with db url jdbc:postgresql://localhost:5434/grep0
01.11.2010 23:14:47 org.apache.hadoop.mapred.MapTask runOldMapper
INFO: numReduceTasks: 0
01.11.2010 23:14:47 edu.yale.cs.hadoopdb.connector.AbstractDBRecordReader close
INFO: DB times (ms): connection = 181, query execution = 22, row retrieval  = 96
01.11.2010 23:14:47 edu.yale.cs.hadoopdb.connector.AbstractDBRecordReader close
INFO: Rows retrieved = 4
01.11.2010 23:14:47 org.apache.hadoop.mapred.Task done
INFO: Task:attempt_local_0001_m_000000_0 is done. And is in the process of commiting
01.11.2010 23:14:47 org.apache.hadoop.mapred.LocalJobRunner$Job statusUpdate
INFO: 
01.11.2010 23:14:47 org.apache.hadoop.mapred.Task commit
INFO: Task attempt_local_0001_m_000000_0 is allowed to commit now
01.11.2010 23:14:47 org.apache.hadoop.mapred.FileOutputCommitter commitTask
INFO: Saved output of task &#39;attempt_local_0001_m_000000_0&#39; to file:/home/hadoop/padraig
01.11.2010 23:14:47 org.apache.hadoop.mapred.LocalJobRunner$Job statusUpdate
INFO: 
01.11.2010 23:14:47 org.apache.hadoop.mapred.Task sendDone
INFO: Task &#39;attempt_local_0001_m_000000_0&#39; done.
01.11.2010 23:14:47 org.apache.hadoop.mapred.JobClient monitorAndPrintJob
INFO:  map 100% reduce 0%
01.11.2010 23:14:47 org.apache.hadoop.mapred.JobClient monitorAndPrintJob
INFO: Job complete: job_local_0001
01.11.2010 23:14:47 org.apache.hadoop.mapred.Counters log
INFO: Counters: 6
01.11.2010 23:14:47 org.apache.hadoop.mapred.Counters log
INFO:   FileSystemCounters
01.11.2010 23:14:47 org.apache.hadoop.mapred.Counters log
INFO:     FILE_BYTES_READ=141345
01.11.2010 23:14:47 org.apache.hadoop.mapred.Counters log
INFO:     FILE_BYTES_WRITTEN=153291
01.11.2010 23:14:47 org.apache.hadoop.mapred.Counters log
INFO:   Map-Reduce Framework
01.11.2010 23:14:47 org.apache.hadoop.mapred.Counters log
INFO:     Map input records=4
01.11.2010 23:14:47 org.apache.hadoop.mapred.Counters log
INFO:     Spilled Records=0
01.11.2010 23:14:47 org.apache.hadoop.mapred.Counters log
INFO:     Map input bytes=4
01.11.2010 23:14:47 org.apache.hadoop.mapred.Counters log
INFO:     Map output records=4
01.11.2010 23:14:47 edu.yale.cs.hadoopdb.exec.DBJobBase run
INFO: 
JOB TIME : 2332 ms.</code></pre>
<p>Как паттерн поиска я задал «May». В логах можно увидеть как производится поиск. На выходе получаем:</p>
<pre><code>$ cd padraig
$ cat part-00000
I am live!	Maybe
I am live!	Maybewqe
I am live!	Maybewqesad
:)	May cool string!</code></pre>
<p>В упрощенной системе с одним кластером PostgreSQL не понятно ради чего такие сложности. Но если к HadoopDB подключить более одного кластера PostgreSQL, то данной методикой возможно работать с данными PostgreSQL, объединенных в shared-nothing кластер.</p>
<p>Более подробно по HadoopDB можно почитать по данной ссылке <a href="http://hadoopdb.sourceforge.net/guide/quick_start_guide.html">hadoopdb.sourceforge.net</a>.</p>
<h3 id="заключение-4">Заключение</h3>
<p>В данной статье не показывается, как работать с Hive, как более проще работать с HadoopDB. Эта книга не сможет учесть все, что требуется для работы c Hadoop. Назначение этой главы — дать основу для работы с Hadoop и HaddopDB.</p>
<p>HadoopDB не заменяет Hadoop. Эти системы сосуществуют, позволяя аналитику выбирать соответствующие средства в зависимости от имеющихся данных и задач.</p>
<p>HadoopDB может приблизиться в отношении производительности к параллельным системам баз данных, обеспечивая при этом отказоустойчивость и возможность использования в неоднородной среде при тех же правилах лицензирования, что и Hadoop. Хотя производительность HadoopDB, вообще говоря, ниже производительности параллельных систем баз данных, во многом это объясняется тем, что в PostgreSQL таблицы хранятся не по столбцам, и тем, что в PostgreSQL не использовалось сжатие данных. Кроме того, Hadoop и Hive — это сравнительно молодые проекты с открытыми кодами.</p>
<p>В HadoopDB применяется некоторый гибрид подходов параллельных СУБД и Hadoop к анализу данных, позволяющий достичь производительности и эффективности параллельных систем баз данных, обеспечивая при этом масштабируемость, отказоустойчивость и гибкость систем, основанных на MapReduce. Способность HadoopDB к прямому включению Hadoop и программного обеспечения СУБД с открытыми исходными текстами (без изменения кода) делает HadoopDB особенно пригодной для выполнения крупномасштабного анализа данных в будущих рабочих нагрузках.</p>
<h2 id="заключение-5">Заключение</h2>
<p>В данной главе рассмотрены лишь базовые настройки кластеров БД. Про кластеры PostgreSQL потребуется написать отдельную книгу, чтобы рассмотреть все шаги с установкой, настройкой и работой кластеров. Надеюсь, что несмотря на это, информация будет полезна многим читателям.</p>
<h1 id="pgpool-ii">PgPool-II</h1>
<h2 id="введение-10">Введение</h2>
<p>pgpool-II — это прослойка, работающая между серверами PostgreSQL и клиентами СУБД PostgreSQL. Она предоставляет следующие функции:</p>
<ul>
<li><p><strong>Объединение соединений</strong></p>
<p>pgpool-II сохраняет соединения с серверами PostgreSQL и использует их повторно в случае если новое соединение устанавливается с теми же параметрами (т.е. имя пользователя, база данных, версия протокола). Это уменьшает накладные расходы на соединения и увеличивает производительность системы в целом.</p></li>
<li><p><strong>Репликация</strong></p>
<p>pgpool-II может управлять множеством серверов PostgreSQL. Использование функции репликации данных позволяет создание резервной копии данных в реальном времени на 2 или более физических дисков, так что сервис может продолжать работать без остановки серверов в случае выхода из строя диска.</p></li>
<li><p><strong>Балансировка нагрузки</strong></p>
<p>Если база данных реплицируется, то выполнение запроса SELECT на любом из серверов вернет одинаковый результат. pgpool-II использует преимущество функции репликации для уменьшения нагрузки на каждый из серверов PostgreSQL распределяя запросы SELECT на несколько серверов, тем самым увеличивая производительность системы вцелом. В лучшем случае производительность возрастает пропорционально числу серверов PostgreSQL. Балансировка нагрузки лучше всего работает в случае когда много пользователей выполняют много запросов в одно и то же время.</p></li>
<li><p><strong>Ограничение лишних соединений</strong></p>
<p>Существует ограничение максимального числа одновременных соединений с PostgreSQL, при превышении которого новые соединения отклоняются. Установка максимального числа соединений, в то же время, увеличивает потребление ресурсов и снижает производительность системы. pgpool-II также имеет ограничение на максимальное число соединений, но «лишние» соединения будут поставлены в очередь вместо немедленного возврата ошибки.</p></li>
<li><p><strong>Параллельные запросы</strong></p>
<p>Используя функцию параллельных запросов можно разнести данные на множество серверов, благодаря чему запрос может быть выполнен на всех серверах одновременно для уменьшения общего времени выполнения. Параллельные запросы работают лучше всего при поиске в больших объемах данных.</p></li>
</ul>
<p>pgpool-II общается по протоколу бэкенда и фронтенда PostgreSQL и располагается между ними. Таким образом, приложение базы данных (фронтенд) считает что pgpool-II — настоящий сервер PostgreSQL, а сервер (бэкенд) видит pgpool-II как одного из своих клиентов. Поскольку pgpool-II прозрачен как для сервера, так и для клиента, существующие приложения, работающие с базой данных, могут использоваться с pgpool-II практически без изменений в исходном коде.</p>
<p>Оригинал руководства доступен по адресу <a href="http://pgpool.projects.pgfoundry.org/pgpool-II/doc/tutorial-en.html">pgpool.projects.pgfoundry.org</a>.</p>
<h2 id="sec:pgpool-II-begin">Давайте начнем!</h2>
<p>Перед тем как использовать репликацию или параллельные запросы мы должны научиться устанавливать и настраивать pgpool-II и узлы базы данных.</p>
<h3 id="установка-pgpool-ii">Установка pgpool-II</h3>
<p>Установка pgpool-II очень проста. В каталоге, в который вы распаковали архив с исходными текстами, выполните следующие команды.</p>
<pre><code>./configure
make
make install</code></pre>
<p>Скрипт configure собирает информацию о вашей системе и использует ее в процедуре компиляции. Вы можете указать параметры в командной строке скрипта configure чтобы изменить его поведение по умолчанию, такие, например, как каталог установки. pgpool-II по умолчанию будет установлен в каталог /usr/local.</p>
<p>Команда make скомпилирует исходный код, а make install установит исполняемые файлы. У вас должно быть право на запись в каталог установки.</p>
<p>Обратите внимание: для работы pgpool-II необходима библиотека libpq для PostgreSQL 7.4 или более поздней версии (3 версия протокола). Если скрипт configure выдает следующее сообщение об ошибке, возможно не установлена библиотека libpq или она не 3 версии.</p>
<pre><code>configure: error: libpq is not installed or libpq is old</code></pre>
<p>Если библиотека 3 версии, но указанное выше сообщение все-таки выдается, ваша библиотека libpq, вероятно, не распознается скриптом configure.</p>
<p>Скрипт configure ищет библиотеку libpq начиная от каталога /usr/local/pgsql. Если вы установили PostgreSQL в каталог отличный от /usr/local/pgsql используйте параметры командной строки –with-pgsql или –with-pgsql-includedir вместе с параметром –with-pgsql-libdir при запуске скрипта configure.</p>
<p>Во многих Linux системах pgpool-II может находиться в репозитории пакетов. Для Ubuntu Linux, например, достаточно будет выполнить:</p>
<pre><code>sudo aptitude install pgpool2</code></pre>
<h3 id="файлы-конфигурации">Файлы конфигурации</h3>
<p>Параметры конфигурации pgpool-II хранятся в файле pgpool.conf. Формат файла: одна пара «параметр = значение» в строке. При установке pgpool-II автоматически создается файл pgpool.conf.sample. Мы рекомендуем скопировать его в файл pgpool.conf, а затем отредактировать по вашему желанию.</p>
<pre><code>cp /usr/local/etc/pgpool.conf.sample /usr/local/etc/pgpool.conf</code></pre>
<p>pgpool-II принимает соединения только с localhost на порт 9999. Если вы хотите принимать соединения с других хостов, установите для параметра listen_addresses значение «*».</p>
<pre><code>listen_addresses = &#39;localhost&#39;
port = 9999</code></pre>
<p>Мы будем использовать параметры по умолчанию в этом руководстве.</p>
<p>В Ubuntu Linux конфиг находится /etc/pgpool.conf.</p>
<h3 id="настройка-команд-pcp">Настройка команд PCP</h3>
<p>У pgpool-II есть интерфейс для административных целей — получить информацию об узлах базы данных, остановить pgpool-II и т.д. — по сети. Чтобы использовать команды PCP, необходима идентификация пользователя. Эта идентификация отличается от идентификации пользователей в PostgreSQL. Имя пользователя и пароль нужно указывать в файле pcp.conf. В этом файле имя пользователя и пароль указываются как пара значений, разделенных двоеточием (:). Одна пара в строке. Пароли зашифрованы в формате хэша md5.</p>
<pre><code>postgres:e8a48653851e28c69d0506508fb27fc5</code></pre>
<p>При установке pgpool-II автоматически создается файл pcp.conf.sample. Мы рекомендуем скопировать его в файл pcp.conf и отредактировать.</p>
<pre><code>$ cp /usr/local/etc/pcp.conf.sample /usr/local/etc/pcp.conf</code></pre>
<p>В Ubuntu Linux файл находится /etc/pcp.conf.</p>
<p>Для того чтобы зашифровать ваш пароль в формате хэша md5 используете команду pg_md5, которая устанавливается как один из исполняемых файлов pgpool-II. pg_md5 принимает текст в параметре командной строки и отображает текст его md5 хэша.</p>
<p>Например, укажите «postgres» в качестве параметра командной строки и pg_md5 выведет текст хэша md5 в стандартный поток вывода.</p>
<pre><code>$ /usr/bin/pg_md5 postgres
e8a48653851e28c69d0506508fb27fc5</code></pre>
<p>Команды PCP выполняются по сети, так что в файле pgpool.conf должен быть указан номер порта в параметре pcp_port.</p>
<p>Мы будем использовать значение по умолчанию для параметра pcp_port 9898 в этом руководстве.</p>
<pre><code>pcp_port = 9898</code></pre>
<h3 id="подготовка-узлов-баз-данных">Подготовка узлов баз данных</h3>
<p>Теперь нам нужно настроить серверы бэкендов PostgreSQL для pgpool-II. Эти серверы могут быть размещены на одном хосте с pgpool-II или на отдельных машинах. Если вы решите разместить серверы на том же хосте, для всех серверов должны быть установлены разные номера портов. Если серверы размещены на отдельных машинах, они должны быть настроены так чтобы могли принимать сетевые соединения от pgpool-II.</p>
<p>В этом руководстве мы разместили три сервера в рамках одного хоста вместе с pgpool-II и присвоили им номера портов 5432, 5433, 5434 соответственно. Для настройки pgpool-II отредактируйте файл pgpool.conf как показано ниже.</p>
<pre><code>backend_hostname0 = &#39;localhost&#39;
backend_port0 = 5432
backend_weight0 = 1
backend_hostname1 = &#39;localhost&#39;
backend_port1 = 5433
backend_weight1 = 1
backend_hostname2 = &#39;localhost&#39;
backend_port2 = 5434
backend_weight2 = 1</code></pre>
<p>В параметрах backend_hostname, backend_port, backend_weight укажите имя хоста узла базы данных, номер порта и коэффициент для балансировки нагрузки. В конце имени каждого параметра должен быть указан идентификатор узла путем добавления положительного целого числа начиная с 0 (т.е. 0, 1, 2).</p>
<p>Параметры backend_weight все равны 1, что означает что запросы SELECT равномерно распределены по трем серверам.</p>
<h3 id="запускостановка-pgpool-ii">Запуск/Остановка pgpool-II</h3>
<p>Для старта pgpool-II выполните в терминале следующую команду.</p>
<pre><code>pgpool</code></pre>
<p>Указанная выше команда, однако, не печатает протокол своей работы потому что pgpool отсоединяется от терминала. Если вы хотите показать протокол работы pgpool, укажите параметр -n в командной строке при запуске pgpool. pgpool-II будет запущен как процесс не-демон и терминал не будет отсоединен.</p>
<pre><code>pgpool -n &amp;</code></pre>
<p>Протокол работы будет печататься на терминал, так что рекомендуемые для использования параметры командной строки, например, такие.</p>
<pre><code>pgpool -n -d &gt; /tmp/pgpool.log 2&gt;&amp;1 &amp;</code></pre>
<p>Параметр -d включает генерацию отладочных сообщений.</p>
<p>Указанная выше команда постоянно добавляет выводимый протокол работы в файл /tmp/pgpool.log. Если вам нужно ротировать файлы протоколов, передавайте протоколы внешней команде, у которой есть функция ротации протоколов. Вам поможет, например, cronolog.</p>
<pre><code>pgpool -n 2&gt;&amp;1 | /usr/sbin/cronolog
  --hardlink=/var/log/pgsql/pgpool.log
  &#39;/var/log/pgsql/%Y-%m-%d-pgpool.log&#39; &amp;</code></pre>
<p>Чтобы остановить процесс pgpool-II, выполните следующую команду.</p>
<pre><code>pgpool stop</code></pre>
<p>Если какие-то из клиентов все еще присоединены, pgpool-II ждет пока они не отсоединятся и потом завершает свою работу. Если вы хотите завершить pgpool-II насильно, используйте вместо этой следующую команду.</p>
<pre><code>pgpool -m fast stop</code></pre>
<h2 id="sec:pgpool-II-replica">Ваша первая репликация</h2>
<p>Репликация включает копирование одних и тех же данных на множество узлов базы данных.</p>
<p>В этом разделе мы будем использовать три узла базы данных, которые мы уже установили в разделе «[sec:pgpool-II-begin]. Давайте начнем!», и проведем вас шаг за шагом к созданию системы репликации базы данных. Пример данных для репликации будет сгенерирован программой для тестирования pgbench.</p>
<h3 id="настройка-репликации">Настройка репликации</h3>
<p>Чтобы включить функцию репликации базы данных установите значение true для параметра replication_mode в файле pgpool.conf.</p>
<pre><code>replication_mode = true</code></pre>
<p>Если параметр replication_mode равен true, pgpool-II будет отправлять копию принятого запроса на все узлы базы данных.</p>
<p>Если параметр load_balance_mode равен true, pgpool-II будет распределять запросы SELECT между узлами базы данных.</p>
<pre><code>load_balance_mode = true</code></pre>
<p>В этом разделе мы включили оба параметра replication_mode и load_balance_mode.</p>
<h3 id="проверка-репликации">Проверка репликации</h3>
<p>Для отражения изменений, сделанных в файле pgpool.conf, pgpool-II должен быть перезапущен. Пожалуйста обращайтесь к разделу «Запуск/Остановка pgpool-II».</p>
<p>После настройки pgpool.conf и перезапуска pgpool-II, давайте проверим репликацию в действии и посмотрим все ли работает хорошо.</p>
<p>Сначала нам нужно создать базу данных, которую будем реплицировать. Назовем ее «bench_replication». Эту базу данных нужно создать на всех узлах. Используйте команду createdb через pgpool-II и база данных будет создана на всех узлах.</p>
<pre><code>createdb -p 9999 bench_replication</code></pre>
<p>Затем мы запустим pgbench с параметром -i. Параметр -i инициализирует базу данных предопределенными таблицами и данными в них.</p>
<pre><code>pgbench -i -p 9999 bench_replication</code></pre>
<p>Указанная ниже таблица содержит сводную информацию о таблицах и данных, которые будут созданы при помощи pgbench -i. Если на всех узлах базы данных перечисленные таблицы и данные были созданы, репликация работает корректно.</p>
<p><span> | c | c | </span> Имя таблицы &amp; Число строк<br />branches &amp; 1<br />tellers &amp; 10<br />accounts &amp; 100000<br />history &amp; 0<br /></p>
<p>Для проверки указанной выше информации на всех узлах используем простой скрипт на shell. Приведенный ниже скрипт покажет число строк в таблицах branches, tellers, accounts и history на всех узлах базы данных (5432, 5433, 5434).</p>
<pre><code>for port in 5432 5433 5434; do
&gt;     echo $port
&gt;     for table_name in branches tellers accounts history; do
&gt;         echo $table_name
&gt;         psql -c &quot;SELECT count(*) FROM $table_name&quot; -p \
&gt;         $port bench_replication
&gt;     done
&gt; done</code></pre>
<h2 id="ваш-первый-параллельный-запрос">Ваш первый параллельный запрос</h2>
<p>Данные из разных диапазонов сохраняются на двух или более узлах базы данных параллельным запросом. Это называется распределением (часто используется без перевода термин partitioning прим. переводчика). Более того, одни и те же данные на двух и более узлах базы данных могут быть воспроизведены с использованием распределения.</p>
<p>Чтобы включить параллельные запросы в pgpool-II вы должны установить еще одну базу данных, называемую «Системной базой данных» («System Database») (далее будем называть ее SystemDB).</p>
<p>SystemDB хранит определяемые пользователем правила, определяющие какие данные будут сохраняться на каких узлах базы данных. Также SystemDB используется чтобы объединить результаты возвращенные узлами базы данных посредством dblink.</p>
<p>В этом разделе мы будем использовать три узла базы данных, которые мы установили в разделе «[sec:pgpool-II-begin]. Давайте начнем!», и проведем вас шаг за шагом к созданию системы баз данных с параллельными запросами. Для создания примера данных мы снова будем использовать pgbench.</p>
<h3 id="настройка-параллельного-запроса">Настройка параллельного запроса</h3>
<p>Чтобы включить функцию выполнения параллельных запросов установите для параметра parallel_mode значение true в файле pgpool.conf.</p>
<pre><code>parallel_mode = true</code></pre>
<p>Установка параметра parallel_mode равным true не запустит параллельные запросы автоматически. Для этого pgpool-II нужна SystemDB и правила определяющие как распределять данные по узлам базы данных.</p>
<p>Также SystemDB использует dblink для создания соединений с pgpool-II. Таким образом, нужно установить значение параметра listen_addresses таким образом чтобы pgpool-II принимал эти соединения.</p>
<pre><code>listen_addresses = &#39;*&#39;</code></pre>
<p>Внимание: Репликация не реализована для таблиц, которые распределяются посредством параллельных запросов и, в то же время, репликация может быть успешно осуществлена. Вместе с тем, из-за того что набор хранимых данных отличается при параллельных запросах и при репликации, база данных «bench_replication», созданная в разделе «[sec:pgpool-II-replica]. Ваша первая репликация» не может быть повторно использована.</p>
<pre><code>replication_mode = true
load_balance_mode = false</code></pre>
<p>ИЛИ</p>
<pre><code>replication_mode = false
load_balance_mode = true</code></pre>
<p>В этом разделе мы установим параметры parallel_mode и load_balance_mode равными true, listen_addresses равным «*», replication_mode равным false.</p>
<h3 id="настройка-systemdb">Настройка SystemDB</h3>
<p>В основном, нет отличий между простой и системной базами данных. Однако, в системной базе данных определяется функция dblink и присутствует таблица, в которой хранятся правила распределения данных. Таблицу dist_def необходимо определять. Более того, один из узлов базы данных может хранить системную базу данных, а pgpool-II может использоваться для распределения нагрузки каскадным подключеним.</p>
<p>В этом разделе мы создадим SystemDB на узле с портом 5432. Далее приведен список параметров конфигурации для SystemDB</p>
<pre><code>system_db_hostname = &#39;localhost&#39;
system_db_port = 5432
system_db_dbname = &#39;pgpool&#39;
system_db_schema = &#39;pgpool_catalog&#39;
system_db_user = &#39;pgpool&#39;
system_db_password = &#39;&#39;</code></pre>
<p>На самом деле, указанные выше параметры являются параметрами по умолчанию в файле pgpool.conf. Теперь мы должны создать пользователя с именем «pgpool» и базу данных с именем «pgpool» и владельцем «pgpool».</p>
<pre><code>createuser -p 5432 pgpool
createdb -p 5432 -O pgpool pgpool</code></pre>
<h4 id="установка-dblink">Установка dblink</h4>
<p>Далее мы должны установить dblink в базу данных «pgpool». dblink — один из инструментов включенных в каталог contrib исходного кода PostgreSQL.</p>
<p>Для установки dblink на вашей системе выполните следующие команды.</p>
<pre><code>USE_PGXS=1 make -C contrib/dblink
USE_PGXS=1 make -C contrib/dblink install</code></pre>
<p>После того как dblink был установлен в вашей системе мы добавим функции dblink в базу данных «pgpool». Если PostgreSQL установлен в каталог /usr/local/pgsql, dblink.sql (файл с определениями функций) должен быть установлен в каталог /usr/local/pgsql/share/contrib. Теперь выполним следующую команду для добавления функций dblink.</p>
<pre><code>psql -f /usr/local/pgsql/share/contrib/dblink.sql -p 5432 pgpool</code></pre>
<h4 id="создание-таблицы-dist_def">Создание таблицы dist_def</h4>
<p>Следующим шагом мы создадим таблицу с именем «dist_def», в которой будут храниться правила распределения данных. Поскольку pgpool-II уже был установлен, файл с именем system_db.sql должен быть установлен в /usr/local/share/system_db.sql (имейте в виду, что это учебное руководство и мы использовали для установки каталог по умолчанию — /usr/local). Файл system_db.sql содержит директивы для создания специальных таблиц, включая и таблицу «dist_def». Выполните следующую команду для создания таблицы «dist_def».</p>
<pre><code>$ psql -f /usr/local/share/system_db.sql -p 5432 -U pgpool pgpool</code></pre>
<p>Все таблицы в файле system_db.sql, включая «dist_def», создаются в схеме «pgpool_catalog». Если вы установили параметр system_db_schema на использование другой схемы, вам нужно, соответственно, отредактировать файл system_db.sql.</p>
<p>Описание таблицы «dist_def» выглядит так как показано ниже. Имя таблицы не должно измениться.</p>
<pre><code>CREATE TABLE pgpool_catalog.dist_def (
    dbname text, -- имя базы данных
    schema_name text, -- имя схемы
    table_name text, -- имя таблицы
    col_name text NOT NULL CHECK (col_name = ANY (col_list)), 
    -- столбец ключ для распределения данных
    col_list text[] NOT NULL, -- список имен столбцов
    type_list text[] NOT NULL, -- список типов столбцов
    dist_def_func text NOT NULL, 
    -- имя функции распределения данных
    PRIMARY KEY (dbname, schema_name, table_name)
);</code></pre>
<p>Записи, хранимые в таблице «dist_def», могут быть двух типов:</p>
<ul>
<li><p>Правило Распределения Данных (col_name, dist_def_func)</p></li>
<li><p>Мета-информация о таблицах (dbname, schema_name, table_name, col_list, type_list)</p></li>
</ul>
<p>Правило распределения данных определяет как будут распределены данные на конкретный узел базы данных. Данные будут распределены в зависимости от значения столбца «col_name». «dist_def_func» — это функция, которая принимает значение «col_name» в качестве агрумента и возвращает целое число, которое соответствует идентификатору узла базы данных, на котором должны быть сохранены данные.</p>
<p>Мета-информация используется для того чтобы переписывать запросы. Параллельный запрос должен переписывать исходные запросы так чтобы результаты, возвращаемые узлами-бэкендами, могли быть объединены в единый результат.</p>
<h4 id="создание-таблицы-replicate_def">Создание таблицы replicate_def</h4>
<p>В случае если указана таблица, для которой производится репликация в выражение SQL, использующее зарегистрированную в dist_def таблицу путем объединения таблиц, информация о таблице, для которой необходимо производить репликацию, предварительно регистрируется в таблице с именем replicate_def. Таблица replicate_def уже была создана при обработке файла system_db.sql во время создания таблицы dist_def. Таблица replicate_def описана так как показано ниже.</p>
<pre><code>CREATE TABLE pgpool_catalog.replicate_def (
    dbname text, -- имя базы данных
    schema_name text, -- имя схемы
    table_name text, -- имя таблицы
    col_list text[] NOT NULL, -- список имен столбцов
    type_list text[] NOT NULL, -- список типов столбцов
    PRIMARY KEY (dbname, schema_name, table_name)
);</code></pre>
<h3 id="установка-правил-распределения-данных">Установка правил распределения данных</h3>
<p>В этом учебном руководстве мы определим правила распределения данных, созданных программой pgbench, на три узла базы данных. Тестовые данные будут созданы командой «pgbench -i -s 3» (т.е. масштабный коэффициент равен 3). Для этого раздела мы создадим новую базу данных с именем «bench_parallel».</p>
<p>В каталоге sample исходного кода pgpool-II вы можете найти файл dist_def_pgbench.sql. Мы будем использовать этот файл с примером для создания правил распределения для pgbench. Выполните следующую команду в каталоге с распакованным исходным кодом pgpool-II.</p>
<pre><code>psql -f sample/dist_def_pgbench.sql -p 5432 pgpool</code></pre>
<p>Ниже представлено описание файла dist_def_pgbench.sql.</p>
<p>В файле dist_def_pgbench.sql мы добавляем одну строку в таблицу «dist_def». Это функция распределения данных для таблицы accounts. В качестве столбца-ключа указан столбец aid.</p>
<pre><code>INSERT INTO pgpool_catalog.dist_def VALUES (
    &#39;bench_parallel&#39;,
    &#39;public&#39;,
    &#39;accounts&#39;,
    &#39;aid&#39;,
    ARRAY[&#39;aid&#39;, &#39;bid&#39;, &#39;abalance&#39;, &#39;filler&#39;],
    ARRAY[&#39;integer&#39;, &#39;integer&#39;, &#39;integer&#39;, 
    &#39;character(84)&#39;],
    &#39;pgpool_catalog.dist_def_accounts&#39;
);</code></pre>
<p>Теперь мы должны создать функцию распределения данных для таблицы accounts. Заметим, что вы можете использовать одну и ту же функцию для разных таблиц. Также вы можете создавать функции с использованием языков отличных от SQL (например, PL/pgSQL, PL/Tcl, и т.д.).</p>
<p>Таблица accounts в момент инициализации данных хранит значение масштабного коэффициента равное 3, значения столбца aid от 1 до 300000. Функция создана таким образом что данные равномерно распределяются по трем узлам базы данных.</p>
<p>Следующая SQL-функция будет возвращать число узлов базы данных.</p>
<pre><code>CREATE OR REPLACE FUNCTION 
pgpool_catalog.dist_def_branches(anyelement)
RETURNS integer AS $$
    SELECT CASE WHEN $1 &gt; 0 AND $1 &lt;= 1 THEN 0
        WHEN $1 &gt; 1 AND $1 &lt;= 2 THEN 1
        ELSE 2
    END;
$$ LANGUAGE sql;</code></pre>
<h3 id="установка-правил-репликации">Установка правил репликации</h3>
<p>Правило репликации — это то что определяет какие таблицы должны быть использованы для выполнения репликации.</p>
<p>Здесь это сделано при помощи pgbench с зарегистрированными таблицами branches и tellers.</p>
<p>Как результат, стало возможно создание таблицы accounts и выполнение запросов, использующих таблицы branches и tellers.</p>
<pre><code>INSERT INTO pgpool_catalog.replicate_def VALUES (
    &#39;bench_parallel&#39;,
    &#39;public&#39;,
    &#39;branches&#39;,
    ARRAY[&#39;bid&#39;, &#39;bbalance&#39;, &#39;filler&#39;],
    ARRAY[&#39;integer&#39;, &#39;integer&#39;, &#39;character(88)&#39;]
);

INSERT INTO pgpool_catalog.replicate_def VALUES (
    &#39;bench_parallel&#39;,
    &#39;public&#39;,
    &#39;tellers&#39;,
    ARRAY[&#39;tid&#39;, &#39;bid&#39;, &#39;tbalance&#39;, &#39;filler&#39;],
    ARRAY[&#39;integer&#39;, &#39;integer&#39;, &#39;integer&#39;, &#39;character(84)&#39;]
);</code></pre>
<p>Подготовленный файл Replicate_def_pgbench.sql находится в каталоге sample. Команда psql запускается с указанием пути к исходному коду, определяющему правила репликации, например, как показано ниже.</p>
<pre><code>psql -f sample/replicate_def_pgbench.sql -p 5432 pgpool</code></pre>
<h3 id="проверка-параллельного-запроса">Проверка параллельного запроса</h3>
<p>Для отражения изменений, сделанных в файле pgpool.conf, pgpool-II должен быть перезапущен. Пожалуйста, обращайтесь к разделу «Запуск/Остановка pgpool-II».</p>
<p>После настройки pgpool.conf и перезапуска pgpool-II давайте проверим хорошо ли работают параллельные запросы.</p>
<p>Сначала нам нужно создать базу данных, которая будет распределена. Мы назовем ее «bench_parallel». Эту базу данных нужно создать на всех узлах. Используйте команду createdb посредством pgpool-II и база данных будет создана на всех узлах.</p>
<pre><code>createdb -p 9999 bench_parallel</code></pre>
<p>Затем запустим pgbench с параметрами -i -s 3. Параметр -i инициализирует базу данных предопределенными таблицами и данными. Параметр -s указывает масштабный коэффициент для инициализации.</p>
<pre><code>pgbench -i -s 3 -p 9999 bench_parallel</code></pre>
<p>Созданные таблицы и данные в них показаны в разделе «Установка правил распределения данных».</p>
<p>Один из способов проверить корректно ли были распределены данные — выполнить запрос SELECT посредством pgpool-II и напрямую на бэкендах и сравнить результаты. Если все настроено правильно база данных «bench_parallel» должна быть распределена как показано ниже.</p>
<p><span> | c | c | </span> Имя таблицы &amp; Число строк<br />branches &amp; 3<br />tellers &amp; 30<br />accounts &amp; 300000<br />history &amp; 0<br /></p>
<p>Для проверки указанной выше информации на всех узлах и посредством pgpool-II используем простой скрипт на shell. Приведенный ниже скрипт покажет минимальное и максимальное значение в таблице accounts используя для соединения порты 5432, 5433, 5434 и 9999.</p>
<pre><code>for port in 5432 5433 5434i 9999; do
&gt;     echo $port
&gt;     psql -c &quot;SELECT min(aid), max(aid) FROM accounts&quot; \
&gt;     -p $port bench_parallel
&gt; done</code></pre>
<h2 id="master-slave-режим">Master-slave режим</h2>
<p>Этот режим предназначен для использования pgpool-II с другой репликацией (например Slony-I, Londiste). Информация про БД указывается как для репликации. master_slave_mode и load_balance_mode устанавливается в true. pgpool-II будет посылать запросы INSERT/UPDATE/DELETE на Master DB (1 в списке), а SELECT — использовать балансировку нагрузки, если это возможно.</p>
<p>При этом, DDL и DML для временной таблицы может быть выполнен только на мастере. Если нужен SELECT только на мастере, то для этого нужно использовать комментарий /*NO LOAD BALANCE*/ перед SELECT.</p>
<p>В Master/Slave режиме replication_mode должен быть установлен false, а master_slave_mode — true.</p>
<h3 id="streaming-replication-потоковая-репликация-1">Streaming Replication (Потоковая репликация)</h3>
<p>В master-slave режиме с потоковой репликацией, если мастер или слейв упал, возможно использовать отказоустоичивый функционал внутри pgpool-II. Автоматически отключив упавший нод PostgreSQL, pgpool-II переключится на следующий слейв как на новый мастер (при падении мастера), или останется работать на мастере (при падении слейва). В потоковой репликации, когда слейв становится мастером, требуется создать триггер файл (который указан в recovery.conf, параметр «trigger_file»), чтобы PostgreSQL перешел из режима восстановления в нормальный. Для этого можно создать небольшой скрипт:</p>
<pre><code>#! /bin/sh
# Failover command for streming replication.
# This script assumes that DB node 0 is primary, and 1 is standby.
# 
# If standby goes down, does nothing. If primary goes down, create a
# trigger file so that standby take over primary node.
#
# Arguments: $1: failed node id. $2: new master hostname. $3: path to
# trigger file.

failed_node=$1
new_master=$2
trigger_file=$3

# Do nothing if standby goes down.
if [ $failed_node = 1 ]; then
	exit 0;
fi

# Create trigger file.
/usr/bin/ssh -T $new_master /bin/touch $trigger_file

exit 0;</code></pre>
<p>Работает он просто: если падает слейв — скрипт ничего не выполняет, при падении мастера — создает триггер файл на новом мастере. Сохраним этот файл под именем «failover_stream.sh» и в pgpool.conf добавим:</p>
<pre><code>failover_command = &#39;/path_to_script/failover_stream.sh %d %H /tmp/trigger_file&#39;</code></pre>
<p>где «/tmp/trigger_file» — триггер файл, указаный в конфиге recovery.conf.</p>
<p>Теперь, если мастер СУБД упадет, слейв будет переключен из режима восстановления в обычный и сможет принимать запросы на запись.</p>
<h2 id="онлайн-восстановление">Онлайн восстановление</h2>
<p>pgpool-II в режиме репликации может синхронизировать базы данных и добавлять их как ноды к pgpool. Называется это «онлайн восстановление». Этот метод также может быть использован когда нужно вернуть в репликацию упавший нод базы данных.</p>
<p>Вся процедура выполняется в два задания. Несколько секунд или минут клиент может ждать подключения к pgpool, в то время как восстанавливается узел базы данных. Онлайн восстановление состоит из следующих шагов:</p>
<ul>
<li><p>CHECKPOINT;</p></li>
<li><p>Первый этап восстановления;</p></li>
<li><p>Ждем, пока все клиенты не отключатся;</p></li>
<li><p>CHECKPOINT;</p></li>
<li><p>Второй этап восстановления;</p></li>
<li><p>Запуск postmaster (выполнить pgpool_remote_start);</p></li>
<li><p>Восстанавливаем нод СУБД;</p></li>
</ul>
<p>Для работы онлайн восстановления потребуется указать следующие параметры:</p>
<ul>
<li><p><strong>backend_data_directory</strong></p>
<p>Каталог данных определенного PostgreSQL кластера.</p></li>
<li><p><strong>recovery_user</strong></p>
<p>Имя пользователя PostgreSQL.</p></li>
<li><p><strong>recovery_password</strong></p>
<p>Пароль пользователя PostgreSQL.</p></li>
<li><p><strong>recovery_1st_stage_command</strong></p>
<p>Параметр указывает команду для первого этапа онлайн восстановления. Файл с командами должен быть помещен в каталог данных СУБД кластера из соображений безопасности. Например, если<br />recovery_1st_stage_command = ’some_script’, то pgpool-II выполнит $PGDATA/some_script. Обратите внимание, что pgpool-II принимает подключения и запросы в то время как выполняется recovery_1st_stage.</p></li>
<li><p><strong>recovery_2nd_stage_command</strong></p>
<p>Параметр указывает команду для второго этапа онлайн восстановления. Файл с командами должен быть помещен в каталог данных СУБД кластера из-за проблем безопасности. Например, если<br />recovery_2st_stage_command = ’some_script’, то pgpool-II выполнит $PGDATA/some_script. Обратите внимание, что pgpool-II НЕ принимает подключения и запросы в то время как выполняется recovery_2st_stage. Таким образом, pgpool-II будет ждать пока все клиенты не закроют подключения.</p></li>
</ul>
<h3 id="streaming-replication-потоковая-репликация-2">Streaming Replication (Потоковая репликация)</h3>
<p>В master-slave режиме с потоковой репликацией, онлайн восстановление — отличное средство вернуть назад упавший нод PostgreSQL. Вернуть возможно только слейв ноды, таким методом не восстановить упавший мастер. Для восстановления мастера потребуется остановить все PostgreSQL ноды и pgpool-II (для восстановления из резервной копии мастера).</p>
<p>Для настройки онлайн восстановления нам потребуется:</p>
<ul>
<li><p>Установить «recovery_user». Обычно это «postgres».</p>
<pre><code>recovery_user = &#39;postgres&#39;</code></pre></li>
<li><p>Установить «recovery_password» для «recovery_user» для подключения к СУБД.</p>
<pre><code>recovery_password = &#39;some_password&#39;</code></pre></li>
<li><p>Настроить «recovery_1st_stage_command». Для этого создадим скрипт basebackup.sh и положим его в папку с данными мастера ($PGDATA), установив ему права на выполнение. Содержание скрипта:</p>
<pre><code>#! /bin/sh
# Recovery script for streaming replication.
# This script assumes that DB node 0 is primary, and 1 is standby.
#
datadir=$1
desthost=$2
destdir=$3

psql -c &quot;SELECT pg_start_backup(&#39;Streaming Replication&#39;, true)&quot; postgres

rsync -C -a --delete -e ssh --exclude postgresql.conf --exclude postmaster.pid \
--exclude postmaster.opts --exclude pg_log --exclude pg_xlog \
--exclude recovery.conf $datadir/ $desthost:$destdir/

ssh -T localhost mv $destdir/recovery.done $destdir/recovery.conf

psql -c &quot;SELECT pg_stop_backup()&quot; postgres</code></pre>
<p>При восстановления слейва, скрипт запускает бэкап мастера и через rsync передает данные с мастера на слейв. Для этого необходимо настроить SSH так, чтобы «recovery_user» мог заходить с мастера на слейв без пароля.</p>
<p>Далее добавим скрипт на выполнение для первого этапа онлайн востановления:</p>
<pre><code>recovery_1st_stage_command = &#39;basebackup.sh&#39;</code></pre></li>
<li><p>Оставляем «recovery_2nd_stage_command» пустым. После успешного выполнения первого этапа онлайн восстановления, разницу в данных, что успели записатся во время работы скрипта basebackup.sh, слейв заберет через WAL файлы с мастера.</p></li>
<li><p>Устанавливаем C и SQL функции для работы онлайн востановления на каждый нод СУБД.</p>
<pre><code>$ cd pgpool-II-x.x.x/sql/pgpool-recovery
$ make
$ make install
$ psql -f pgpool-recovery.sql template1</code></pre></li>
</ul>
<p>Вот и все. Теперь возможно использовать «pcp_recovery_node» для онлайн восстановления упавших слейвов.</p>
<h2 id="заключение-6">Заключение</h2>
<p>PgPool-II — прекрасное средство, которое нужно применять при масштабировании PostgreSQL.</p>
<h1 id="мультиплексоры-соединений">Мультиплексоры соединений</h1>
<h2 id="введение-11">Введение</h2>
<p>Мультиплексоры соединений (программы для создания пула соединений) позволяют уменьшить накладные расходы на базу данных, в случае, когда огромное количество физических соединений ведет к падению производительности PostgreSQL. Это особенно важно на Windows, когда система ограничивает большое количество соединений. Это также важно для веб-приложений, где количество соединений может быть очень большим.</p>
<p>Вот список программ, которые создают пулы соединений:</p>
<ul>
<li><p>PgBouncer</p></li>
<li><p>Pgpool</p></li>
</ul>
<h2 id="pgbouncer">PgBouncer</h2>
<p>Это мультиплексор соединений для PostgreSQL от компании Skype. Существуют три режима управления.</p>
<ul>
<li><p><strong>Session Pooling.</strong> Наиболее «вежливый» режим. При начале сессии клиенту выделяется соединение с сервером; оно приписано ему в течение всей сессии и возвращается в пул только после отсоединения клиента.</p></li>
<li><p><strong>Transaction Pooling.</strong> Клиент владеет соединением с бакендом только в течение транзакции. Когда PgBouncer замечает, что транзакция завершилась, он возвращает соединение назад в пул.</p></li>
<li><p><strong>Statement Pooling.</strong> Наиболее агрессивный режим. Соединение с бакендом возвращается назад в пул сразу после завершения запроса. Транзакции с несколькими запросами в этом режиме не разрешены, так как они гарантировано будут отменены. Также не работают подготовленные выражения (prepared statements) в этом режиме.</p></li>
</ul>
<p>К достоинствам PgBouncer относится:</p>
<ul>
<li><p>малое потребление памяти (менее 2 КБ на соединение);</p></li>
<li><p>отсутствие привязки к одному серверу баз данных;</p></li>
<li><p>реконфигурация настроек без рестарта.</p></li>
</ul>
<p>Базовая утилита запускается так:</p>
<pre><code>pgbouncer [-d][-R][-v][-u user] &lt;pgbouncer.ini&gt;</code></pre>
<p>Простой пример для конфига:</p>
<pre><code>template1 = host=127.0.0.1 port=5432 dbname=template1
[pgbouncer]
listen_port = 6543
listen_addr = 127.0.0.1
auth_type = md5
auth_file = userlist.txt
logfile = pgbouncer.log
pidfile = pgbouncer.pid
admin_users = someuser</code></pre>
<p>Нужно создать файл пользователей userlist.txt примерно такого содержания: ”someuser” ”same_password_as_in_server”</p>
<p>Админский доступ из консоли к базе данных pgbouncer:</p>
<pre><code>psql -h 127.0.0.1 -p 6543 pgbouncer</code></pre>
<p>Здесь можно получить различную статистическую информацию с помощью команды SHOW.</p>
<h2 id="pgpool-ii-vs-pgbouncer">PgPool-II vs PgBouncer</h2>
<p>Все очень просто. PgBouncer намного лучше работает с пулами соединений, чем PgPool-II. Если вам не нужны остальные возможности, которыми владеет PgPool-II (ведь пулы коннектов это мелочи к его функционалу), то конечно лучше использовать PgBouncer.</p>
<ul>
<li><p>PgBouncer потребляет меньше памяти, чем PgPool-II</p></li>
<li><p>у PgBouncer возможно настроить очередь соединений</p></li>
<li><p>в PgBouncer можно настраивать псевдо базы данных (на сервере они могут называтся по-другому)</p></li>
</ul>
<p>Хотя некоторые используют PgBouncer и PgPool-II совместно.</p>
<h1 id="кэширование-в-postgresql">Кэширование в PostgreSQL</h1>
<h2 id="введение-12">Введение</h2>
<p>Кэш или кеш — промежуточный буфер с быстрым доступом, содержащий информацию, которая может быть запрошена с наибольшей вероятностью. Кэширование SELECT запросов позволяет повысить производительность приложений и снизить нагрузку на PostgreSQL. Преимущества кэширования особенно заметны в случае с относительно маленькими таблицами, имеющими статические данные, например, справочными таблицами.</p>
<p>Многие СУБД могут кэшировать SQL запросы, и данная возможность идет у них, в основном, «из коробки». PostgreSQL не обладает подобным функционалом. Почему? Во-первых, мы теряем транзакционную чистоту происходящего в базе. Что это значит? Управление конкурентным доступом с помощью многоверсионности (MVCC — MultiVersion Concurrency Control) — один из механизмов обеспечения одновременного конкурентного доступа к БД, заключающийся в предоставлении каждому пользователю «снимка» БД, обладающего тем свойством, что вносимые данным пользователем изменения в БД невидимы другим пользователям до момента фиксации транзакции. Этот способ управления позволяет добиться того, что пишущие транзакции не блокируют читающих, и читающие транзакции не блокируют пишущих. При использовании кэширования, которому нет дела к транзакциям СУБД, «снимки» БД могут быть с неверными данными. Во-вторых, кеширование результатов запросов, в основном, должно происходить на стороне приложения, а не СУБД. В таком случае управление кэшированием может работать более гибко (включать и отключать его где потребуется для приложения), а СУБД будет заниматься своей непосредственной целью — хранением и обеспечение целостности данных.</p>
<p>Но, несмотря на все эти минусы, многим разработчикам требуется кэширование на уровне базы данных. Для организации кэширования существует два инструмента для PostgreSQL:</p>
<ul>
<li><p>Pgmemcache (с memcached)</p></li>
<li><p>Pgpool-II (query cache)</p></li>
</ul>
<h2 id="sec:pgmemcache">Pgmemcache</h2>
<p>Memcached<a href="#fn19" class="footnoteRef" id="fnref19"><sup>19</sup></a> — компьютерная программа, реализующая сервис кэширования данных в оперативной памяти на основе парадигмы распределенной хеш-таблицы. С помощью клиентской библиотеки позволяет кэшировать данные в оперативной памяти одного или нескольких из множества доступных серверов. Распределение реализуется путем сегментирования данных по значению хэша ключа по аналогии с сокетами хэш-таблицы. Клиентская библиотека используя ключ данных вычисляет хэш и использует его для выбора соответствующего сервера. Ситуация сбоя сервера трактуется как промах кэша, что позволяет повышать отказоустойчивость комплекса за счет наращивания количества memcached серверов и возможности производить их горячую замену.</p>
<p>Pgmemcache<a href="#fn20" class="footnoteRef" id="fnref20"><sup>20</sup></a> — это PostgreSQL API библиотека на основе libmemcached для взаимодействия с memcached. С помощью данной библиотеки PostgreSQL может записывать, считывать, искать и удалять данные из memcached. Посмотрим, что из себя представляет данный тип кэширования.</p>
<h3 id="установка-7">Установка</h3>
<p>Во время написания этой главы была доступна 2.0.4 версия pgmemcache<a href="#fn21" class="footnoteRef" id="fnref21"><sup>21</sup></a>. Pgmemcache будет устанавливаться и настраиваться на PostgreSQL версии 8.4 (для версии 9.0 все аналогично), операционная система — Ubuntu Server 10.10. Поскольку Pgmemcache идет как модуль, то потребуется PostgreSQL с PGXS (если уже не установлен, поскольку в сборках для Linux присутствует PGXS). Также потребуется memcached и libmemcached библиотека версии не ниже 0.38.</p>
<p>После скачивания и распаковки исходников, существует два варианта установки Pgmemcache:</p>
<ul>
<li><p><strong>Установка из исходников</strong></p>
<p>Для этого достаточно выполнить в консоли:</p>
<pre><code>$ make
$ sudo make install</code></pre></li>
<li><p><strong>Создание и установка deb пакета (для Debian, Ubuntu)</strong></p>
<p>Если у Вас на серверах стоит Debian или Ubuntu, то удобнее создать deb пакет нужной программы и распостранать его через собственный репозиторий на все сервера с PostgreSQL:</p>
<pre><code>$ sudo apt-get install libmemcached-dev postgresql-server-dev-8.4 libpq-dev devscripts yada flex bison
$ make deb84
# устанавливаем deb пакет
$ sudo dpkg -i ../postgresql-pgmemcache-8.4*.deb</code></pre>
<p>Для версии 2.0.4 утилита yada выдавала ошибку при создании deb пакета со следующим текстом:</p>
<pre><code>Cannot recognize source name in &#39;debian/changelog&#39; at /usr/bin/yada line 145, &lt;CHANGELOG&gt; line 1.
make: *** [deb84] Ошибка 9</code></pre>
<p>Для устранения этой ошибки потребуется удалить первую строчку текста в «debian/changelog» в каталоге, котором происходит сборка:</p>
<pre><code>$PostgreSQL: pgmemcache/debian/changelog,v 1.2 2010/05/05 19:56:50 ormod Exp $ &lt;---- удалить
pgmemcache (2.0.4) unstable; urgency=low

  * v2.0.4</code></pre>
<p>После устранения данной ошибки сборка deb-пакета должна пройти без проблем.</p></li>
</ul>
<h3 id="настройка-6">Настройка</h3>
<p>После успешной установки Pgmemcache потребуется добавить во все базы данных (на которых вы хотите использовать Pgmemcache) функции для работы с этой библиотекой:</p>
<pre><code>% psql [mydbname] [pguser]
[mydbname]=# BEGIN;
[mydbname]=# \i /usr/local/postgresql/share/contrib/pgmemcache.sql
# для Debian: \i /usr/share/postgresql/8.4/contrib/pgmemcache.sql
[mydbname]=# COMMIT;</code></pre>
<p>Теперь можно добавлять сервера memcached через memcache_server_add и работать с кэшем. Но есть одно но. Все сервера memcached придется задавать при каждом новом подключении к PostgreSQL. Это ограничение можно обойти, если настроить параметры в postgresql.conf файле:</p>
<ul>
<li><p>Добавить «pgmemcache» в shared_preload_libraries (автозагрузка библиотеки pgmemcache во время старта PostgreSQL)</p></li>
<li><p>Добавить «pgmemcache» в custom_variable_classes (устанавливаем переменную для pgmemcache)</p></li>
<li><p>Создаем «pgmemcache.default_servers», указав в формате «host:port» (port - опционально) через запятую. Например:</p>
<pre><code>pgmemcache.default_servers = &#39;127.0.0.1, 192.168.0.20:11211&#39; # подключили два сервера memcached</code></pre></li>
<li><p>Также можем настроить работу самой библиотеки pgmemcache через «pgmemcache.default_behavior». Настройки соответствуют настрокам libmemcached. Например:</p>
<pre><code>pgmemcache.default_behavior=&#39;BINARY_PROTOCOL:1&#39;</code></pre></li>
</ul>
<p>Теперь не требуется при подключении к PostgreSQL указывать сервера memcached.</p>
<h3 id="проверка-1">Проверка</h3>
<p>После успешной установки и настройки pgmemcache, становится доступен список команд для работы с memcached серверами.</p>
<p>[h] [tabular:pgmemcache1]</p>
<p><span>| &gt;p<span>7cm</span>| &gt;p<span>7cm</span> |</span> Команда &amp; Описание<br />memcache_server_add(’hostname:port’::TEXT)</p>
<p>memcache_server_add(’hostname’::TEXT) &amp; Добавляет memcached сервер в список доступных серверов. Если порт не указан, по умолчанию используется 11211.<br /></p>
<p>memcache_add(key::TEXT, value::TEXT, expire::TIMESTAMPTZ)</p>
<p>memcache_add(key::TEXT, value::TEXT, expire::INTERVAL)</p>
<p>memcache_add(key::TEXT, value::TEXT) &amp; Добавляет ключ в кэш, если ключ не существует.<br /></p>
<p>newval = memcache_decr(key::TEXT, decrement::INT4)</p>
<p>newval = memcache_decr(key::TEXT) &amp; Если ключ существует и является целым числом, происходит уменьшение его значения на указаное число (по умолчанию на единицу). Возвращает целое число после уменьшения.<br /></p>
<p>memcache_delete(key::TEXT, hold_timer::INTERVAL)</p>
<p>memcache_delete(key::TEXT)</p>
<p>&amp; Удаляет указанный ключ. Если указать таймер, то ключ с таким же названием может быть добавлен только после окончания таймера.<br /></p>
<p>memcache_flush_all()</p>
<p>&amp; Очищает все данные на всех memcached серверах.<br /></p>
<p>value = memcache_get(key::TEXT)</p>
<p>&amp; Выбирает ключ из кэша. Возвращает NULL, если ключ не существует, иначе — текстовую строку.<br /></p>
<p>memcache_get_multi(keys::TEXT[])</p>
<p>memcache_get_multi(keys::BYTEA[])</p>
<p>&amp; Получает массив ключей из кэша. Возвращает список найденных записей в виде «ключ=значение».<br /></p>
<p>newval = memcache_incr(key::TEXT, increment::INT4)</p>
<p>newval = memcache_incr(key::TEXT)</p>
<p>&amp; Если ключ существует и является целым числом, происходит увеличение его значения на указаное число (по умолчанию на единицу). Возвращает целое число после увеличения.<br /></p>
<p>memcache_replace(key::TEXT, value::TEXT, expire::TIMESTAMPTZ)</p>
<p>memcache_replace(key::TEXT, value::TEXT, expire::INTERVAL)</p>
<p>memcache_replace(key::TEXT, value::TEXT)</p>
<p>&amp; Заменяет значение для существующего ключа.<br /></p>
<p>memcache_set(key::TEXT, value::TEXT, expire::TIMESTAMPTZ)</p>
<p>memcache_set(key::TEXT, value::TEXT, expire::INTERVAL)</p>
<p>memcache_set(key::TEXT, value::TEXT)</p>
<p>&amp; Создает ключ со значение. Если такой ключ существует — заменяет в нем значение на указаное.<br /></p>
<p>stats = memcache_stats()</p>
<p>&amp; Возвращает статистику по всем серверам memcached.<br /></p>
<p>Посмотрим работу в СУБД данных функций. Для начала получим информацию по memcached серверах:</p>
<pre><code>pgmemcache=# SELECT memcache_stats();
      memcache_stats       
---------------------------
 
 Server: 127.0.0.1 (11211)
 pid: 1116
 uptime: 70
 time: 1289598098
 version: 1.4.5
 pointer_size: 32
 rusage_user: 0.0
 rusage_system: 0.24001
 curr_items: 0
 total_items: 0
 bytes: 0
 curr_connections: 5
 total_connections: 7
 connection_structures: 6
 cmd_get: 0
 cmd_set: 0
 get_hits: 0
 get_misses: 0
 evictions: 0
 bytes_read: 20
 bytes_written: 782
 limit_maxbytes: 67108864
 threads: 4
 
(1 row)</code></pre>
<p>Теперь сохраним данные в memcached и попробуем их забрать:</p>
<pre><code>pgmemcache=# SELECT memcache_add(&#39;some_key&#39;, &#39;test_value&#39;);
 memcache_add 
--------------
 t
(1 row)

pgmemcache=# SELECT memcache_get(&#39;some_key&#39;);
 memcache_get 
--------------
 test_value
(1 row)</code></pre>
<p>Можно также проверить работу счетчиков в memcached (данный функционал может пригодиться для создания последовательностей):</p>
<pre><code>pgmemcache=# SELECT memcache_add(&#39;some_seq&#39;, &#39;10&#39;);
 memcache_add 
--------------
 t
(1 row)

pgmemcache=# SELECT memcache_incr(&#39;some_seq&#39;);
 memcache_incr 
---------------
            11
(1 row)

pgmemcache=# SELECT memcache_incr(&#39;some_seq&#39;);
 memcache_incr 
---------------
            12
(1 row)

pgmemcache=# SELECT memcache_incr(&#39;some_seq&#39;, 10);
 memcache_incr 
---------------
            22
(1 row)

pgmemcache=# SELECT memcache_decr(&#39;some_seq&#39;);
 memcache_decr 
---------------
            21
(1 row)

pgmemcache=# SELECT memcache_decr(&#39;some_seq&#39;);
 memcache_decr 
---------------
            20
(1 row)

pgmemcache=# SELECT memcache_decr(&#39;some_seq&#39;, 6);
 memcache_decr 
---------------
            14
(1 row)</code></pre>
<p>Для работы с pgmemcache лучше создать функции и, если требуется, активировать эти функции через триггеры.</p>
<p>Например, наше приложение кэширует зашифрованые пароли пользователей в memcached (для более быстрого доступа), и нам требуется обновлять информацию в кэше, если она изменяется в СУБД. Создаем функцию:</p>
<pre><code>CREATE OR REPLACE FUNCTION auth_passwd_upd() RETURNS TRIGGER AS $$
	BEGIN
	IF OLD.passwd != NEW.passwd THEN
		PERFORM memcache_set(&#39;user_id_&#39; || NEW.user_id || &#39;_password&#39;, NEW.passwd);
	END IF;
	RETURN NEW;
END;
$$ LANGUAGE &#39;plpgsql&#39;;</code></pre>
<p>Активируем триггер для обновления таблицы пользователей:</p>
<pre><code>CREATE TRIGGER auth_passwd_upd_trg AFTER UPDATE ON passwd FOR EACH ROW EXECUTE PROCEDURE auth_passwd_upd();</code></pre>
<p>Но(!!!) данный пример транзакционно не безопасен — при отмене транзации кэш не вернется на старое значение. Поэтому лучше очищать старые данные:</p>
<pre><code>CREATE OR REPLACE FUNCTION auth_passwd_upd() RETURNS TRIGGER AS $$
BEGIN
	IF OLD.passwd != NEW.passwd THEN
		PERFORM memcache_delete(&#39;user_id_&#39; || NEW.user_id || &#39;_password&#39;);
	END IF;
	RETURN NEW;
END;$$ LANGUAGE &#39;plpgsql&#39;;</code></pre>
<p>Также нужен триггер на чистку кэша при удалении записи из СУБД:</p>
<pre><code>CREATE TRIGGER auth_passwd_del_trg AFTER DELETE ON passwd FOR EACH ROW EXECUTE PROCEDURE auth_passwd_upd();</code></pre>
<p>Замечу от себя, что создавать кэш в memcached на кешированый пароль нового пользователя (или обновленного) лучше через приложение.</p>
<h3 id="заключение-7">Заключение</h3>
<p>PostgreSQL с помощью Pgmemcache библиотеки позволяет работать с memcached серверами, что может потребоваться в определенных случаях для кэширования данных напрямую с СУБД. Удобство данной библиотеки заключается в полном доступе к функциям memcached, но вот готовой реализации кэширование SQL запросов тут нет, и её придется дорабатывать вручную через функции и триггеры PostgreSQL.</p>
<h1 id="расширения">Расширения</h1>
<h2 id="введение-13">Введение</h2>
<p>Один из главных плюсов PostgreSQL это возможность расширения его функционала с помощью расширений. В данной статье я затрону только самые интересные и популярные из существующих расширений.</p>
<h2 id="postgis">PostGIS</h2>
<p><strong>Лицензия</strong>: Open Source</p>
<p><strong>Ссылка</strong>: <a href="http://www.postgis.org/">www.postgis.org</a></p>
<p>PostGIS добавляет поддержку для географических объектов в PostgreSQL. По сути PostGIS позволяет использовать PostgreSQL в качестве бэкэнда пространственной базы данных для геоинформационных систем (ГИС), так же, как ESRI SDE или пространственного расширения Oracle. PostGIS соответствует OpenGIS «Простые особенности. Спецификация для SQL» и был сертифицирован.</p>
<h2 id="pgsphere">pgSphere</h2>
<p><strong>Лицензия</strong>: Open Source</p>
<p><strong>Ссылка</strong>: <a href="http://pgsphere.projects.postgresql.org/">pgsphere.projects.postgresql.org</a></p>
<p>pgSphere обеспечивает PostgreSQL сферическими типами данных, а также функциями и операторами для работы с ними. Используется для работы с географическими (может использоваться вместо PostGIS) или астронамическими типами данных.</p>
<h2 id="hstore">HStore</h2>
<p><strong>Лицензия</strong>: Open Source</p>
<p>HStore – расширение, которое реализует тип данных для хранения ключ/значение в пределах одного значения в PostgreSQL (например, в одном текстовом поле). Это может быть полезно в различных ситуациях, таких как строки с многими атрибутами, которые редко вибираются, или полу-структурированные данные. Ключи и значения являются простыми текстовыми строками.</p>
<h3 id="пример-использования">Пример использования</h3>
<p>Для начала активируем расширение:</p>
<pre><code># CREATE EXTENSION hstore;</code></pre>
<p>Проверим работу расширения:</p>
<pre><code># SELECT &#39;a=&gt;1,a=&gt;2&#39;::hstore;
  hstore  
----------
 &quot;a&quot;=&gt;&quot;1&quot;
(1 row)</code></pre>
<p>Как видно на листинге [lst:hstore2] ключи в hstore уникальны. Создадим таблицу и заполним её данными:</p>
<pre><code>CREATE TABLE products (
   id serial PRIMARY KEY,
   name varchar,
   attributes hstore
);   
INSERT INTO products (name, attributes)
VALUES (
  &#39;Geek Love: A Novel&#39;,
  &#39;author    =&gt; &quot;Katherine Dunn&quot;,
  pages     =&gt; 368,
  category  =&gt; fiction&#39;
),
(
 &#39;Leica M9&#39;,
 &#39;manufacturer  =&gt; Leica,
  type          =&gt; camera,
  megapixels    =&gt; 18,
  sensor        =&gt; &quot;full-frame 35mm&quot;&#39;
),
( &#39;MacBook Air 11&#39;,
 &#39;manufacturer  =&gt; Apple,
  type          =&gt; computer,
  ram           =&gt; 4GB,
  storage       =&gt; 256GB,
  processor     =&gt; &quot;1.8 ghz Intel i7 duel core&quot;,
  weight        =&gt; 2.38lbs&#39;
);</code></pre>
<p>Теперь можно производить поиск по ключу:</p>
<pre><code># SELECT name, attributes-&gt;&#39;pages&#39; as page FROM products WHERE attributes ? &#39;pages&#39;;
        name        | page 
--------------------+------
 Geek Love: A Novel | 368
(1 row)</code></pre>
<p>Или по значению ключа:</p>
<pre><code># SELECT name, attributes-&gt;&#39;manufacturer&#39; as manufacturer FROM products WHERE attributes-&gt;&#39;type&#39; = &#39;computer&#39;;
       name      | manufacturer 
 ----------------+--------------
  MacBook Air 11 | Apple
 (1 row)</code></pre>
<p>Создание индексов:</p>
<pre><code>CREATE INDEX products_hstore_index ON products USING GIST (attributes);
CREATE INDEX products_hstore_index ON products USING GIN (attributes);</code></pre>
<p>Можно также cоздавать индекс на ключ:</p>
<pre><code>CREATE INDEX product_manufacturer 
   ON products ((products.attributes-&gt;&#39;manufacturer&#39;));</code></pre>
<h3 id="заключение-8">Заключение</h3>
<p>HStore — расширение для удобного и индексируемого хранения слабоструктурированых данных в PostgreSQL.</p>
<h2 id="plv8">PLV8</h2>
<p><strong>Лицензия</strong>: Open Source</p>
<p><strong>Ссылка</strong>: <a href="http://code.google.com/p/plv8js/">code.google.com/p/plv8js</a></p>
<p>PLV8 является расширением, которое предоставляет PostgreSQL процедурный язык с движком V8 JavaScript. С помощью этого расширения можно писать в PostgreSQL JavaScript функции, которые можно вызывать из SQL.</p>
<h3 id="скорость-работы">Скорость работы</h3>
<p>V8<a href="#fn22" class="footnoteRef" id="fnref22"><sup>22</sup></a> компилирует JavaScript код непосредственно в машинный код и с помощью этого достигается высокая скорость работы. Для примера расмотрим расчет числа Фибоначчи. Вот функция написана на plpgsql:</p>
<pre><code>CREATE OR REPLACE FUNCTION
psqlfib(n int) RETURNS int AS $$
 BEGIN
     IF n &lt; 2 THEN
         RETURN n;
     END IF;
     RETURN psqlfib(n-1) + psqlfib(n-2);
 END;
$$ LANGUAGE plpgsql IMMUTABLE STRICT;</code></pre>
<p>Замерим скорость её работы:</p>
<pre><code>SELECT n, psqlfib(n) FROM generate_series(0,30,5) as n;
 n  | psqlfib 
----+---------
  0 |       0
  5 |       5
 10 |      55
 15 |     610
 20 |    6765
 25 |   75025
 30 |  832040
(7 rows)

Time: 16003,257 ms</code></pre>
<p>Теперь сделаем то же самое, но с использованием PLV8:</p>
<pre><code>CREATE OR REPLACE FUNCTION
fib(n int) RETURNS int as $$

  function fib(n) {
    return n&lt;2 ? n : fib(n-1) + fib(n-2)
  }
  return fib(n)

$$ LANGUAGE plv8 IMMUTABLE STRICT;</code></pre>
<p>Замерим скорость работы:</p>
<pre><code>SELECT n, fib(n) FROM generate_series(0,30,5) as n;
 n  |  fib   
----+--------
  0 |      0
  5 |      5
 10 |     55
 15 |    610
 20 |   6765
 25 |  75025
 30 | 832040
(7 rows)

Time: 59,254 ms</code></pre>
<p>Как видим PLV8 приблизительно в 270 (16003.257/59.254) раз быстрее plpgsql. Можно ускорить работу расчета чисел Фибоначи на PLV8 за счет кеширования:</p>
<pre><code>CREATE OR REPLACE FUNCTION
fib1(n int) RETURNS int as $$
  var memo = {0: 0, 1: 1};
  function fib(n) {
    if(!(n in memo))
      memo[n] = fib(n-1) + fib(n-2)
    return memo[n]
  }
  return fib(n);
$$ LANGUAGE plv8 IMMUTABLE STRICT;</code></pre>
<p>Замерим скорость работы:</p>
<pre><code>SELECT n, fib1(n) FROM generate_series(0,30,5) as n;
 n  |  fib1  
----+--------
  0 |      0
  5 |      5
 10 |     55
 15 |    610
 20 |   6765
 25 |  75025
 30 | 832040
(7 rows)

Time: 0,766 ms</code></pre>
<p>Теперь расчет на PLV8 приблизительно в 20892 (16003.257/0.766) раза быстрее, чем на plpgsql.</p>
<h3 id="использование">Использование</h3>
<p>Одним из полезных применений PLV8 может быть создание на базе PostgreSQL документоориентированного хранилища. Для хранения неструктурированных данных можно использовать hstore, но у него есть свои недостатки:</p>
<ul>
<li><p>нет вложенности</p></li>
<li><p>все данные (ключ и значение по ключу) это строка</p></li>
</ul>
<p>Для хранения данных многие документоориентированные базы данных используют JSON (MongoDB, CouchDB, Couchbase и т.д.). Для этого, начиная с PostgreSQL 9.2, добавлен тип данных JSON. Такой тип можно добавить для PostgreSQL 9.1 и ниже используя PLV8 и DOMAIN:</p>
<pre><code>CREATE OR REPLACE FUNCTION 
valid_json(json text)
RETURNS BOOLEAN AS $$
  try { 
    JSON.parse(json); return true; 
  } catch(e) { 
    return false;
  }
$$ LANGUAGE plv8 IMMUTABLE STRICT;

CREATE DOMAIN json AS TEXT 
CHECK(valid_json(VALUE));</code></pre>
<p>Функция «valid_json» используется для проверки JSON данных. Пример использования:</p>
<pre><code>$ INSERT INTO members 
VALUES(&#39;not good json&#39;);
ERROR:  value for domain json 
violates check constraint &quot;json_check&quot;
$ INSERT INTO members 
VALUES(&#39;{&quot;good&quot;: &quot;json&quot;, &quot;is&quot;: true}&#39;);
INSERT 0 1
$ select * from members;
	    profile            
------------------------------
  {&quot;good&quot;: &quot;json&quot;, &quot;is&quot;: true}
(1 row)</code></pre>
<p>Рассмотрим пример использования JSON для хранения данных и PLV8 для их поиска. Для начала создадим таблицу и заполним её данными:</p>
<pre><code>$ CREATE TABLE members ( id SERIAL, profile json );
$ SELECT count(*) FROM members;
  count  
---------
 1000000
(1 row)

Time: 201.109 ms</code></pre>
<p>В «profile» поле мы записали приблизительно такую структуру JSON:</p>
<pre><code>{                                  +
  &quot;name&quot;: &quot;Litzy Satterfield&quot;,     +
  &quot;age&quot;: 24,                       +
  &quot;siblings&quot;: 2,                   +
  &quot;faculty&quot;: false,                +
  &quot;numbers&quot;: [                     +
    {                              +
      &quot;type&quot;:   &quot;work&quot;,            +
      &quot;number&quot;: &quot;684.573.3783 x368&quot;+
    },                             +
    {                              +
      &quot;type&quot;:   &quot;home&quot;,            +
      &quot;number&quot;: &quot;625.112.6081&quot;     +
    }                              +
  ]                                +
}</code></pre>
<p>Теперь создадим функцию для вывода значения по ключу из JSON (в данном случае ожидаем цифру):</p>
<pre><code>CREATE OR REPLACE FUNCTION get_numeric(json_raw json, key text)
RETURNS numeric AS $$
  var o = JSON.parse(json_raw);
  return o[key];
$$ LANGUAGE plv8 IMMUTABLE STRICT;</code></pre>
<p>Теперь мы можем произвести поиск по таблице, фильтруя по значениям ключей «age», «siblings» или другим числовым полям:</p>
<pre><code>$ SELECT * FROM members WHERE get_numeric(profile, &#39;age&#39;) = 36;
Time: 9340.142 ms
$ SELECT * FROM members WHERE get_numeric(profile, &#39;siblings&#39;) = 1;
Time: 14320.032 ms</code></pre>
<p>Поиск работает, но скорость очень маленькая. Чтобы увеличить скорость, нужно создать функциональные индексы:</p>
<pre><code>CREATE INDEX member_age ON members (get_numeric(profile, &#39;age&#39;));
CREATE INDEX member_siblings ON members (get_numeric(profile, &#39;siblings&#39;));</code></pre>
<p>С индексами скорость поиска по JSON станет достаточно высокая:</p>
<pre><code>$ SELECT * FROM members WHERE get_numeric(profile, &#39;age&#39;) = 36;
Time: 57.429 ms
$ SELECT * FROM members WHERE get_numeric(profile, &#39;siblings&#39;) = 1;
Time: 65.136 ms
$ SELECT count(*) from members where  get_numeric(profile, &#39;age&#39;) = 26 and get_numeric(profile, &#39;siblings&#39;) = 1;
Time: 106.492 ms</code></pre>
<p>Получилось отличное документоориентированное хранилище из PostgreSQL.</p>
<p>PLV8 позволяет использовать некоторые JavaScript библиотеки внутри PostgreSQL. Вот пример рендера Mustache<a href="#fn23" class="footnoteRef" id="fnref23"><sup>23</sup></a> темплейтов:</p>
<pre><code>CREATE OR REPLACE FUNCTION mustache(template text, view json)
RETURNS text as $$
  // …400 lines of mustache.js…
  return Mustache.render(template, JSON.parse(view))
$$ LANGUAGE plv8 IMMUTABLE STRICT;</code></pre>
<pre><code>$ SELECT mustache(
  &#39;hello {{#things}}{{.}} {{/things}}:) {{#data}}{{key}}{{/data}}&#39;,
  &#39;{&quot;things&quot;: [&quot;world&quot;, &quot;from&quot;, &quot;postgresql&quot;], &quot;data&quot;: {&quot;key&quot;: &quot;and me&quot;}}&#39;
);
		mustache                
---------------------------------------
  hello world from postgresql :) and me
(1 row)

Time: 0.837 ms</code></pre>
<p>Этот пример показывает как можно использовать PLV8. В действительности рендерить Mustache в PostgreSQL не лучшая идея.</p>
<h3 id="вывод">Вывод</h3>
<p>PLV8 расширение предоставляет PostgreSQL процедурный язык с движком V8 JavaScript, с помощью которого можно работать с JavaScript билиотеками, индексировать JSON данные и использовать его как более быстрый язык.</p>
<h2 id="smlar">Smlar</h2>
<p><strong>Лицензия</strong>: Open Source</p>
<p><strong>Ссылка</strong>: <a href="http://sigaev.ru/git/gitweb.cgi?p=smlar.git;a=blob;hb=HEAD;f=README">sigaev.ru</a></p>
<p>Поиск похожести в больших базах данных является важным вопросом в настоящее время для таких систем как блоги (похожие статьи), интернет-магазины (похожие продукты), хостинг изображений (похожие изображения, поиск дубликатов изображений) и т.д. PostgreSQL позволяет сделать такой поиск более легким. Прежде всего, необходимо понять, как мы будем вычислять сходство двух объектов.</p>
<h3 id="похожесть">Похожесть</h3>
<p>Любой объект может быть описан как список характеристик. Например, статья в блоге может быть описана тегами, продукт в интернет-магазине может быть описан размером, весом, цветом и т.д. Это означает, что для каждого объекта можно создать цифровую подпись — массив чисел, описывающих объект (отпечатки пальцев<a href="#fn24" class="footnoteRef" id="fnref24"><sup>24</sup></a>, n-grams<a href="#fn25" class="footnoteRef" id="fnref25"><sup>25</sup></a>). То есть нужно создать массив из цифр для описания каждого объекта. Что делать дальше?</p>
<h3 id="расчет-похожести">Расчет похожести</h3>
<p>Есть несколько методов вычисления похожести сигнатур объектов. Прежде всего, легенда для расчетов:</p>
<p><span class="math"><em>N</em><sub><em>a</em></sub></span>, <span class="math"><em>N</em><sub><em>b</em></sub></span> — количество уникальных элементов в массивах</p>
<p><span class="math"><em>N</em><sub><em>u</em></sub></span> — количество уникальных элементов при объединении массивов</p>
<p><span class="math"><em>N</em><sub><em>i</em></sub></span> — количество уникальных элементов при пересечение массивов</p>
<p>Один из простейших расчетов похожести двух объектов - количество уникальных элементов при пересечение массивов делить на количество уникальных элементов в двух массивах:</p>
<p><br /><span class="math">$$\label{eq:smlar1}
 S(A,B) = \frac{N_{i}}{(N_{a}+N_{b})}$$</span><br /></p>
<p>или проще</p>
<p><br /><span class="math">$$\label{eq:smlar2}
 S(A,B) = \frac{N_{i}}{N_{u}}$$</span><br /></p>
<p>Преимущества:</p>
<ul>
<li><p>Легко понять</p></li>
<li><p>Скорость расчета: <span class="math"><em>N</em> * log<em>N</em></span></p></li>
<li><p>Хорошо работает на похожих и больших <span class="math"><em>N</em><sub><em>a</em></sub></span> и <span class="math"><em>N</em><sub><em>b</em></sub></span></p></li>
</ul>
<p>Также похожесть можно рассчитана по формуле косинусов<a href="#fn26" class="footnoteRef" id="fnref26"><sup>26</sup></a>:</p>
<p><br /><span class="math">$$\label{eq:smlar3}
 S(A,B) = \frac{N_{i}}{\sqrt{N_{a}*N_{b}}}$$</span><br /></p>
<p>Преимущества:</p>
<ul>
<li><p>Скорость расчета: <span class="math"><em>N</em> * log<em>N</em></span></p></li>
<li><p>Отлично работает на больших <span class="math"><em>N</em></span></p></li>
</ul>
<p>Но у обоих этих методов есть общие проблемы:</p>
<ul>
<li><p>Если элементов мало, то разброс похожести не велик</p></li>
<li><p>Глобальная статистика: частые элементы ведут к тому, что вес ниже</p></li>
<li><p>Спамеры и недобросовестные пользователи. Один «залетевший дятел» разрушит цивилизацию - алгоритм перестанет работать на Вас.</p></li>
</ul>
<p>Для избежания этих проблем можно воспользоваться TF/IDF<a href="#fn27" class="footnoteRef" id="fnref27"><sup>27</sup></a> метрикой:</p>
<p><br /><span class="math">$$\label{eq:smlar4}
 S(A,B) = \frac{\sum_{i &lt; N_{a}, j &lt; N_{b}, A_{i} = B_{j}}TF_{i} * TF_{j}}{\sqrt{\sum_{i &lt; N_{a}}TF_{i}^{2} * \sum_{j &lt; N_{b}}TF_{j}^{2}}}$$</span><br /></p>
<p>где инвертированный вес элемента в коллекции:</p>
<p><br /><span class="math">$$\label{eq:smlar5}
 IDF_{element} = \log{(\frac{N_{objects}}{N_{objects\ with\ element}} + 1)}$$</span><br /></p>
<p>и вес элемента в массиве:</p>
<p><br /><span class="math"><em>T</em><em>F</em><sub><em>e</em><em>l</em><em>e</em><em>m</em><em>e</em><em>n</em><em>t</em></sub> = <em>I</em><em>D</em><em>F</em><sub><em>e</em><em>l</em><em>e</em><em>m</em><em>e</em><em>n</em><em>t</em></sub> * <em>N</em><sub><em>o</em><em>c</em><em>c</em><em>u</em><em>r</em><em>r</em><em>e</em><em>n</em><em>c</em><em>e</em><em>s</em></sub></span><br /></p>
<p>Не пугайтесь! Все эти алгоритмы встроены в smlar расширение, учить (или даже глубоко понимать) их не нужно. Главное понимать, что для TF/IDF метрики требуются вспомогательная таблица для хранения данных, по сравнению с другими простыми метриками.</p>
<h3 id="smlar-1">Smlar</h3>
<p>Перейдем к практике. Олег Бартунов и Теодор Сигаев разработали PostgreSQL расширение smlar, которое предоставляет несколько методов для расчета похожести массивов (все встроенные типы данных поддерживаются) и оператор для расчета похожести с поддержкой индекса на базе GIST и GIN. Для начала установим это расширение (PostgreSQL уже должен быть установлен):</p>
<pre><code>git clone git://sigaev.ru/smlar
cd smlar
USE_PGXS=1 make &amp;&amp; make install</code></pre>
<p>В PostgreSQL 9.2 и выше это расширение должно встать без проблем, для PostgreSQL 9.1 и ниже вам нужно сделать небольшое исправление в исходниках. В файле «smlar_guc.c» в строке 214 сделайте изменение с:</p>
<pre><code>set_config_option(&quot;smlar.threshold&quot;, buf, PGC_USERSET, PGC_S_SESSION ,GUC_ACTION_SET, true, 0);</code></pre>
<p>на (нужно убрать последний аргумент):</p>
<pre><code>set_config_option(&quot;smlar.threshold&quot;, buf, PGC_USERSET, PGC_S_SESSION ,GUC_ACTION_SET, true);</code></pre>
<p>Теперь проверим расширение:</p>
<pre><code>$ psql
psql (9.2.1)
Type &quot;help&quot; for help.

test=# CREATE EXTENSION smlar;
CREATE EXTENSION

test=# SELECT smlar(&#39;{1,4,6}&#39;::int[], &#39;{5,4,6}&#39;::int[]);
  smlar  
----------
 0.666667
(1 row)

test=# SELECT smlar(&#39;{1,4,6}&#39;::int[], &#39;{5,4,6}&#39;::int[], &#39;N.i / sqrt(N.a * N.b)&#39; );
  smlar  
----------
 0.666667
(1 row)</code></pre>
<p>Расширение установлено успешно, если у Вас такой же вывод в консоли. Методы, которые предоставляет это расширение:</p>
<ul>
<li><p>«float4 smlar(anyarray, anyarray)» — вычисляет похожесть двух массивов. Массивы должны быть одного типа.</p></li>
<li><p>«float4 smlar(anyarray, anyarray, bool useIntersect)» — вычисляет похожесть двух массивы составных типов. Составной тип выглядит следующим образом:</p>
<pre><code>CREATE TYPE type_name AS (element_name anytype, weight_name float4);</code></pre>
<p>useIntersect параметр для использования пересекающихся элементов в знаменателе</p></li>
<li><p>«float4 smlar( anyarray a, anyarray b, text formula )» — вычисляет похожесть двух массивов по данной формуле, массивы должны быть того же типа. Доступные переменные в формуле:</p>
<ul>
<li><p>N.i — количество общих элементов в обоих массивов (пересечение)</p></li>
<li><p>N.a — количество уникальных элементов первого массива</p></li>
<li><p>N.b — количество уникальных элементов второго массива</p></li>
</ul></li>
<li><p>«anyarray % anyarray» — возвращает истину, если похожесть массивов больше, чем указанный предел. Предел указывается в конфиге PostgreSQL:</p>
<pre><code>custom_variable_classes = &#39;smlar&#39;
smlar.threshold = 0.8 # предел от 0 до 1</code></pre>
<p>Также в конфиге можно указать дополнительные настройки для smlar:</p>
<pre><code>custom_variable_classes = &#39;smlar&#39;
smlar.threshold = 0.8 # предел от 0 до 1
smlar.type = &#39;cosine&#39; # по какой формуле производить расчет похожести: cosine, tfidf, overlap
smlar.stattable = &#39;stat&#39; # Имя таблицы для хранения статистики при работе по формуле tfidf</code></pre>
<p>Более подробно можно прочитать в README этого расширения.</p></li>
</ul>
<p>GiST и GIN индексы поддерживаются для оператора «%».</p>
<h3 id="пример-поиск-дубликатов-картинок">Пример: поиск дубликатов картинок</h3>
<p>Рассмотрим простой пример поиска дубликатов картинок. Алгоритм помогает найти похожие изображения, которые, например, незначительно отличаются (изображение обесцветили, добавили водяные знаки, пропустили через фильтры). Но, поскольку точность мала, то у алгоритма есть и позитивная сторона — скорость работы. Как можно определить, что картинки похожи? Самый простой метод — сравнивать попиксельно два изображения. Но скорость такой работы будет не велика на больших разрешениях. Тем более, такой метод не учитывает, что могли изменять уровень света, насыщенность и прочие характеристики изображения. Нам нужно создать сигнатуру для картинок в виде массива цифр:</p>
<p>[fig:smlar1]</p>
<ul>
<li><p>Создаем пиксельную матрицу к изображению (изменения размера изображения к требуемоему размеру пиксельной матрице), например 15X15 пикселей(Рис. [fig:smlar1]).</p></li>
<li><p>Рассчитаем интенсивность каждого пикселя (интенсивность вычисляется по формуле <span class="math">$0.299 * \textup{красный} + 0.587 * \textup{зеленый} + 0.114 * \textup{синий}$</span>). Интенсивность поможет нам находить похожие изображения, не обращая внимание на используемые цвета в них.</p></li>
<li><p>Узнаем отношение интенсивности каждого пикселя к среднему значению интенсивности по всей матрице(Рис. [fig:smlar2]).</p></li>
<li><p>Генерируем уникальное число для каждой ячейки (отношение интенсивности + координаты ячейки).</p></li>
<li><p>Сигнатура для картинки готова.</p></li>
</ul>
<p>[fig:smlar2]</p>
<p>Создаем таблицу, где будем хранить имя картинки, путь к ней и её сигнатуру:</p>
<pre><code>CREATE TABLE images (
 id serial PRIMARY KEY,
 name varchar(50),
 img_path varchar(250),
 image_array integer[]
);</code></pre>
<p>Создадим GIN или GIST индекс:</p>
<pre><code>CREATE INDEX image_array_gin ON images USING GIN(image_array _int4_sml_ops);
CREATE INDEX image_array_gist ON images USING GIST(image_array _int4_sml_ops);</code></pre>
<p>Теперь можно произвести поиск дубликатов:</p>
<pre><code>test=# SELECT count(*) from images;
  count 
---------
 1000000
(1 row)

test=# EXPLAIN ANALYZE SELECT count(*) FROM images WHERE images.image_array % &#39;{1010259,1011253,...,2423253,2424252}&#39;::int[];

 Bitmap Heap Scan on images  (cost=286.64..3969.45 rows=986 width=4) (actual time=504.312..2047.533 rows=200000 loops=1)
   Recheck Cond: (image_array % &#39;{1010259,1011253,...,2423253,2424252}&#39;::integer[])
   -&gt;  Bitmap Index Scan on image_array_gist  (cost=0.00..286.39 rows=986 width=0) (actual time=446.109..446.109 rows=200000 loops=1)
         Index Cond: (image_array % &#39;{1010259,1011253,...,2423253,2424252}&#39;::integer[])
 Total runtime: 2152.411 ms
(5 rows)</code></pre>
<p>где «’<span>1010259,...,2424252</span>’::int[]» — сигнатура изображения, для которой пытаемся найти похожие изображения. С помощью «smlar.threshold» управляем % похожести картинок (при каком проценте они будут попадать в выборку).</p>
<p>Дополнительно можем добавить сортировку по самым похожим изображениям:</p>
<pre><code>test=# EXPLAIN ANALYZE SELECT smlar(images.image_array, &#39;{1010259,...,2424252}&#39;::int[]) as similarity FROM images WHERE images.image_array % &#39;{1010259,1011253, ...,2423253,2424252}&#39;::int[] ORDER BY similarity DESC; 


 Sort  (cost=4020.94..4023.41 rows=986 width=924) (actual time=2888.472..2901.977 rows=200000 loops=1)
   Sort Key: (smlar(image_array, &#39;{...,2424252}&#39;::integer[]))
   Sort Method: quicksort  Memory: 15520kB
   -&gt;  Bitmap Heap Scan on images  (cost=286.64..3971.91 rows=986 width=924) (actual time=474.436..2729.638 rows=200000 loops=1)
         Recheck Cond: (image_array % &#39;{...,2424252}&#39;::integer[])
         -&gt;  Bitmap Index Scan on image_array_gist  (cost=0.00..286.39 rows=986 width=0) (actual time=421.140..421.140 rows=200000 loops=1)
               Index Cond: (image_array % &#39;{...,2424252}&#39;::integer[])
 Total runtime: 2912.207 ms
(8 rows)</code></pre>
<p>Достаточно эффективно для 1 милиона записей. P.S. Мои данные не помещались в память и PostgreSQL читал их с диска, поэтому скорость будет лучше, если у Вас эта таблица будет в памяти (или будут быстрые диски).</p>
<h3 id="вывод-1">Вывод</h3>
<p>Smlar расширение может быть использовано в системах, где нам нужно искать похожие объекты, такие как: тексты, темы, блоги, товары, изображения, видео, отпечатки пальцев и прочее.</p>
<h2 id="postpic">PostPic</h2>
<p><strong>Лицензия</strong>: Open Source</p>
<p><strong>Ссылка</strong>: <a href="http://github.com/drotiro/postpic">github.com/drotiro/postpic</a></p>
<p>PostPic расширение для СУБД PostgreSQL, которое позволяет обрабатывать изображения в базе данных, как PostGIS делает это с пространственными данными. Он добавляет новый типа поля «image», а также несколько функций для обработки изображений (обрезка краев, создание миниатюр, поворот и т.д.) и извлечений его атрибутов (размер, тип, разрешение).</p>
<h2 id="fuzzystrmatch">Fuzzystrmatch</h2>
<p><strong>Лицензия</strong>: Open Source</p>
<p>Fuzzystrmatch предоставляет несколько функций для определения сходства и расстояния между строками. Функция soundex используется для согласования сходно звучащих имен путем преобразования их в одинаковый код. Функция difference преобразует две строки в soundex код, а затем сообщает количество совпадающих позиций кода. В soundex код состоит из четырех символов, поэтому результат будет от нуля до четырех: 0 — не совпадают, 4 — точное совпадение (таким образом, функция названа неверно — как название лучше подходит similarity):</p>
<pre><code># CREATE EXTENSION fuzzystrmatch;
CREATE EXTENSION
# SELECT soundex(&#39;hello world!&#39;);
 soundex 
---------
 H464
(1 row)

# SELECT soundex(&#39;Anne&#39;), soundex(&#39;Ann&#39;), difference(&#39;Anne&#39;, &#39;Ann&#39;);
 soundex | soundex | difference 
---------+---------+------------
 A500    | A500    |          4
(1 row)

# SELECT soundex(&#39;Anne&#39;), soundex(&#39;Andrew&#39;), difference(&#39;Anne&#39;, &#39;Andrew&#39;);
 soundex | soundex | difference 
---------+---------+------------
 A500    | A536    |          2
(1 row)

# SELECT soundex(&#39;Anne&#39;), soundex(&#39;Margaret&#39;), difference(&#39;Anne&#39;, &#39;Margaret&#39;);
 soundex | soundex | difference 
---------+---------+------------
 A500    | M626    |          0
(1 row)

# CREATE TABLE s (nm text);
CREATE TABLE
# INSERT INTO s VALUES (&#39;john&#39;), (&#39;joan&#39;), (&#39;wobbly&#39;), (&#39;jack&#39;);
INSERT 0 4
# SELECT * FROM s WHERE soundex(nm) = soundex(&#39;john&#39;);
  nm  
------
 john
 joan
(2 rows)
 
# SELECT * FROM s WHERE difference(s.nm, &#39;john&#39;) &gt; 2;
  nm  
------
 john
 joan
 jack
(3 rows)</code></pre>
<p>Функция levenshtein вычисляет расстояние Левенштейна<a href="#fn28" class="footnoteRef" id="fnref28"><sup>28</sup></a> между двумя строками. levenshtein_less_equal ускоряется функцию levenshtein для маленьких значений расстояния:</p>
<pre><code># SELECT levenshtein(&#39;GUMBO&#39;, &#39;GAMBOL&#39;);
 levenshtein
-------------
           2
(1 row)

# SELECT levenshtein(&#39;GUMBO&#39;, &#39;GAMBOL&#39;, 2, 1, 1);
 levenshtein
-------------
           3
(1 row)

# SELECT levenshtein_less_equal(&#39;extensive&#39;, &#39;exhaustive&#39;, 2);
 levenshtein_less_equal
------------------------
                      3
(1 row)

test=# SELECT levenshtein_less_equal(&#39;extensive&#39;, &#39;exhaustive&#39;, 4);
 levenshtein_less_equal
------------------------
                      4
(1 row)</code></pre>
<p>Функция metaphone, как и soundex, построена на идее создания кода для строки: две строки, которые будут считатся похожими, будут иметь одинаковые коды. Последним параметром указывается максимальная длина metaphone кода. Функция dmetaphone вычисляет два «как звучит» кода для строки — «первичный» и «альтернативный»:</p>
<pre><code># SELECT metaphone(&#39;GUMBO&#39;, 4);
 metaphone
-----------
 KM
(1 row)
# SELECT dmetaphone(&#39;postgresql&#39;);
 dmetaphone 
------------
 PSTK
(1 row)

# SELECT dmetaphone_alt(&#39;postgresql&#39;);
 dmetaphone_alt 
----------------
 PSTK
(1 row)</code></pre>
<h2 id="tsearch2">Tsearch2</h2>
<p><strong>Лицензия</strong>: Open Source</p>
<p>Tsearch2 – расширение для полнотекстового поиска. Встроен в PostgreSQL начиная с версии 8.3.</p>
<h2 id="openfts">OpenFTS</h2>
<p><strong>Лицензия</strong>: Open Source</p>
<p><strong>Ссылка</strong>: <a href="http://openfts.sourceforge.net/">openfts.sourceforge.net</a></p>
<p>OpenFTS (Open Source Full Text Search engine) является продвинутой PostgreSQL поисковой системой, которая обеспечивает онлайн индексирования данных и актуальность данных для поиска по базе. Тесная интеграция с базой данных позволяет использовать метаданные, чтобы ограничить результаты поиска.</p>
<h2 id="plproxy">PL/Proxy</h2>
<p><strong>Лицензия</strong>: Open Source</p>
<p><strong>Ссылка</strong>: <a href="http://pgfoundry.org/projects/plproxy/">pgfoundry.org/projects/plproxy</a></p>
<p>PL/Proxy представляет собой прокси-язык для удаленного вызова процедур и партицирования данных между разными базами. Подробнее можно почитать в главе.</p>
<h2 id="texcaller">Texcaller</h2>
<p><strong>Лицензия</strong>: Open Source</p>
<p><strong>Ссылка</strong>: <a href="http://www.profv.de/texcaller/">www.profv.de/texcaller</a></p>
<p>Texcaller — это удобный интерфейс для командной строки TeX, который обрабатывает все виды ошибок. Он написан в простом C, довольно портативный, и не имеет внешних зависимостей, кроме TeX. Неверный TeX документ обрабатывается путем простого возвращения NULL, а не прерывается с ошибкой. В случае неудачи, а также в случае успеха, дополнительная обработка информации осуществляется через NOTICEs.</p>
<h2 id="pgmemcache">Pgmemcache</h2>
<p><strong>Лицензия</strong>: Open Source</p>
<p><strong>Ссылка</strong>: <a href="http://pgfoundry.org/projects/pgmemcache/">pgfoundry.org/projects/pgmemcache</a></p>
<p>Pgmemcache — это PostgreSQL API библиотека на основе libmemcached для взаимодействия с memcached. С помощью данной библиотеки PostgreSQL может записывать, считывать, искать и удалять данные из memcached. Подробнее можно почитать в главе.</p>
<h2 id="prefix">Prefix</h2>
<p><strong>Лицензия</strong>: Open Source</p>
<p><strong>Ссылка</strong>: <a href="http://pgfoundry.org/projects/prefix">pgfoundry.org/projects/prefix</a></p>
<p>Prefix реализует поиск текста по префиксу (prefix @&gt; text). Prefix используется в приложениях телефонии, где маршрутизация вызовов и расходы зависят от вызывающего/вызываемого префикса телефонного номера оператора.</p>
<h2 id="dblink">Dblink</h2>
<p><strong>Лицензия</strong>: Open Source</p>
<p>Dblink – расширение, которое позволяет выполнять запросы к удаленным базам данных непосредственно из SQL, не прибегая к помощи внешних скриптов.</p>
<h2 id="ltree">Ltree</h2>
<p><strong>Лицензия</strong>: Open Source</p>
<p>Ltree – расширение, которое позволяет хранить древовидные структуры в виде меток, а также предоставляет широкие возможности поиска по ним. Реализация алгоритма <a href="http://en.wikipedia.org/wiki/Materialized_path">Materialized Path</a> (достаточно быстрый как на запись, так и на чтение).</p>
<h2 id="заключение-9">Заключение</h2>
<p>Расширения помогают улучшить работу PostgreSQL в решении специфических проблем. Расширяемость PostgreSQL позволяет создавать собственные расширения, или же наоборот, не нагружать СУБД лишним, не требуемым функционалом.</p>
<h1 id="бэкап-и-восстановление-postgresql">Бэкап и восстановление PostgreSQL</h1>
<h2 id="введение-14">Введение</h2>
<p>Любой хороший сисадмин знает — бэкапы нужны всегда. Насколько бы надежной ни казалась Ваша система, всегда может произойти случай, который был не учтен, и из-за которого могут быть потеряны данные.</p>
<p>Тоже самое касается и PostgreSQL баз данных. Бекапы должны быть! Посыпавшийся винчестер на сервере, ошибка в файловой системе, ошибка в другой программе, которая перетерла весь каталог PostgreSQL и многое другое приведет только к плачевному результату. И даже если у Вас репликация с множеством слейвов, это не означает, что система в безопасности — неверный запрос на мастер (DELETE, DROP), и у слейвов такая же порция данных (точнее их отсутствие).</p>
<p>Существуют три принципиально различных подхода к резервному копированию данных PostgreSQL:</p>
<ul>
<li><p>SQL бэкап;</p></li>
<li><p>Бекап уровня файловой системы;</p></li>
<li><p>Непрерывное резервное копирование.</p></li>
</ul>
<p>Каждый из этих подходов имеет свои сильные и слабые стороны.</p>
<h2 id="sql-бэкап">SQL бэкап</h2>
<p>Идея этого подхода в создании текстового файла с командами SQL. Такой файл можно передать обратно на сервер и воссоздать базу данных в том же состоянии, в котором она была во время бэкапа. У PostgreSQL для этого есть специальная утилита — pg_dump. Пример использования pg_dump:</p>
<pre><code>pg_dump dbname &gt; outfile</code></pre>
<p>Для восстановления такого бэкапа достаточно выполнить:</p>
<pre><code>psql dbname &lt; infile</code></pre>
<p>При этом базу данных «dbname» потребуется создать перед восстановлением. Также потребуется создать пользователей, которые имеют доступ к данным, которые восстанавливаются (это можно и не делать, но тогда просто в выводе восстановления будут ошибки). Если нам требуется, чтобы восстановление прекратилось при возникновении ошибки, тогда потребуется восстанавливать бэкап таким способом:</p>
<pre><code>psql --set ON_ERROR_STOP=on dbname &lt; infile</code></pre>
<p>Также, можно делать бэкап и сразу восстанавливать его в другую базу:</p>
<pre><code>pg_dump -h host1 dbname | psql -h host2 dbname</code></pre>
<p>После восстановления бэкапа желательно запустить «ANALYZE», чтобы оптимизатор запросов обновил статистику.</p>
<p>А что, если нужно сделать бэкап не одной базы данных, а всех, да и еще получить в бэкапе информацию про роли и таблицы? В таком случае у PostgreSQL есть утилита pg_dumpall. pg_dumpall используется для создания бэкапа данных всего кластера PostgreSQL:</p>
<pre><code>pg_dumpall &gt; outfile</code></pre>
<p>Для восстановления такого бэкапа достаточно выполнить от суперпользователя:</p>
<pre><code>psql -f infile postgres</code></pre>
<h3 id="sql-бэкап-больших-баз-данных">SQL бэкап больших баз данных</h3>
<p>Некоторые операционные системы имеют ограничения на максимальный размер файла, что может вызывать проблемы при создании больших бэкапов через pg_dump. К счастью, pg_dump можете бэкапить в стандартный вывод. Так что можно использовать стандартные инструменты Unix, чтобы обойти эту проблему. Есть несколько возможных способов:</p>
<ul>
<li><p><strong>Использовать сжатие для бэкапа.</strong></p>
<p>Можно использовать программу сжатия данных, например GZIP:</p>
<pre><code>pg_dump dbname | gzip &gt; filename.gz</code></pre>
<p>Восстановление:</p>
<pre><code>gunzip -c filename.gz | psql dbname</code></pre>
<p>или</p>
<pre><code>cat filename.gz | gunzip | psql dbname</code></pre></li>
<li><p><strong>Использовать команду split.</strong></p>
<p>Команда split позволяет разделить вывод в файлы меньшего размера, которые являются подходящими по размеру для файловой системы. Например, бэкап делится на куски по 1 мегабайту:</p>
<pre><code>pg_dump dbname | split -b 1m - filename</code></pre>
<p>Восстановление:</p>
<pre><code>cat filename* | psql dbname</code></pre></li>
<li><p><strong>Использовать пользовательский формат дампа pg_dump</strong></p>
<p>PostgreSQL построен на системе с библиотекой сжатия Zlib, поэтому пользовательский формат бэкапа будет в сжатом виде. Это похоже на метод с импользованием GZIP, но он имеет дополнительное преимущество — таблицы могут быть восстановлены выборочно:</p>
<pre><code>pg_dump -Fc dbname &gt; filename</code></pre>
<p>Через psql такой бэкап не восстановить, но для этого есть утилита pg_restore:</p>
<pre><code>pg_restore -d dbname filename</code></pre></li>
</ul>
<p>При слишком большой базе данных, вариант с командой split нужно комбинировать со сжатием данных.</p>
<h2 id="бекап-уровня-файловой-системы">Бекап уровня файловой системы</h2>
<p>Альтернативный метод резервного копирования заключается в непосредственном копировании файлов, которые PostgreSQL использует для хранения данных в базе данных. Например:</p>
<pre><code>tar -cf backup.tar /usr/local/pgsql/data</code></pre>
<p>Но есть два ограничения, которые делает этот метод нецелесообразным, или, по крайней мере, уступающим SQL бэкапу:</p>
<ul>
<li><p>PostgreSQL база данных должна быть остановлена, для того, чтобы получить актуальный бэкап (PostgreSQL держит множество объектов в памяти, буферизация файловой системы). Излишне говорить, что во время восстановления такого бэкапа потребуется также остановить PostgreSQL.</p></li>
<li><p>Не получится востановить только определенные данные с такого бэкапа.</p></li>
</ul>
<p>Как альтернатива, можно делать снимки (snapshot) файлов системы (папки с файлами PostgreSQL). В таком случае останавливать PostgreSQL не требуется. Однако, резервная копия, созданная таким образом, сохраняет файлы базы данных в состоянии, как если бы сервер базы данных был неправильно остановлен. Поэтому при запуске PostgreSQL из резервной копии, он будет думать, что предыдущий экземпляр сервера вышел из строя и повторит журнала WAL. Это не проблема, просто надо знать про это (и не забыть включить WAL файлы в резервную копию). Также, если файловая система PostgreSQL распределена по разным файловым система, то такой метод бэкапа будет очень ненадежным — снимки файлов системы должны быть сделаны одновременно(!!!). Почитайте документацию файловой системы очень внимательно, прежде чем доверять снимкам файлов системы в таких ситуациях.</p>
<p>Также возможен вариант с использованием rsync. Первым запуском rsync мы копируем основные файлы с директории PostgreSQL (PostgreSQL при этом продолжает работу). После этого мы останавливаем PostgreSQL и запускаем повторно rsync. Второй запуск rsync пройдет гораздо быстрее, чем первый, потому что будет передавать относительно небольшой размер данных, и конечный результат будет соответствовать остановленной СУБД. Этот метод позволяет делать бекап уровня файловой системы с минимальным временем простоя.</p>
<h2 id="непрерывное-резервное-копирование">Непрерывное резервное копирование</h2>
<p>PostgreSQL поддерживает упреждающую запись логов (Write Ahead Log, WAL) в pg_xlog директорию, которая находится в директории данных СУБД. В логи пишутся все изменения сделанные с данными в СУБД. Этот журнал существует прежде всего для безопасности во время краха PostgreSQL: если происходят сбои в системе, базы данных могут быть восстановлены с помощью «перезапуска» этого журнала. Тем не менее, существование журнала делает возможным использование третьей стратегии для резервного копирования баз данных: мы можем объединить бекап уровня файловой системы с резервной копией WAL файлов. Если требуется восстановить такой бэкап, то мы восстанавливаем файлы резервной копии файловой системы, а затем «перезапускаем» с резервной копии файлов WAL для приведения системы к актуальному состоянию. Этот подход является более сложным для администрирования, чем любой из предыдущих подходов, но он имеет некоторые преимущества:</p>
<ul>
<li><p>Не нужно согласовывать файлы резервной копии системы. Любая внутренняя противоречивость в резервной копии будет исправлена путем преобразования журнала (не отличается от того, что происходит во время восстановления после сбоя).</p></li>
<li><p>Восстановление состояния сервера для определенного момента времени.</p></li>
<li><p>Если мы постоянно будем «скармливать» файлы WAL на другую машину, которая была загружена с тех же файлов резервной базы, то у нас будет находящийся всегда в актуальном состоянии резервный сервер PostgreSQL (создание сервера горячего резерва).</p></li>
</ul>
<p>Как и бэкап файловой системы, этот метод может поддерживать только восстановление всей базы данных кластера. Кроме того, он требует много места для хранения WAL файлов.</p>
<h3 id="настройка-7">Настройка</h3>
<p>Первый шаг — активировать архивирование. Эта процедура будет копировать WAL файлы в архивный каталог из стандартного каталога pg_xlog. Это делается в файле postgresql.conf:</p>
<pre><code>archive_mode = on # enable archiving
archive_command = &#39;cp -v %p /data/pgsql/archives/%f&#39;
archive_timeout = 300 # timeout to close buffers</code></pre>
<p>После этого необходимо перенести файлы (в порядке их появления) в архивный каталог. Для этого можно использовать функцию rsync. Можно поставить функцию в cron и, таким образом, файлы могут автоматически перемещаться между хостами каждые несколько минут.</p>
<pre><code>rsync -avz --delete prod1:/data/pgsql/archives/ \
/data/pgsql/archives/ &gt; /dev/null</code></pre>
<p>В конце, необходимо скопировать файлы в каталог pg_xlog на сервере PostgreSQL (он должен быть в режиме восстановления). Для этого необходимо в каталоге данных PostgreSQL создать файл recovery.conf с заданной командой копирования файлов из архива в нужную директорию:</p>
<pre><code>restore_command = &#39;cp /data/pgsql/archives/%f &quot;%p&quot;&#39;</code></pre>
<p>Документация PostgreSQL предлагает хорошее описание настройки непрерывного копирования, поэтому я не углублялся в детали (например, как перенести директорию СУБД с одного сервера на другой, какие могут быть проблемы). Более подробно вы можете почитать по этой ссылке <a href="http://www.postgresql.org/docs/current/static/continuous-archiving.html">www.postgresql.org/docs/current/static/continuous-archiving.html</a>.</p>
<h2 id="утилиты-для-непрерывного-резервного-копирования">Утилиты для непрерывного резервного копирования</h2>
<p>Непрерывное резервное копирования один из лучших спрособ для создания бэкапов и восстановления их. Нередко бэкапы сохраняются на той же файловой системе, на которой расположена база данных. Это не очень безопасно, т.к. при выходе дисковой системы сервера из строя вы можете потерять все данные (и базу, и бэкапы), или попросту столкнуться с тем, что на жестком диске закончится свободное место. Поэтому лучше, когда бэкапы складываются на отдельный сервер или в «облачное хранилище» (например S3<a href="#fn29" class="footnoteRef" id="fnref29"><sup>29</sup></a>). Чтобы не писать свой «велосипед» для автоматизации этого процесса на сегодняшний день существует набор программ, которые облегчает процесс настройки и поддержки процесса создания бэкапов на основе непрерывного резервного копирования.</p>
<h3 id="wal-e">WAL-E</h3>
<p><strong>Ссылка</strong>: <a href="https://github.com/heroku/WAL-E">github.com/heroku/WAL-E</a></p>
<p>WAL-E предназначенная для непрерывной архивации PostgreSQL WAL-logs в S3 и управления использованием pg_start_backup и pg_stop_backup. Утилита написана на Python и разработана в компании <a href="http://www.heroku.com/">Heroku</a>, где её активно используют.</p>
<h4 id="установка-8">Установка</h4>
<p>У WAL-E есть пару зависимостей: lzop, psql, mbuffer, python 2.6+ и несколько python библиотек (gevent &gt;= 0.13, boto &gt;= 2.0). Также для удобства настроек переменных среды устанавливается daemontools. На Ubuntu это можно все поставить одной командой:</p>
<pre><code># PostgreSQL уже установлен
aptitude install git-core python-dev python-setuptools build-essential libevent-dev lzop mbuffer daemontools daemontools-run</code></pre>
<p>Теперь установим WAL-E:</p>
<pre><code>git clone git://github.com/heroku/WAL-E.git
cd WAL-E
python setup.py build
sudo python setup.py install</code></pre>
<p>После успешной установки можно начать работать с WAL-E.</p>
<h4 id="настройка-и-работа">Настройка и работа</h4>
<p>Как уже писалось, WAL-E сливает все данные в AWS S3, поэтому нам потребуются «Access Key ID» и «Secret Access Key» (эти данные можно найти в акаунте Amazon AWS). Команда для загрузки бэкапа всей базы данных в S3:</p>
<pre><code>AWS_SECRET_ACCESS_KEY=... wal-e                     \
  -k AWS_ACCESS_KEY_ID                                \
  --s3-prefix=s3://some-bucket/directory/or/whatever  \
  backup-push /var/lib/postgresql/9.2/main</code></pre>
<p>Где «s3-prefix» — URL, который содержит имя S3 бакета (bucket) и путь к папке, куда следует складывать резервные копии. Команда для загрузки WAL-логов на S3:</p>
<pre><code>AWS_SECRET_ACCESS_KEY=... wal-e                     \
  -k AWS_ACCESS_KEY_ID                                \
  --s3-prefix=s3://some-bucket/directory/or/whatever  \
  wal-push /var/lib/postgresql/9.2/main/pg_xlog/WAL_SEGMENT_LONG_HEX</code></pre>
<p>Для управления этими переменными окружения можно использовать команду envdir (идет в поставке с daemontools). Для этого создадим envdir каталог:</p>
<pre><code>$ mkdir -p /etc/wal-e.d/env
$ echo &quot;secret-key&quot; &gt; /etc/wal-e.d/env/AWS_SECRET_ACCESS_KEY
$ echo &quot;access-key&quot; &gt; /etc/wal-e.d/env/AWS_ACCESS_KEY_ID
$ echo &#39;s3://some-bucket/directory/or/whatever&#39; &gt; /etc/wal-e.d/env/WALE_S3_PREFIX
$ chown -R root:postgres /etc/wal-e.d</code></pre>
<p>После создания данного каталога появляется возможность запускать WAL-E команды гораздо проще и с меньшим риском случайного использования некорректных значений:</p>
<pre><code>$ envdir /etc/wal-e.d/env wal-e backup-push ...
$ envdir /etc/wal-e.d/env wal-e wal-push ...</code></pre>
<p>Теперь настроим PostgreSQL для сбрасывания WAL-логов в S3 c помощью WAL-E. Отредактируем postgresql.conf:</p>
<pre><code>wal_level = hot_standby # или archive, если PostgreSQL &lt; 9.0
archive_mode = on
archive_command = &#39;envdir /etc/wal-e.d/env /usr/local/bin/wal-e wal-push %p&#39;
archive_timeout = 60</code></pre>
<p>Лучше указать полный путь к WAL-E (можно узнать командой «which wal-e»), поскольку PostgreSQL может его не найти. После этого нужно перегрузить PostgreSQL. В логах базы вы должны увидеть что-то подобное:</p>
<pre><code>2012-11-07 14:52:19 UTC LOG:  database system was shut down at 2012-11-07 14:51:40 UTC
2012-11-07 14:52:19 UTC LOG:  database system is ready to accept connections
2012-11-07 14:52:19 UTC LOG:  autovacuum launcher started
2012-11-07T14:52:19.784+00 pid=7653 wal_e.worker.s3_worker INFO     MSG: begin archiving a file
        DETAIL: Uploading &quot;pg_xlog/000000010000000000000001&quot; to &quot;s3://cleverdb-pg-backups/pg/wal_005/000000010000000000000001.lzo&quot;.
2012-11-07 14:52:19 UTC LOG:  incomplete startup packet
2012-11-07T14:52:28.234+00 pid=7653 wal_e.worker.s3_worker INFO     MSG: completed archiving to a file 
        DETAIL: Archiving to &quot;s3://cleverdb-pg-backups/pg/wal_005/000000010000000000000001.lzo&quot; complete at 21583.3KiB/s. 
2012-11-07T14:52:28.341+00 pid=7697 wal_e.worker.s3_worker INFO     MSG: begin archiving a file
        DETAIL: Uploading &quot;pg_xlog/000000010000000000000002.00000020.backup&quot; to &quot;s3://cleverdb-pg-backups/pg/wal_005/000000010000000000000002.00000020.backup.lzo&quot;.
2012-11-07T14:52:34.027+00 pid=7697 wal_e.worker.s3_worker INFO     MSG: completed archiving to a file 
        DETAIL: Archiving to &quot;s3://cleverdb-pg-backups/pg/wal_005/000000010000000000000002.00000020.backup.lzo&quot; complete at 00KiB/s. 
2012-11-07T14:52:34.187+00 pid=7711 wal_e.worker.s3_worker INFO     MSG: begin archiving a file
        DETAIL: Uploading &quot;pg_xlog/000000010000000000000002&quot; to &quot;s3://cleverdb-pg-backups/pg/wal_005/000000010000000000000002.lzo&quot;.
2012-11-07T14:52:40.232+00 pid=7711 wal_e.worker.s3_worker INFO     MSG: completed archiving to a file 
        DETAIL: Archiving to &quot;s3://cleverdb-pg-backups/pg/wal_005/000000010000000000000002.lzo&quot; complete at 2466.67KiB/s. </code></pre>
<p>Если ничего похожего в логах не видно, тогда нужно смотреть что за ошибка появляется и исправлять её.</p>
<p>Для того, чтобы бэкапить всю базу достаточно выполнить данную команду:</p>
<pre><code>$ envdir /etc/wal-e.d/env wal-e backup-push /var/lib/postgresql/9.2/main
2012-11-07T14:49:26.174+00 pid=7493 wal_e.operator.s3_operator INFO     MSG: start upload postgres version metadata
        DETAIL: Uploading to s3://cleverdb-pg-backups/pg/basebackups_005/base_000000010000000000000006_00000032/extended_version.txt.
2012-11-07T14:49:32.783+00 pid=7493 wal_e.operator.s3_operator INFO     MSG: postgres version metadata upload complete
2012-11-07T14:49:32.859+00 pid=7493 wal_e.worker.s3_worker INFO     MSG: beginning volume compression
        DETAIL: Building volume 0.
...
HINT:  Check that your archive_command is executing properly.  pg_stop_backup can be canceled safely, but the database backup will not be usable without all the WAL segments.
NOTICE:  pg_stop_backup complete, all required WAL segments have been archived</code></pre>
<p>[fig:wal-e1]</p>
<p>[fig:wal-e2]</p>
<p>[fig:wal-e3]</p>
<p>Данный бэкап лучше делать раз в сутки (например, добавить в crontab). На рис [fig:wal-e1]-[fig:wal-e3] видно как хранятся бэкапы на S3. Все бэкапы сжаты через lzop<a href="#fn30" class="footnoteRef" id="fnref30"><sup>30</sup></a>. Данный алгоритм сжимает хуже чем gzip, но скорость сжатия намного быстрее (приблизительно 25Мб/сек используя 5% ЦПУ). Чтобы уменьшить нагрузку на чтение с жесткого диска бэкапы отправляются через mbuffer (опцией «cluster-read-rate-limit» можно ограничить скорость чтения, если это требуется).</p>
<p>Теперь перейдем к восстановлению данных. Для восстановления базы из резервной копии используется «backup-fetch» команда:</p>
<pre><code>$ sudo -u postgres bash -c &quot;envdir /etc/wal-e.d/env wal-e  --s3-prefix=s3://some-bucket/directory/or/whatever backup-fetch /var/lib/postgresql/9.2/main LATEST&quot;</code></pre>
<p>Где «LATEST» означает восстановится из последнего актуального бэкапа (PostgreSQL в это время должен быть остановлен). Для восстановления из более поздней резервной копии:</p>
<pre><code>$ sudo -u postgres bash -c &quot;envdir /etc/wal-e.d/env wal-e  --s3-prefix=s3://some-bucket/directory/or/whatever backup-fetch /var/lib/postgresql/9.2/main base_LONGWALNUMBER_POSITION_NUMBER&quot;</code></pre>
<p>Для получения списка доступных резервных копий есть команда «backup-list»:</p>
<pre><code>$ envdir /etc/wal-e.d/env wal-e backup-list
name	last_modified	expanded_size_bytes	wal_segment_backup_start	wal_segment_offset_backup_start	wal_segment_backup_stop	wal_segment_offset_backup_stop
base_000000010000000000000008_00000032	2012-11-07T14:00:07.000Z		000000010000000000000008	00000032		
base_00000001000000000000000C_00000032	2012-11-08T15:00:08.000Z		00000001000000000000000C	00000032</code></pre>
<p>После завершения работы с основной резервной копией для полного восстановления нужно считать WAL-логи (чтобы данные обновились до последнего состояния). Для этого используется recovery.conf:</p>
<pre><code>restore_command = &#39;envdir /etc/wal-e.d/env /usr/local/bin/wal-e wal-fetch &quot;%f&quot; &quot;%p&quot;&#39;</code></pre>
<p>После создания этого файла нужно запустить PostgreSQL. Через небольшой интервал времени база станет полностью восстановленной.</p>
<p>Для удаления старых резервных копий (или вообще всех) используется команда «delete»:</p>
<pre><code># удаления старых бэкапов старше base_00000004000002DF000000A6_03626144
$ envdir /etc/wal-e.d/env wal-e delete --confirm before base_00000004000002DF000000A6_03626144
# удаления всех бэкапов
$ envdir /etc/wal-e.d/env wal-e delete --confirm everything</code></pre>
<p>Без опции «confirm» команды будут запускаться и показывать, что будет удаляться, но фактического удаления не будет производиться (dry run).</p>
<h4 id="заключение-10">Заключение</h4>
<p>WAL-E помогает автоматизировать сбор резервных копий с PostgreSQL и хранить их в достаточно дешевом и надежном хранилище — Amazon S3.</p>
<h3 id="barman">Barman</h3>
<p><strong>Ссылка</strong>: <a href="http://www.pgbarman.org/">www.pgbarman.org</a></p>
<p>Barman, как и WAL-E, позволяет создать систему для бэкапа и восстановления PostgreSQL на основе непрерывного резервного копирования. Barman использует для хранения бэкапов отдельный сервер, который может собирать бэкапы как с одного, так и с нескольких PostgreSQL баз данных.</p>
<h4 id="установка-и-настройка-1">Установка и настройка</h4>
<p>Рассмотрим простом случай с одним экземпляром PostgreSQL (один сервер) и пусть его хост будет «pghost». Наша задача — автоматизировать сбор и хранение бэкапов этой базы на другом сервере (его хост будет «brhost»). Для взаимодействия эти два сервера должны быть полностью открыты по SSH (доступ без пароля, по ключам). Для этого можно использовать authorized_keys файл.</p>
<pre><code># Проверка подключения с сервера PostgreSQL (pghost)
ssh barman@brhost
# Проверка подключения с сервера бэкапов (brhost)
ssh postgres@pghost</code></pre>
<p>Далее нужно установить на сервере для бэкапов barman. Сам barman написан на python и имеет пару зависимостей: python 2.6+, rsync &gt;= 3.0.4 и python библиотеки (argh, psycopg2, python-dateutil &lt; 2.0 (для python 3.0 не нужен), distribute). На Ubuntu все зависимости можно поставить одной командой:</p>
<pre><code>aptitude install python-dev python-argh python-psycopg2 python-dateutil rsync python-setuptools</code></pre>
<p>Далее нужно установить barman:</p>
<pre><code># tar -xzf barman-1.1.1.tar.gz
# cd barman-1.1.1/
# python setup.py build
# sudo python setup.py install</code></pre>
<p>Теперь перейдем к серверу с PostgreSQL. Для того, чтобы barman мог подключаться к базе данных без проблем, нам нужно выставить настройки доступа в конфигах PostgreSQL:</p>
<pre><code>listen_adress = &#39;*&#39;</code></pre>
<pre><code>host  all  all  brhost/32  trust</code></pre>
<p>После этих изменений нужно перегрузить PostgreSQL. Теперь можем проверить с сервера бэкапов подключение к PostgreSQL:</p>
<pre><code>$ psql -c &#39;SELECT version()&#39; -U postgres -h pghost
                                                  version                                                   
------------------------------------------------------------------------------------------------------------
 PostgreSQL 9.2.1 on x86_64-unknown-linux-gnu, compiled by gcc (Ubuntu/Linaro 4.7.2-2ubuntu1) 4.7.2, 64-bit
(1 row)</code></pre>
<p>Далее создадим папку на сервере с бэкапами для хранения этих самых бэкапов:</p>
<pre><code># sudo mkdir -p /srv/barman    
# sudo chown barman:barman /srv/barman</code></pre>
<p>Для настройки barman создадим /etc/barman.conf:</p>
<pre><code>; Main directory
barman_home = /srv/barman

; Log location
log_file = /var/log/barman/barman.log

; Default compression level: possible values are None (default), bzip2, gzip or custom
compression = gzip

; &#39;main&#39; PostgreSQL Server configuration
[main]
; Human readable description
description =  &quot;Main PostgreSQL Database&quot;

; SSH options
ssh_command = ssh postgres@pghost

; PostgreSQL connection string
conninfo = host=pghost user=postgres</code></pre>
<p>Секция «main» (так мы назвали для barman наш PostgreSQL сервер) содержит настроки для подключения к PostgreSQL серверу и базе. Проверим настройки:</p>
<pre><code># barman show-server main
Server main:
	active: true
	description: Main PostgreSQL Database
	ssh_command: ssh postgres@pghost
	conninfo: host=pghost user=postgres
	backup_directory: /srv/barman/main
	basebackups_directory: /srv/barman/main/base
	wals_directory: /srv/barman/main/wals
	incoming_wals_directory: /srv/barman/main/incoming
	lock_file: /srv/barman/main/main.lock
	compression: gzip
	custom_compression_filter: None
	custom_decompression_filter: None
	retention_policy: None
	wal_retention_policy: None
	pre_backup_script: None
	post_backup_script: None
	current_xlog: None
	last_shipped_wal: None
	archive_command: None
	server_txt_version: 9.2.1
	data_directory: /var/lib/postgresql/9.2/main
	archive_mode: off
	config_file: /etc/postgresql/9.2/main/postgresql.conf
	hba_file: /etc/postgresql/9.2/main/pg_hba.conf
	ident_file: /etc/postgresql/9.2/main/pg_ident.conf

# barman check main
Server main:
	ssh: OK
	PostgreSQL: OK
	archive_mode: FAILED (please set it to &#39;on&#39;)
	archive_command: FAILED (please set it accordingly to documentation)
	directories: OK
	compression settings: OK</code></pre>
<p>Все хорошо, вот только PostgreSQL не настроен. Для этого на сервере с PostgreSQL отредактируем конфиг базы:</p>
<pre><code>wal_level = hot_standby # archive для PostgreSQL &lt; 9.0
archive_mode = on
archive_command = &#39;rsync -a %p barman@brhost:INCOMING_WALS_DIRECTORY/%f&#39;</code></pre>
<p>где «INCOMING_WALS_DIRECTORY» — директория для складывания WAL-логов. Её можно узнать из вывода команды «barman show-server main»(смотри листинг [lst:barman9], тут указано «/srv/barman/main/incoming»). После изменения настроек нужно перегрузить PostgreSQL. Теперь проверим статус на сервере бэкапов:</p>
<pre><code># barman check main
Server main:
	ssh: OK
	PostgreSQL: OK
	archive_mode: OK
	archive_command: OK
	directories: OK
	compression settings: OK</code></pre>
<p>Все готово. Для добавления нового сервера процедуру потребуется повторить, а в barman.conf добавить новый сервер.</p>
<h4 id="работа">Работа</h4>
<p>Получение списка серверов:</p>
<pre><code># barman list-server
main - Main PostgreSQL Database</code></pre>
<p>Запуск создания резервной копии PostgreSQL (сервер указывается последним параметром):</p>
<pre><code># barman backup main
Starting backup for server main in /srv/barman/main/base/20121109T090806
Backup start at xlog location: 0/3000020 (000000010000000000000003, 00000020)
Copying files.
Copy done.
Asking PostgreSQL server to finalize the backup.
Backup end at xlog location: 0/30000D8 (000000010000000000000003, 000000D8)
Backup completed</code></pre>
<p>Такую задачу лучше выполнять раз в сутки (добавить в cron).</p>
<p>Посмотреть список бэкапов для указаной базы:</p>
<pre><code># barman list-backup main
main 20121110T091608 - Fri Nov 10 09:20:58 2012 - Size: 1.0 GiB - WAL Size: 446.0 KiB
main 20121109T090806 - Fri Nov  9 09:08:10 2012 - Size: 23.0 MiB - WAL Size: 477.0 MiB</code></pre>
<p>Более подробная информация о выбраной резервной копии:</p>
<pre><code># barman show-backup main 20121110T091608
Backup 20121109T091608:
  Server Name       : main
  Status:           : DONE
  PostgreSQL Version: 90201
  PGDATA directory  : /var/lib/postgresql/9.2/main

  Base backup information:
    Disk usage      : 1.0 GiB
    Timeline        : 1
    Begin WAL       : 00000001000000000000008C
    End WAL         : 000000010000000000000092
    WAL number      : 7
    Begin time      : 2012-11-10 09:16:08.856884
    End time        : 2012-11-10 09:20:58.478531
    Begin Offset    : 32
    End Offset      : 3576096
    Begin XLOG      : 0/8C000020
    End XLOG        : 0/92369120

  WAL information:
    No of files     : 1
    Disk usage      : 446.0 KiB
    Last available  : 000000010000000000000093

  Catalog information:
    Previous Backup : 20121109T090806
    Next Backup     : - (this is the latest base backup)</code></pre>
<p>Также можно сжимать WAL-логи, которые накапливаются в каталогах командой «cron»:</p>
<pre><code># barman cron
Processing xlog segments for main
	000000010000000000000001
	000000010000000000000002
	000000010000000000000003
	000000010000000000000003.00000020.backup
	000000010000000000000004
	000000010000000000000005
	000000010000000000000006</code></pre>
<p>Эту команду требуется добавлять в cron. Частота выполнения данной команды зависит от того, как много WAL-логов накапливается (чем больше файлов - тем дольше она выполняется). Barman может сжимать WAL-логи через gzip, bzip2 или другой компрессор данных (команды для сжатия и распаковки задаются через custom_compression_filter и custom_decompression_filter соответственно).</p>
<p>Для восстановления базы из бэкапа используется команда «recover»:</p>
<pre><code># barman recover --remote-ssh-command &quot;ssh postgres@pghost&quot; main 20121109T090806 /var/lib/postgresql/9.2/main
Starting remote restore for server main using backup 20121109T090806 
Destination directory: /var/lib/postgresql/9.2/main
Copying the base backup.
Copying required wal segments.
The archive_command was set to &#39;false&#39; to prevent data losses.

Your PostgreSQL server has been successfully prepared for recovery!

Please review network and archive related settings in the PostgreSQL
configuration file before starting the just recovered instance.

WARNING: Before starting up the recovered PostgreSQL server,
please review also the settings of the following configuration
options as they might interfere with your current recovery attempt:

    data_directory = &#39;/var/lib/postgresql/9.1/main&#39;		# use data in another directory
    external_pid_file = &#39;/var/run/postgresql/9.1-main.pid&#39;		# write an extra PID file
    hba_file = &#39;/etc/postgresql/9.1/main/pg_hba.conf&#39;	# host-based authentication file
    ident_file = &#39;/etc/postgresql/9.1/main/pg_ident.conf&#39;	# ident configuration file</code></pre>
<p>Barman может восстановить базу из резервной копии на удаленном сервере через SSH (для этого есть опция «remote-ssh-command»). Также barman может восстановить базу используя PITR<a href="#fn31" class="footnoteRef" id="fnref31"><sup>31</sup></a>: для этого используются опции «target-time» (указывается время) или «target-xid» (id транзакции).</p>
<h4 id="заключение-11">Заключение</h4>
<p>Barman помогает автоматизировать сбор и хранение резервных копий PostgreSQL данных на отдельном сервере. Утилита проста, позволяет хранить и удобно управлять бэкапами нескольких PostgreSQL серверов.</p>
<h2 id="заключение-12">Заключение</h2>
<p>В любом случае, усилия и время, затраченные на создание оптимальной системы создания бэкапов, будут оправданы. Невозможно предугадать когда произойдут проблемы с базой данных, поэтому бэкапы должны быть настроены для PostgreSQL (особенно, если это продакшн система).</p>
<h1 id="стратегии-масштабирования-для-postgresql">Стратегии масштабирования для PostgreSQL</h1>
<h2 id="введение-15">Введение</h2>
<p>Многие разработчики крупных проектов сталкиваются с проблемой, когда один-единственный сервер базы данных никак не может справиться с нагрузками. Очень часто такие проблемы происходят из-за неверного проектирования приложения(плохая структура БД для приложения, отсутствие кеширования). Но в данном случае пусть у нас есть «идеальное» приложение, для которого оптимизированы все SQL запросы, используется кеширование, PostgreSQL настроен, но все равно не справляется с нагрузкой. Такая проблема может возникнуть как на этапе проектирования, так и на этапе роста приложения. И тут возникает вопрос: какую стратегию выбрать при возникновении подобной ситуации?</p>
<p>Если Ваш заказчик готов купить супер сервер за несколько тысяч долларов (а по мере роста — десятков тысяч и т.д.), чтобы сэкономить время разработчиков, но сделать все быстро, можете дальше эту главу не читать. Но такой заказчик — мифическое существо и, в основном, такая проблема ложится на плечи разработчиков.</p>
<h3 id="суть-проблемы">Суть проблемы</h3>
<p>Для того, что-бы сделать какой-то выбор, необходимо знать суть проблемы. Существуют два предела, в которые могут уткнуться сервера баз данных:</p>
<ul>
<li><p>Ограничение пропускной способности чтения данных;</p></li>
<li><p>Ограничение пропускной способности записи данных;</p></li>
</ul>
<p>Практически никогда не возникает одновременно две проблемы, по крайне мере, это маловероятно (если вы конечно не Twitter или Facebook пишете). Если вдруг такое происходит — возможно система неверно спроектирована, и её реализацию следует пересмотреть.</p>
<h2 id="проблема-чтения-данных">Проблема чтения данных</h2>
<p>Проблема с чтением данных обычно начинается, когда СУБД не в состоянии обеспечить то количество выборок, которое требуется. В основном такое происходит в блогах, новостных лентах и т.д. Хочу сразу отметить, что подобную проблему лучше решать внедрением кеширования, а потом уже думать как масштабировать СУБД.</p>
<h3 id="методы-решения">Методы решения</h3>
<ul>
<li><p><strong>PgPool-II v.3 + PostgreSQL v.9 с Streaming Replication</strong> — отличное решение для масштабирования на чтение, более подробно можно ознакомится по <a href="http://pgpool.projects.pgfoundry.org/contrib_docs/simple_sr_setting/index.html">ссылке</a>. Основные преимущества:</p>
<ul>
<li><p>Низкая задержка репликации между мастером и слейвом</p></li>
<li><p>Производительность записи падает незначительно</p></li>
<li><p>Отказоустойчивость (failover)</p></li>
<li><p>Пулы соединений</p></li>
<li><p>Интеллектуальная балансировка нагрузки – проверка задержки репликации между мастером и слейвом (сам проверяет pg_current_xlog_location и pg_last_xlog_receive_location).</p></li>
<li><p>Добавление слейвов СУБД без остановки pgpool-II</p></li>
<li><p>Простота в настройке и обслуживании</p></li>
</ul></li>
<li><p><strong>PgPool-II v.3 + PostgreSQL с Slony</strong> — аналогично предыдущему решению, но с использованием Slony. Основные преимущества:</p>
<ul>
<li><p>Отказоустойчивость (failover)</p></li>
<li><p>Пулы соединений</p></li>
<li><p>Интеллектуальная балансировка нагрузки – проверка задержки репликации между мастером и слейвом.</p></li>
<li><p>Добавление слейв СУБД без остановки pgpool-II</p></li>
<li><p>Можно использовать Postgresql ниже 9 версии</p></li>
</ul></li>
<li><p><strong>Postgres-XC</strong> — подробнее можно прочитать в главе.</p></li>
</ul>
<h2 id="проблема-записи-данных">Проблема записи данных</h2>
<p>Обычно такая проблема возникает в системах, которые производят анализ больших объемов данных (например ваш аналог Google Analytics). Данные активно пишутся и мало читаются (или читается только суммарный вариант собранных данных).</p>
<h3 id="методы-решения-1">Методы решения</h3>
<p>Один из самых популярных методов решение проблем — размазать нагрузку по времени с помощью систем очередей.</p>
<ul>
<li><p><strong>PgQ</strong> — это система очередей, разработанная на базе PostgreSQL. Разработчики — компания Skype. Используется в Londiste (подробнее ). Особенности:</p>
<ul>
<li><p>Высокая производительность благодаря особенностям PostgreSQL</p></li>
<li><p>Общая очередь, с поддержкой нескольких обработчиков и нескольких генераторов событий</p></li>
<li><p>PgQ гарантирует, что каждый обработчик увидит каждое событие как минимум один раз</p></li>
<li><p>События достаются из очереди «пачками» (batches)</p></li>
<li><p>Чистое API на SQL функциях</p></li>
<li><p>Удобный мониторинг</p></li>
</ul>
<p>Также можно воспользоваться еще одной утилитой — RabbitMQ. RabbitMQ — платформа, реализующая систему обмена сообщениями между компонентами программной системы (Message Oriented Middleware) на основе стандарта AMQP (Advanced Message Queuing Protocol). RabbitMQ выпускается под Mozilla Public License. RabbitMQ создан на основе испытанной Open Telecom Platform, обеспечивающий высокую надёжность и производительность промышленного уровня и написан на языке Erlang.</p></li>
<li><p><strong>Postgres-XC</strong> — подробнее можно прочитать в главе.</p></li>
</ul>
<h2 id="заключение-13">Заключение</h2>
<p>В данной главе показаны только несколько возможных вариантов решения задач масштабирования PostgreSQL. Таких стратегий существует огромное количество и каждая из них имеет как сильные, так и слабые стороны. Самое важное то, что выбор оптимальной стратегии масштабирования для решения поставленных задач остается на плечах разработчиков и/или администраторов СУБД.</p>
<h1 id="советы-по-разным-вопросам-performance-snippets">Советы по разным вопросам (Performance Snippets)</h1>
<h2 id="введение-16">Введение</h2>
<p>Иногда возникают очень интересные проблемы по работе с PostgreSQL, которые при нахождении ответа поражают своей лаконичностью, красотой и простым исполнением (а может и не простым). В данной главе я решил собрать интересные методы решения разных проблем, с которыми сталкиваются люди при работе с PostgreSQL. Я не являюсь огромным специалистом по данной теме, поэтому многие решения мне помогали находить люди из PostgreSQL комьюнити, а иногда хватало и поиска в интернете.</p>
<h2 id="советы">Советы</h2>
<h3 id="размер-объектов-в-базе-данных">Размер объектов в базе данных</h3>
<p>Данный запрос показывает размер объектов в базе данных (например, таблиц и индексов).</p>
<pre><code>SELECT nspname || &#39;.&#39; || relname AS &quot;relation&quot;,
    pg_size_pretty(pg_relation_size(C.oid)) AS &quot;size&quot;
  FROM pg_class C
  LEFT JOIN pg_namespace N ON (N.oid = C.relnamespace)
  WHERE nspname NOT IN (&#39;pg_catalog&#39;, &#39;information_schema&#39;)
  ORDER BY pg_relation_size(C.oid) DESC
  LIMIT 20;</code></pre>
<p>Пример вывода:</p>
<pre><code>relation        |    size    
------------------------+------------
 public.accounts        | 326 MB
 public.accounts_pkey   | 44 MB
 public.history         | 592 kB
 public.tellers_pkey    | 16 kB
 public.branches_pkey   | 16 kB
 public.tellers         | 16 kB
 public.branches        | 8192 bytes</code></pre>
<h3 id="размер-самых-больших-таблиц">Размер самых больших таблиц</h3>
<p>Данный запрос показывает размер самых больших таблиц в базе данных.</p>
<pre><code>SELECT nspname || &#39;.&#39; || relname AS &quot;relation&quot;,
    pg_size_pretty(pg_total_relation_size(C.oid)) AS &quot;total_size&quot;
  FROM pg_class C
  LEFT JOIN pg_namespace N ON (N.oid = C.relnamespace)
  WHERE nspname NOT IN (&#39;pg_catalog&#39;, &#39;information_schema&#39;)
    AND C.relkind &lt;&gt; &#39;i&#39;
    AND nspname !~ &#39;^pg_toast&#39;
  ORDER BY pg_total_relation_size(C.oid) DESC
  LIMIT 20;</code></pre>
<p>Пример вывода:</p>
<pre><code>relation            | total_size 
--------------------------------+------------
 public.actions                 | 4249 MB
 public.product_history_records | 197 MB
 public.product_updates         | 52 MB
 public.import_products         | 34 MB
 public.products                | 29 MB
 public.visits                  | 25 MB</code></pre>
<h3 id="средний-count">«Средний» count</h3>
<p>Данный метод позволяет узнать приблизительное количество записей в таблице. Для огромных таблиц этот метод работает быстрее, чем обыкновенный count.</p>
<pre><code>CREATE LANGUAGE plpgsql;
CREATE FUNCTION count_estimate(query text) RETURNS integer AS $$
DECLARE
    rec   record;
    rows  integer;
BEGIN
    FOR rec IN EXECUTE &#39;EXPLAIN &#39; || query LOOP
        rows := substring(rec.&quot;QUERY PLAN&quot; FROM &#39; rows=([[:digit:]]+)&#39;);
        EXIT WHEN rows IS NOT NULL;
    END LOOP;
 
    RETURN rows;
END;
$$ LANGUAGE plpgsql VOLATILE STRICT;</code></pre>
<p>Пример:</p>
<pre><code>CREATE TABLE foo (r double precision);
INSERT INTO foo SELECT random() FROM generate_series(1, 1000);
ANALYZE foo;

# SELECT count(*) FROM foo WHERE r &lt; 0.1;
 count 
-------
    92
(1 row)

# SELECT count_estimate(&#39;SELECT * FROM foo WHERE r &lt; 0.1&#39;);
 count_estimate 
----------------
             94
(1 row)</code></pre>
<h3 id="узнать-значение-по-умолчанию-у-поля-в-таблице">Узнать значение по умолчанию у поля в таблице</h3>
<p>Данный метод позволяет узнать значение по умолчанию у поля в таблице (заданное через DEFAULT).</p>
<pre><code>CREATE OR REPLACE FUNCTION ret_def(text,text,text) RETURNS text AS $$
SELECT 
  COLUMNS.column_default::text
FROM 
  information_schema.COLUMNS
  WHERE table_name = $2
  AND table_schema = $1
  AND column_name = $3
$$ LANGUAGE sql IMMUTABLE;</code></pre>
<p>Пример:</p>
<pre><code># SELECT ret_def(&#39;schema&#39;,&#39;table&#39;,&#39;column&#39;);

SELECT ret_def(&#39;public&#39;,&#39;image_files&#39;,&#39;id&#39;);
                 ret_def                 
-----------------------------------------
 nextval(&#39;image_files_id_seq&#39;::regclass)
(1 row)

SELECT ret_def(&#39;public&#39;,&#39;schema_migrations&#39;,&#39;version&#39;);
 ret_def 
---------
 
(1 row)</code></pre>
<h3 id="случайное-число-из-диапазона">Случайное число из диапазона</h3>
<p>Данный метод позволяет взять случайное число из указаного диапазона (целое или с плавающей запятой).</p>
<pre><code>CREATE OR REPLACE FUNCTION random(numeric, numeric)
RETURNS numeric AS
$$
   SELECT ($1 + ($2 - $1) * random())::numeric;
$$ LANGUAGE &#39;sql&#39; VOLATILE;</code></pre>
<p>Пример:</p>
<pre><code>SELECT random(1,10)::int, random(1,10);
 random |      random      
--------+------------------
      6 | 5.11675184825435
(1 row)

SELECT random(1,10)::int, random(1,10);
 random |      random      
--------+------------------
      7 | 1.37060070643201
(1 row)</code></pre>
<h3 id="алгоритм-луна">Алгоритм Луна</h3>
<p>Алгоритм Луна или формула Луна<a href="#fn32" class="footnoteRef" id="fnref32"><sup>32</sup></a> — алгоритм вычисления контрольной цифры, получивший широкую популярность. Он используется, в частности, при первичной проверке номеров банковских пластиковых карт, номеров социального страхования в США и Канаде. Алгоритм был разработан сотрудником компании «IBM» Хансом Петером Луном и запатентован в 1960 году.</p>
<p>Контрольные цифры вообще и алгоритм Луна в частности предназначены для защиты от случайных ошибок, а не преднамеренных искажений данных.</p>
<p>Алгоритм Луна реализован на чистом SQL. Обратите внимание, что эта реализация является чисто арифметической.</p>
<pre><code>CREATE OR REPLACE FUNCTION luhn_verify(int8) RETURNS BOOLEAN AS $$
-- Take the sum of the
-- doubled digits and the even-numbered undoubled digits, and see if
-- the sum is evenly divisible by zero.
SELECT
         -- Doubled digits might in turn be two digits. In that case,
         -- we must add each digit individually rather than adding the
         -- doubled digit value to the sum. Ie if the original digit was
         -- `6&#39; the doubled result was `12&#39; and we must add `1+2&#39; to the
         -- sum rather than `12&#39;.
         MOD(SUM(doubled_digit / INT8 &#39;10&#39; + doubled_digit % INT8 &#39;10&#39;), 10) = 0
FROM
-- Double odd-numbered digits (counting left with
-- least significant as zero). If the doubled digits end up
-- having values
-- &gt; 10 (ie they&#39;re two digits), add their digits together.
(SELECT
         -- Extract digit `n&#39; counting left from least significant
         -- as zero
         MOD( ( $1::int8 / (10^n)::int8 ), 10::int8)
         -- Double odd-numbered digits
         * (MOD(n,2) + 1)
         AS doubled_digit
         FROM generate_series(0, CEIL(LOG( $1 ))::INTEGER - 1) AS n
) AS doubled_digits;
 
$$ LANGUAGE &#39;SQL&#39;
IMMUTABLE
STRICT;
 
COMMENT ON FUNCTION luhn_verify(int8) IS &#39;Return true iff the last digit of the
input is a correct check digit for the rest of the input according to Luhn&#39;&#39;s
algorithm.&#39;;
CREATE OR REPLACE FUNCTION luhn_generate_checkdigit(int8) RETURNS int8 AS $$
SELECT
     -- Add the digits, doubling even-numbered digits (counting left
     -- with least-significant as zero). Subtract the remainder of
     -- dividing the sum by 10 from 10, and take the remainder
     -- of dividing that by 10 in turn.
     ((INT8 &#39;10&#39; - SUM(doubled_digit / INT8 &#39;10&#39; + doubled_digit % INT8 &#39;10&#39;) %
                       INT8 &#39;10&#39;) % INT8 &#39;10&#39;)::INT8
FROM (SELECT
         -- Extract digit `n&#39; counting left from least significant\
         -- as zero
         MOD( ($1::int8 / (10^n)::int8), 10::int8 )
         -- double even-numbered digits
         * (2 - MOD(n,2))
         AS doubled_digit
         FROM generate_series(0, CEIL(LOG($1))::INTEGER - 1) AS n
) AS doubled_digits;
 
$$ LANGUAGE &#39;SQL&#39;
IMMUTABLE
STRICT;
 
COMMENT ON FUNCTION luhn_generate_checkdigit(int8) IS &#39;For the input
value, generate a check digit according to Luhn&#39;&#39;s algorithm&#39;;
CREATE OR REPLACE FUNCTION luhn_generate(int8) RETURNS int8 AS $$
SELECT 10 * $1 + luhn_generate_checkdigit($1);
$$ LANGUAGE &#39;SQL&#39;
IMMUTABLE
STRICT;
 
COMMENT ON FUNCTION luhn_generate(int8) IS &#39;Append a check digit generated
according to Luhn&#39;&#39;s algorithm to the input value. The input value must be no
greater than (maxbigint/10).&#39;;
CREATE OR REPLACE FUNCTION luhn_strip(int8) RETURNS int8 AS $$
SELECT $1 / 10;
$$ LANGUAGE &#39;SQL&#39;
IMMUTABLE
STRICT;
 
COMMENT ON FUNCTION luhn_strip(int8) IS &#39;Strip the least significant digit from
the input value. Intended for use when stripping the check digit from a number
including a Luhn&#39;&#39;s algorithm check digit.&#39;;</code></pre>
<p>Пример:</p>
<pre><code>Select luhn_verify(49927398716);
 luhn_verify 
-------------
 t
(1 row)

Select luhn_verify(49927398714);
 luhn_verify 
-------------
 f
(1 row)</code></pre>
<h3 id="выборка-и-сортировка-по-данному-набору-данных">Выборка и сортировка по данному набору данных</h3>
<p>Выбор данных по определенному набору данных можно сделать с помощью обыкновенного IN. Но как сделать подобную выборку и отсортировать данные в том же порядке, в котором передан набор данных. Например:</p>
<p>Дан набор: (2,6,4,10,25,7,9) Нужно получить найденные данные в таком же порядке т.е. 2 2 2 6 6 4 4</p>
<pre><code>SELECT foo.* FROM foo                                           
JOIN (SELECT id.val, row_number() over() FROM (VALUES(3),(2),(6),(1),(4)) AS
id(val)) AS id
ON (foo.catalog_id = id.val) ORDER BY row_number;</code></pre>
<p>где</p>
<p>VALUES(3),(2),(6),(1),(4) — наш набор данных</p>
<p>foo – таблица, из которой идет выборка</p>
<p>foo.catalog_id — поле, по которому ищем набор данных (замена foo.catalog_id IN(3,2,6,1,4))</p>
<h3 id="quine-запрос-который-выводит-сам-себя">Quine — запрос который выводит сам себя</h3>
<p>Куайн, квайн (англ. quine) — компьютерная программа (частный случай метапрограммирования), которая выдаёт на выходе точную копию своего исходного текста.</p>
<pre><code>select a || &#39; from (select &#39; || quote_literal(a) || b || &#39;, &#39; || quote_literal(b) || &#39;::text as b) as quine&#39; from 
(select &#39;select a || &#39;&#39; from (select &#39;&#39; || quote_literal(a) || b || &#39;&#39;, &#39;&#39; || quote_literal(b) || &#39;&#39;::text as b) as 
quine&#39;&#39;&#39;::text as a, &#39;::text as a&#39;::text as b) as quine;</code></pre>
<h3 id="ускоряем-like">Ускоряем LIKE</h3>
<p>Автокомплит — очень популярная фишка в web системах. Реализуется это простым LIKE «some%», где «some» — то, что пользователь успел ввести. Проблема в том, что и в огромной таблице (например таблица тегов) такой запрос будет работать очень медленно.</p>
<p>Для ускорения запроса типа «LIKE ’bla%’» можно использовать text_pattern_ops (или varchar_pattern_ops если у поле varchar).</p>
<pre><code>prefix_test=# create table tags (
prefix_test(#  tag    text primary key,
prefix_test(#  name      text not null,
prefix_test(#  shortname text,
prefix_test(#  status    char default &#39;S&#39;,
prefix_test(# 
prefix_test(#  check( status in (&#39;S&#39;, &#39;R&#39;) )
prefix_test(# );
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index &quot;tags_pkey&quot; for table &quot;tags&quot;
CREATE TABLE
prefix_test=# CREATE INDEX i_tag ON tags USING btree(lower(tag)  text_pattern_ops);
CREATE INDEX

prefix_test=# create table invalid_tags (
prefix_test(#  tag    text primary key,
prefix_test(#  name      text not null,
prefix_test(#  shortname text,
prefix_test(#  status    char default &#39;S&#39;,
prefix_test(# 
prefix_test(#  check( status in (&#39;S&#39;, &#39;R&#39;) )
prefix_test(# );
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index &quot;invalid_tags_pkey&quot; for table &quot;invalid_tags&quot;
CREATE TABLE



prefix_test=# select count(*) from tags;
 count 
-------
 11966
(1 row)

prefix_test=# select count(*) from invalid_tags;
 count 
-------
 11966
(1 row)

# EXPLAIN ANALYZE select * from invalid_tags where lower(tag) LIKE lower(&#39;0146%&#39;);
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Seq Scan on invalid_tags  (cost=0.00..265.49 rows=60 width=26) (actual time=0.359..20.695 rows=1 loops=1)
   Filter: (lower(tag) ~~ &#39;0146%&#39;::text)
 Total runtime: 20.803 ms
(3 rows)

# EXPLAIN ANALYZE select * from invalid_tags where lower(tag) LIKE lower(&#39;0146%&#39;);
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Seq Scan on invalid_tags  (cost=0.00..265.49 rows=60 width=26) (actual time=0.549..19.503 rows=1 loops=1)
   Filter: (lower(tag) ~~ &#39;0146%&#39;::text)
 Total runtime: 19.550 ms
(3 rows)

# EXPLAIN ANALYZE select * from tags where lower(tag) LIKE lower(&#39;0146%&#39;);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on tags  (cost=5.49..97.75 rows=121 width=26) (actual time=0.054..0.057 rows=1 loops=1)
   Filter: (lower(tag) ~~ &#39;0146%&#39;::text)
   -&gt;  Bitmap Index Scan on i_tag (cost=0.00..5.46 rows=120 width=0) (actual time=0.032..0.032 rows=1 loops=1)
         Index Cond: ((lower(tag) ~&gt;=~ &#39;0146&#39;::text) AND (lower(tag) ~&lt;~ &#39;0147&#39;::text))
 Total runtime: 0.119 ms
(5 rows)

# EXPLAIN ANALYZE select * from tags where lower(tag) LIKE lower(&#39;0146%&#39;);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on tags  (cost=5.49..97.75 rows=121 width=26) (actual time=0.025..0.025 rows=1 loops=1)
   Filter: (lower(tag) ~~ &#39;0146%&#39;::text)
   -&gt;  Bitmap Index Scan on i_tag (cost=0.00..5.46 rows=120 width=0) (actual time=0.016..0.016 rows=1 loops=1)
         Index Cond: ((lower(tag) ~&gt;=~ &#39;0146&#39;::text) AND (lower(tag) ~&lt;~ &#39;0147&#39;::text))
 Total runtime: 0.050 ms
(5 rows)</code></pre>
<h3 id="поиск-дубликатов-индексов">Поиск дубликатов индексов</h3>
<p>Запрос находит индексы, созданные на одинаковый набор столбцов (такие индексы эквивалентны, а значит бесполезны).</p>
<pre><code>SELECT pg_size_pretty(sum(pg_relation_size(idx))::bigint) AS size,
       (array_agg(idx))[1] AS idx1, (array_agg(idx))[2] AS idx2,
       (array_agg(idx))[3] AS idx3, (array_agg(idx))[4] AS idx4
FROM (
    SELECT indexrelid::regclass AS idx, (indrelid::text ||E&#39;\n&#39;|| indclass::text ||E&#39;\n&#39;|| indkey::text ||E&#39;\n&#39;||
                                         coalesce(indexprs::text,&#39;&#39;)||E&#39;\n&#39; || coalesce(indpred::text,&#39;&#39;)) AS KEY
    FROM pg_index) sub
GROUP BY KEY HAVING count(*)&gt;1
ORDER BY sum(pg_relation_size(idx)) DESC;</code></pre>
<h3 id="размер-и-статистика-использования-индексов">Размер и статистика использования индексов</h3>
<pre><code>SELECT
    t.tablename,
    indexname,
    c.reltuples AS num_rows,
    pg_size_pretty(pg_relation_size(quote_ident(t.tablename)::text)) AS table_size,
    pg_size_pretty(pg_relation_size(quote_ident(indexrelname)::text)) AS index_size,
    CASE WHEN x.is_unique = 1  THEN &#39;Y&#39;
       ELSE &#39;N&#39;
    END AS UNIQUE,
    idx_scan AS number_of_scans,
    idx_tup_read AS tuples_read,
    idx_tup_fetch AS tuples_fetched
FROM pg_tables t
LEFT OUTER JOIN pg_class c ON t.tablename=c.relname
LEFT OUTER JOIN
       (SELECT indrelid,
           max(CAST(indisunique AS integer)) AS is_unique
       FROM pg_index
       GROUP BY indrelid) x
       ON c.oid = x.indrelid
LEFT OUTER JOIN
    ( SELECT c.relname AS ctablename, ipg.relname AS indexname, x.indnatts AS number_of_columns, idx_scan, idx_tup_read, idx_tup_fetch,indexrelname FROM pg_index x
           JOIN pg_class c ON c.oid = x.indrelid
           JOIN pg_class ipg ON ipg.oid = x.indexrelid
           JOIN pg_stat_all_indexes psai ON x.indexrelid = psai.indexrelid )
    AS foo
    ON t.tablename = foo.ctablename
WHERE t.schemaname=&#39;public&#39;
ORDER BY 1,2;</code></pre>
<p><span>9</span></p>
<p>Алексей Борзов (Sad Spirit) borz_off@cs.msu.su <em>PostgreSQL: настройка производительности</em> http://www.phpclub.ru/detail/store/pdf/postgresql-performance.pdf</p>
<p>Eugene Kuzin eugene@kuzin.net <em>Настройка репликации в PostgreSQL с помощью системы Slony-I</em> http://www.kuzin.net/work/sloniki-privet.html</p>
<p>Sergey Konoplev gray.ru@gmail.com <em>Установка Londiste в подробностях</em> http://gray-hemp.blogspot.com/2010/04/londiste.html</p>
<p>Dmitry Stasyuk <em>Учебное руководство по pgpool-II</em> http://undenied.ru/2009/03/04/uchebnoe-rukovodstvo-po-pgpool-ii/</p>
<p>Чиркин Дима dmitry.chirkin@gmail.com <em>Горизонтальное масштабирование PostgreSQL с помощью PL/Proxy</em> http://habrahabr.ru/blogs/postgresql/45475/</p>
<p>Иван Блинков wordpress@insight-it.ru <em>Hadoop</em> http://www.insight-it.ru/masshtabiruemost/hadoop/</p>
<p>Padraig O’Sullivan <em>Up and Running with HadoopDB</em> http://posulliv.github.com/2010/05/10/hadoopdb-mysql.html</p>
<p>Иван Золотухин <em>Масштабирование PostgreSQL: готовые решения от Skype</em> http://postgresmen.ru/articles/view/25</p>
<p><em>Streaming Replication</em>. http://wiki.postgresql.org/wiki/Streaming_Replication</p>
<p>Den Golotyuk <em>Шардинг, партиционирование, репликация - зачем и когда?</em> http://highload.com.ua/index.php/2009/05/06/шардинг-партиционирование-репликац/</p>
<p><em>Postgres-XC — A PostgreSQL Clustering Solution</em> http://www.linuxforu.com/2012/01/postgres-xc-database-clustering-solution/</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>под которым понимаются старые версии изменённых/удалённых записей<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>«слишком часто» можно определить как «чаще раза в минуту». Вы также можете задать параметр checkpoint_warning (в секундах): в журнал сервера будут писаться предупреждения, если контрольные точки происходят чаще заданного.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>буфер находится в разделяемой памяти и является общим для всех процессов<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Указывает планировщику на размер самого большого объекта в базе данных, который теоретически может быть закеширован<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>при этом не будет отслеживаться время последнего доступа к файлу<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>http://pgtune.projects.postgresql.org/<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>и поэтому EXPLAIN ANALYZE DELETE … — не слишком хорошая идея<a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>RULE — реализованное в PostgreSQL расширение стандарта SQL, позволяющее, в частности, создавать обновляемые представления<a href="#fnref8">↩</a></p></li>
<li id="fn9"><p>«на нашем форуме более 10000 зарегистрированных пользователей, оставивших более 50000 сообщений!»<a href="#fnref9">↩</a></p></li>
<li id="fn10"><p>http://pgfouine.projects.pgfoundry.org/<a href="#fnref10">↩</a></p></li>
<li id="fn11"><p>http://dalibo.github.com/pgbadger/<a href="#fnref11">↩</a></p></li>
<li id="fn12"><p>http://pgfoundry.org/projects/skytools/<a href="#fnref12">↩</a></p></li>
<li id="fn13"><p>http://search.cpan.org/CPAN/authors/id/T/TU/TURNSTEP/<a href="#fnref13">↩</a></p></li>
<li id="fn14"><p>http://bucardo.org/wiki/Bucardo#Obtaining_Bucardo<a href="#fnref14">↩</a></p></li>
<li id="fn15"><p>http://pgfoundry.org/projects/plproxy<a href="#fnref15">↩</a></p></li>
<li id="fn16"><p>http://en.wikipedia.org/wiki/CAP_theorem<a href="#fnref16">↩</a></p></li>
<li id="fn17"><p>http://sourceforge.net/projects/hadoopdb/files/<a href="#fnref17">↩</a></p></li>
<li id="fn18"><p>http://jdbc.postgresql.org/download.html<a href="#fnref18">↩</a></p></li>
<li id="fn19"><p>http://memcached.org/<a href="#fnref19">↩</a></p></li>
<li id="fn20"><p>http://pgfoundry.org/projects/pgmemcache/<a href="#fnref20">↩</a></p></li>
<li id="fn21"><p>http://pgfoundry.org/frs/download.php/2672/pgmemcache_2.0.4.tar.bz2<a href="#fnref21">↩</a></p></li>
<li id="fn22"><p>http://en.wikipedia.org/wiki/V8_(JavaScript_engine)<a href="#fnref22">↩</a></p></li>
<li id="fn23"><p>http://mustache.github.com/<a href="#fnref23">↩</a></p></li>
<li id="fn24"><p>http://en.wikipedia.org/wiki/Fingerprint<a href="#fnref24">↩</a></p></li>
<li id="fn25"><p>http://en.wikipedia.org/wiki/N-gram<a href="#fnref25">↩</a></p></li>
<li id="fn26"><p>http://en.wikipedia.org/wiki/Law_of_cosines<a href="#fnref26">↩</a></p></li>
<li id="fn27"><p>http://en.wikipedia.org/wiki/Tf*idf<a href="#fnref27">↩</a></p></li>
<li id="fn28"><p>http://en.wikipedia.org/wiki/Levenshtein_distance<a href="#fnref28">↩</a></p></li>
<li id="fn29"><p>http://aws.amazon.com/s3/<a href="#fnref29">↩</a></p></li>
<li id="fn30"><p>http://en.wikipedia.org/wiki/Lzop<a href="#fnref30">↩</a></p></li>
<li id="fn31"><p>http://en.wikipedia.org/wiki/Point-in-time_recovery<a href="#fnref31">↩</a></p></li>
<li id="fn32"><p>http://en.wikipedia.org/wiki/Luhn_algorithm<a href="#fnref32">↩</a></p></li>
</ol>
</div>
</body>
</html>
